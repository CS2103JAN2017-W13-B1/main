# A0138423J
###### \java\utask\commons\util\UpdateUtil.java
``` java
public class UpdateUtil {

    public static final String TO_BE_REMOVED = "-";

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    public static ReadOnlyTask fetchTaskToEdit(int index) {
        assert index >= 0;
        List<ReadOnlyTask> lastShownList = UTFilteredListHelper.getInstance()
                .getUnderlyingListByIndex(index);
        int actualInt = UTFilteredListHelper.getInstance()
                .getActualIndexFromDisplayIndex(index);

        return lastShownList.get(actualInt);
    }

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    /**
     * Checks {@code updatedDeadline} and {@code updatedTimestamp} to see
     * whether both are empty or not. Subsequently, based on the statuses, this
     * method will determine the type of editedTask. Types are pre-set based on
     * Enum {@code TaskType}
     */
    public static TaskType typeOfEditedTask(Deadline updatedDeadline,
            Timestamp updatedTimestamp) {
        assert updatedDeadline != null;
        assert updatedTimestamp != null;

        Boolean isDeadlineEmpty = false;
        if (updatedDeadline.equals(Deadline.getEmptyDeadline())) {
            isDeadlineEmpty = true;
        }
        Boolean isTimestampEmpty = false;
        if (updatedTimestamp.equals(Timestamp.getEmptyTimestamp())) {
            isTimestampEmpty = true;
        }
        if (!isDeadlineEmpty && !isTimestampEmpty) {
            return TaskType.EVENT;
        } else if (!isDeadlineEmpty && isTimestampEmpty) {
            return TaskType.DEADLINE;
        } else if (isDeadlineEmpty && isTimestampEmpty) {
            return TaskType.FLOATING;
        }
        return TaskType.UNKNOWN;
    }

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    public static Task createEditedTask(ReadOnlyTask taskToEdit, String value)
            throws IllegalValueException {
        assert taskToEdit != null;
        assert value != null;

        Task placeholder = null;
        switch (typeOfEditedTask(taskToEdit.getDeadline(),
                taskToEdit.getTimestamp())) {
        case FLOATING:
            placeholder = new FloatingTask(taskToEdit.getName(),
                    taskToEdit.getFrequency(), taskToEdit.getTags(),
                    new Status(value.toString()));
            break;
        case DEADLINE:
            placeholder = new DeadlineTask(taskToEdit.getName(),
                    taskToEdit.getDeadline(), taskToEdit.getFrequency(),
                    taskToEdit.getTags(), new Status(value));
            break;
        case EVENT:
            placeholder = new EventTask(taskToEdit.getName(),
                    taskToEdit.getDeadline(), taskToEdit.getTimestamp(),
                    taskToEdit.getFrequency(), taskToEdit.getTags(),
                    new Status(value.toString()));
            break;
        default:
            assert false : "Should never come to this default";
        }
        return placeholder;
    }

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    public static Task createEditedTask(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Name updatedName = editTaskDescriptor.getName()
                .orElseGet(taskToEdit::getName);
        Status updatedIsCompleted = editTaskDescriptor.getStatus()
                .orElseGet(taskToEdit::getStatus);
        Deadline updatedDeadline = updateOrRemoveDeadline(taskToEdit,
                editTaskDescriptor, attributeToRemove);
        Timestamp updatedTimestamp = updateOrRemoveTimestamp(taskToEdit,
                editTaskDescriptor, attributeToRemove);
        Frequency updatedFrequency = updateOrRemoveFrequency(taskToEdit,
                editTaskDescriptor, attributeToRemove);
        UniqueTagList updatedTags = updateOrRemoveUniqueTagList(taskToEdit,
                editTaskDescriptor, attributeToRemove);

        Task placeholder = null;
        switch (typeOfEditedTask(updatedDeadline, updatedTimestamp)) {
        case FLOATING:
            placeholder = new FloatingTask(updatedName, updatedFrequency,
                    updatedTags, updatedIsCompleted);
            break;
        case DEADLINE:
            placeholder = new DeadlineTask(updatedName, updatedDeadline,
                    updatedFrequency, updatedTags, updatedIsCompleted);
            break;
        case EVENT:
            placeholder = new EventTask(updatedName, updatedDeadline,
                    updatedTimestamp, updatedFrequency, updatedTags,
                    updatedIsCompleted);
            break;
        default:
            assert false : "Should never come to this default";
        }
        return placeholder;
    }

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    /**
     * Creates and returns a {@code Deadline} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove Deadline field based on
     * {@code attributeToRemove}
     */
    private static Deadline updateOrRemoveDeadline(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Deadline updatedDeadline = editTaskDescriptor.getDeadline()
                .orElseGet(taskToEdit::getDeadline);
        if (attributeToRemove.contains(Attribute.DEADLINE)) {
            updatedDeadline = Deadline.getEmptyDeadline();
        }
        return updatedDeadline;
    }

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    /**
     * Creates and returns a {@code Timestamp} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove Timestamp field based on
     * {@code attributeToRemove}
     */
    private static Timestamp updateOrRemoveTimestamp(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Timestamp updatedTimestamp = editTaskDescriptor.getTimeStamp()
                .orElseGet(taskToEdit::getTimestamp);
        if (attributeToRemove.contains(Attribute.TIMESTAMP)) {
            updatedTimestamp = Timestamp.getEmptyTimestamp();
        }
        return updatedTimestamp;
    }

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    /**
     * Creates and returns a {@code UniqueTagList} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove UniqueTagList field based on
     * {@code attributeToRemove}
     */
    private static Frequency updateOrRemoveFrequency(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Frequency updatedFrequency = editTaskDescriptor.getFrequency()
                .orElseGet(taskToEdit::getFrequency);
        if (attributeToRemove.contains(Attribute.FREQUENCY)) {
            updatedFrequency = Frequency.getEmptyFrequency();
        }
        return updatedFrequency;
    }

```
###### \java\utask\commons\util\UpdateUtil.java
``` java
    /**
     * Creates and returns a {@code UniqueTagList} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove UniqueTagList field based on
     * {@code attributeToRemove}
     */
    private static UniqueTagList updateOrRemoveUniqueTagList(
            ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        UniqueTagList updatedTags = editTaskDescriptor.getTags()
                .orElseGet(taskToEdit::getTags);
        if (attributeToRemove.contains(Attribute.TAG)) {
            updatedTags = new UniqueTagList();
        }
        return updatedTags;
    }
}
```
###### \java\utask\logic\commands\DoneCommand.java
``` java
/**
 * Edits the Status of an existing task in the uTask.
 */
public class DoneCommand extends Command implements ReversibleCommand {
    private final Logger logger = LogsCenter.getLogger(DoneCommand.class);

    public static final String COMMAND_WORD = "done";
    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";
    public static final String STATUS_TO = "COMPLETE";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the status to Complete of the task specified "
            + "by the index number used in the last task listing. \n"
            + "Parameters: " + COMMAND_FORMAT + "\n" + "Example: "
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_DONE_TASK_SUCCESS = "Done task: %1$s";
    public static final String MESSAGE_NOT_DONE = "A number for index must be provided.";
    public static final String MESSAGE_DUPLICATE_STATUS = "This task is already completed in uTask.";
    public static final String MESSAGE_INTERNAL_ERROR = "Error updating Status.";

    private final int filteredTaskListIndex;
    private ReadOnlyTask taskToEdit;
    private Task editedTask;

```
###### \java\utask\logic\commands\DoneCommand.java
``` java
    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     */
    public DoneCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

```
###### \java\utask\logic\commands\DoneCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        if (filteredTaskListIndex >= model.getTotalSizeOfLists()) {
            throw new CommandException(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        // Retrieve task to be edited from save file
        taskToEdit = UpdateUtil.fetchTaskToEdit(filteredTaskListIndex);
        // If value already completed, inform the user
        if (taskToEdit.getStatus().isStatusComplete()) {
            throw new CommandException(MESSAGE_DUPLICATE_STATUS);
        }
        editedTask = null;
        try {

            editedTask = UpdateUtil.createEditedTask(taskToEdit, STATUS_TO);
            notifyUI(taskToEdit);

            // BAD CODE -- BAD CODE -- BAD CODE
            new DelayedExecution((e) -> {
                try {
                    model.updateTask(taskToEdit, editedTask);
                    model.addUndoCommand(this);
                } catch (DuplicateTaskException e1) {
                    assert false : "Should never happen?";
                }
            }).run();
        } catch (IllegalValueException e) {
            throw new CommandException(MESSAGE_INTERNAL_ERROR);
        }
        logger.fine(String.format(MESSAGE_DONE_TASK_SUCCESS, editedTask));
        return new CommandResult(
                String.format(MESSAGE_DONE_TASK_SUCCESS, editedTask));
    }

```
###### \java\utask\logic\commands\DoneCommand.java
``` java
    @Override
    public void undo() throws Exception {
        model.updateTask(editedTask, taskToEdit);
        notifyUI(taskToEdit);
    }

```
###### \java\utask\logic\commands\DoneCommand.java
``` java
    @Override
    public void redo() throws Exception {
        model.updateTask(taskToEdit, editedTask);
        notifyUI(editedTask);
    }
}
```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
/**
 * Edits the details of an existing task in the uTask.
 */
public class UndoneCommand extends Command implements ReversibleCommand {
    private final Logger logger = LogsCenter.getLogger(UndoneCommand.class);

    public static final String COMMAND_WORD = "undone";
    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";
    public static final String STATUS_TO = "INCOMPLETE";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the status to Incomplete of the task specified "
            + "by the index number used in the last task listing. \n"
            + "Parameters: " + COMMAND_FORMAT + "\n" + "Example: "
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNDONE_TASK_SUCCESS = "Undone task: %1$s";
    public static final String MESSAGE_NOT_DONE = "A number for index must be provided.";
    public static final String MESSAGE_DUPLICATE_STATUS = "This task is already uncompleted in uTask.";
    public static final String MESSAGE_INTERNAL_ERROR = "Error updating Status.";

    private final int filteredTaskListIndex;
    private ReadOnlyTask taskToEdit;
    private Task editedTask;

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     */
    public UndoneCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        if (filteredTaskListIndex >= model.getTotalSizeOfLists()) {
            throw new CommandException(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        // Retrieve task to be edited from save file
        taskToEdit = UpdateUtil.fetchTaskToEdit(filteredTaskListIndex);
        // If value already incomplete, inform the user
        if (!taskToEdit.getStatus().isStatusComplete()) {
            throw new CommandException(MESSAGE_DUPLICATE_STATUS);
        }
        editedTask = null;
        try {
            editedTask = UpdateUtil.createEditedTask(taskToEdit, STATUS_TO);
            model.updateTask(taskToEdit, editedTask);
            model.addUndoCommand(this);

            notifyUI(editedTask);
        } catch (IllegalValueException e) {
            throw new CommandException(MESSAGE_INTERNAL_ERROR);
        }
        logger.fine(String.format(MESSAGE_UNDONE_TASK_SUCCESS, editedTask));
        return new CommandResult(
                String.format(MESSAGE_UNDONE_TASK_SUCCESS, editedTask));
    }

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    @Override
    public void undo() throws Exception {
        model.updateTask(editedTask, taskToEdit);
        notifyUI(taskToEdit);
    }

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    @Override
    public void redo() throws Exception {
        model.updateTask(taskToEdit, editedTask);
        notifyUI(editedTask);
    }
}
```
###### \java\utask\logic\commands\UpdateCommand.java
``` java
public class UpdateCommand extends Command implements ReversibleCommand {
    private final Logger logger = LogsCenter.getLogger(UpdateCommand.class);

    public static final String COMMAND_WORD = "update";

    public static final String COMMAND_FORMAT = "INDEX (must be a positive integer) [/name NAME] [/by DEADLINE]"
            + " [/from START_TIME to END_TIME] [/repeat FREQUENCY] [/tag TAG...][/status COMPLETE|INCOMPLETE]...";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the details of the task specified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: " + COMMAND_FORMAT + "\n" + "Example: "
            + COMMAND_WORD + " 1 /name do homework";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the uTask.";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;
    private final ArrayList<Attribute> attributeToRemove;

    private ReadOnlyTask taskToEdit;
    private Task editedTask;

```
###### \java\utask\logic\commands\UpdateCommand.java
``` java
    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     * @param editTaskDescriptor
     *            details to edit the task with
     * @param attributeToRemove
     *            list <Attribute> of attributes to be removed
     */
    public UpdateCommand(int filteredTaskListIndex,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
        this.attributeToRemove = attributeToRemove;
    }

```
###### \java\utask\logic\commands\UpdateCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        if (filteredTaskListIndex >= model.getTotalSizeOfLists()) {
            throw new CommandException(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToEdit = UpdateUtil.fetchTaskToEdit(filteredTaskListIndex);

        // create modified task from existing task
        editedTask = UpdateUtil.createEditedTask(taskToEdit, editTaskDescriptor,
                attributeToRemove);

        try {
            model.updateTask(taskToEdit, editedTask);
            model.addUndoCommand(this);
            notifyUI(editedTask);
        } catch (IllegalArgumentException ive) {
            throw new CommandException(String
                    .format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        logger.fine(String.format(MESSAGE_EDIT_TASK_SUCCESS, editedTask));
        return new CommandResult(
                String.format(MESSAGE_EDIT_TASK_SUCCESS, editedTask));
    }

```
###### \java\utask\logic\commands\UpdateCommand.java
``` java
    @Override
    public void undo() throws Exception {
        model.updateTask(editedTask, taskToEdit);
        notifyUI(taskToEdit);
    }

```
###### \java\utask\logic\commands\UpdateCommand.java
``` java
    @Override
    public void redo() throws Exception {
        model.updateTask(taskToEdit, editedTask);
        notifyUI(editedTask);
    }
}
```
###### \java\utask\logic\parser\DoneCommandParser.java
``` java
public class DoneCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the DoneCommand
     * and returns an DoneCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        }
        return new DoneCommand(index.get());
    }

}
```
###### \java\utask\logic\parser\ParserUtil.java
``` java
    /**
     * Splits a preamble string into ordered fields.
     *
     * @return A list of size {@code numFields} where the ith element is the ith
     *         field value if specified in the input, {@code Optional.empty()}
     *         otherwise.
     */
    public static List<Optional<String>> splitPreamble(String preamble,
            int numFields) {
        return Arrays
                .stream(Arrays.copyOf(preamble.split("\\s+", numFields),
                        numFields))
                .map(Optional::ofNullable).collect(Collectors.toList());
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if
     * {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name)
            throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> deadline} into an
     * {@code Optional<Deadline>} if {@code deadline} is present.
     */
    public static Optional<Deadline> parseDeadline(Optional<String> deadline)
            throws IllegalValueException {
        assert deadline != null;
        return deadline.isPresent() ? Optional.of(new Deadline(deadline.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> frequency} into an
     * {@code Optional<Frequency>} if {@code frequency} is present.
     */
    public static Optional<Frequency> parseFrequency(Optional<String> frequency)
            throws IllegalValueException {
        assert frequency != null;
        return frequency.isPresent()
                ? Optional.of(new Frequency(frequency.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> timestamp} into an
     * {@code Optional<Timestamp>} if {@code timestamp} is present.
     */
    public static Optional<Timestamp> parseTimestamp(Optional<String> timestamp)
            throws IllegalValueException {
        assert timestamp != null;
        return timestamp.isPresent()
                ? Optional.of(new Timestamp(timestamp.get()))
                : Optional.empty();
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code UniqueTagList}.
     */
    public static UniqueTagList parseTags(Collection<String> tags)
            throws IllegalValueException {
        assert tags != null;
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(new TagName(tagName), new TagColorIndex("2")));
        }
        return new UniqueTagList(tagSet);
    }

    /**
     * Parses a {@code Optional<String> status} into an
     * {@code Optional<Status>} if {@code status} is present.
     */
    public static Optional<Status> parseStatus(
            Optional<String> status) throws IllegalValueException {
        assert status != null;
        return status.isPresent()
                ? Optional.of(new Status(status.get()))
                : Optional.empty();
    }
```
###### \java\utask\logic\parser\UndoneCommandParser.java
``` java
public class UndoneCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the DoneCommand
     * and returns an DoneCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoneCommand.MESSAGE_USAGE));
        }
        return new UndoneCommand(index.get());
    }

}
```
###### \java\utask\logic\parser\UpdateCommandParser.java
``` java
public class UpdateCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = prepareArgumentTokenizer(args);
        Optional<Integer> index = getTaskIndex(argsTokenizer);
        if (!index.isPresent()) {
            return new IncorrectCommand(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        ArrayList<Attribute> attributesToRemove = new ArrayList<Attribute>();
        try {
            editTaskDescriptor = setEditTaskDescriptor(argsTokenizer);
            attributesToRemove = getListOfAttributeToRemove(argsTokenizer);
        } catch (IllegalValueException ive) {
            System.out.println(ive.toString());
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(UpdateCommand.MESSAGE_NOT_EDITED);
        }

        return new UpdateCommand(index.get(), editTaskDescriptor,
                attributesToRemove);
    }

    /**
     * Parses the given {@code args} of arguments in the context of the
     * EditCommand and returns an prepared ArgumentTokenizer
     */
    private ArgumentTokenizer prepareArgumentTokenizer(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_NAME,
                PREFIX_DEADLINE, PREFIX_TIMESTAMP, PREFIX_FREQUENCY, PREFIX_TAG,
                PREFIX_DONE);
        argsTokenizer.tokenize(args);
        return argsTokenizer;
    }

    /**
     * Parses {@code argsTokenizer} into {@code Optional<Integer>}. If
     * {@code argsTokenizer} contain only one element which is an empty string,
     * it will be parsed into a {@code Optional<Integer>} containing zero
     * integer.
     */
    private Optional<Integer> getTaskIndex(ArgumentTokenizer argsTokenizer) {
        List<Optional<String>> preambleFields = ParserUtil
                .splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);
        return preambleFields.get(0).flatMap(ParserUtil::parseIndex);
    }

    /**
     * Parses each attribute found in {@code argsTokenizer} into
     * {@code EditTaskDescriptor}.
     */
    private EditTaskDescriptor setEditTaskDescriptor(
            ArgumentTokenizer argsTokenizer) throws IllegalValueException {
        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        editTaskDescriptor.setName(
                ParserUtil.parseName(argsTokenizer.getValue(PREFIX_NAME)));
        editTaskDescriptor.setDeadline(ParserUtil
                .parseDeadline(argsTokenizer.getValue(PREFIX_DEADLINE)));
        editTaskDescriptor.setTimeStamp(ParserUtil
                .parseTimestamp(argsTokenizer.getValue(PREFIX_TIMESTAMP)));
        editTaskDescriptor.setTags(parseTagsForEdit(
                ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
        editTaskDescriptor.setFrequency(ParserUtil
                .parseFrequency(argsTokenizer.getValue(PREFIX_FREQUENCY)));
        editTaskDescriptor.setIsCompleted(
                ParserUtil.parseStatus(argsTokenizer.getValue(PREFIX_DONE)));
        return editTaskDescriptor;
    }

    /**
     * Parses each attribute found in {@code argsTokenizer} checking whether it
     * matches {@code TO_BE_REMOVED}. If any of the inputs matches, the matching
     * ENUM Attribute will be added to {@code ArrayList<Attribute>}.
     */
    private ArrayList<Attribute> getListOfAttributeToRemove(
            ArgumentTokenizer argsTokenizer) {
        ArrayList<Attribute> attributesToRemove = new ArrayList<Attribute>();
        if (argsTokenizer.tryGet(PREFIX_DEADLINE).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.DEADLINE);
        }
        if (argsTokenizer.tryGet(PREFIX_TIMESTAMP).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.TIMESTAMP);
        }
        if (argsTokenizer.tryGet(PREFIX_TAG).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.TAG);
        }
        if (argsTokenizer.tryGet(PREFIX_FREQUENCY).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.FREQUENCY);
        }
        return attributesToRemove;
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags)
            throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("")
                ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### \java\utask\model\Model.java
``` java
    /**
     * Updates the task located at {@code filteredTaskListIndex} with {@code editedTask}.
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code filteredTaskListIndex} < 0 or >= the size of the filtered list.
     */
    void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException;

    void updateTask(ReadOnlyTask taskToEdit, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException;

    void addTag(Tag tag) throws UniqueTagList.DuplicateTagException;
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public synchronized void updateTask(ReadOnlyTask taskToEdit, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert taskToEdit != null;
        assert editedTask != null;

        uTask.updateTask(taskToEdit, editedTask);

        //TODO: DUPLICATES
        UTFilteredListHelper.getInstance().refresh();
        updateFilteredListToShowAll();
        sortFilteredTaskList(sortingConfig);
    }

    @Override
    public void addTag(Tag tag) throws DuplicateTagException {
        assert tag != null;
        uTask.addTag(tag);
//        indicateUTaskChanged();
        UTFilteredListHelper.getInstance().refresh();
        sortFilteredTaskList(sortingConfig);
    }
```
###### \java\utask\model\ModelManager.java
``` java

```
###### \java\utask\model\tag\Tag.java
``` java
/**
 * Represents a Tag in the address book. Guarantees: immutable; name is valid as
 * declared in {@link #isValidTagName(String)}
 */
public class Tag {

    protected TagName tagname;
    protected TagColorIndex tagcolorindex;
    protected Integer tagCount;

    /**
     * Every field must be present and not null.
     */
    public Tag(TagName tagName, TagColorIndex tagColorIndex) {
        assert !CollectionUtil.isAnyNull(tagName, tagColorIndex);

        this.tagname = tagName;
        this.tagcolorindex = tagColorIndex;
        tagCount = 0;
    }

    public Tag(Tag tag) {
        assert tag != null;

        this.tagname = tag.getTagname();
        this.tagcolorindex = tag.getTagcolorindex();
        tagCount = 0;
    }

    public TagName getTagname() {
        return tagname;
    }

    public void setTagname(TagName tagname) {
        this.tagname = tagname;
    }

    public TagColorIndex getTagcolorindex() {
        return tagcolorindex;
    }

    public void setTagcolorindex(TagColorIndex tagcolorindex) {
        this.tagcolorindex = tagcolorindex;
    }

    public Integer getTagCount() {
        return tagCount;
    }

    public void setTagCount(Integer tagCount) {
        this.tagCount = tagCount;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.isSameStateAs((Tag) other));
    }

    private boolean isSameStateAs(Tag other) {
        return other.getTagname().equals(this.getTagname())
                        && other.getTagcolorindex().equals(this.getTagcolorindex());
    }

    @Override
    public int hashCode() {
        return Objects.hash(tagname, tagcolorindex);
    }

    /**
     * Format state as text for viewing.
     */
    public String toString() {
        return '[' + tagname.toString() + ']' + '[' + tagcolorindex.toString() + ']';
    }

}
```
###### \java\utask\model\tag\TagColorIndex.java
``` java
public class TagColorIndex {

    public static final String MESSAGE_TAG_INDEX_CONSTRAINTS = "Tags Color Index"
            + " should be based on the provided colors.";
    public static final String MESSAGE_TAG_WRONG_COLOR = "Sorry! Selected color is not available. Please try again";
    public static final String TAGCOLORINDEX_VALIDATION_REGEX = "($|[0-8]{1})";
    public static final String TAGCOLORINDEX_ENUM_REGEX = "(BLACK)|(BLUE)|(CYAN)|(GREEN)|(ORANGE)|(PINK)|(PURPLE)|"
            + "(RED)|(YELLOW)";

    public final Integer tagColorIndex;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException
     *             if given name string is invalid.
     */
    public TagColorIndex(String value) throws IllegalValueException {
        assert value != null;
        String trimmedValue = value.trim();
        int colorIndex = -1;
        if (!isValidColorIndex(trimmedValue)) {
            throw new IllegalValueException(MESSAGE_TAG_INDEX_CONSTRAINTS);
        }

        if ("".equals(trimmedValue)) {
            colorIndex = getRandomColorIndex();
        } else if (1 == trimmedValue.length()) {
            colorIndex = Integer.parseInt(value);
        } else {
            colorIndex = ColorType.valueOf(trimmedValue.toUpperCase())
                    .ordinal();
        }
        this.tagColorIndex = colorIndex;
    }

    private int getRandomColorIndex() {
        Random random = new Random();
        return random.nextInt(ColorType.values().length);
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidColorIndex(String test) {
        return (test.matches(TAGCOLORINDEX_VALIDATION_REGEX)
                || test.toUpperCase().matches(TAGCOLORINDEX_ENUM_REGEX));
    }

    public Integer getTagColorIndexAsInt() {
        return tagColorIndex;
    }

    @Override
    public String toString() {
        return tagColorIndex.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TagColorIndex // instanceof handles nulls
                        && this.tagColorIndex
                                .equals(((TagColorIndex) other).tagColorIndex)); // state
        // check
    }

    @Override
    public int hashCode() {
        return tagColorIndex.hashCode();
    }

}
```
###### \java\utask\model\tag\TagName.java
``` java
public class TagName {

    public static final String MESSAGE_TAG_CONSTRAINTS = "Tags names should be alphanumeric";
    public static final String TAGNAME_VALIDATION_REGEX = "^\\w+$";

    public final String tagName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException
     *             if given name string is invalid.
     */
    public TagName(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(TAGNAME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return tagName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TagName // instanceof handles nulls
                        && this.tagName.equals(((TagName) other).tagName)); // state
                                                                           // check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

}
```
###### \java\utask\model\task\Attribute.java
``` java
public enum Attribute {
    DEADLINE("deadline"),
    TIMESTAMP("timestamp"),
    STATUS("status"),
    FREQUENCY("frequency"),
    TAG("tag"),
    UNKNOWN("?");

    String key;

    Attribute(String key) {
        this.key = key;
    }

    Attribute() {
    }

    @Override
    public String toString() {
        return key;
    }

}
```
###### \java\utask\model\task\EditTaskDescriptor.java
``` java
public class EditTaskDescriptor {
    private Optional<Name> name = Optional.empty();
    private Optional<Deadline> deadLine = Optional.empty();
    private Optional<Timestamp> timeStamp = Optional.empty();
    private Optional<Frequency> frequency = Optional.empty();
    private Optional<UniqueTagList> tags = Optional.empty();
    private Optional<Status> status = Optional.empty();

    public EditTaskDescriptor() {
    }

    public EditTaskDescriptor(EditTaskDescriptor toCopy) {
        this.name = toCopy.getName();
        this.deadLine = toCopy.getDeadline();
        this.timeStamp = toCopy.getTimeStamp();
        this.frequency = toCopy.getFrequency();
        this.tags = toCopy.getTags();
        this.status = toCopy.getStatus();
    }

    /**
     * Returns true if at least one field is edited.
     */
    public boolean isAnyFieldEdited() {
        return CollectionUtil.isAnyPresent(this.name, this.deadLine,
                this.timeStamp, this.frequency, this.tags,
                this.status);
    }

    public void setName(Optional<Name> name) {
        assert name != null;
        this.name = name;
    }

    public Optional<Name> getName() {
        return name;
    }

    public void setDeadline(Optional<Deadline> deadLine) {
        assert deadLine != null;
        this.deadLine = deadLine;
    }

    public Optional<Deadline> getDeadline() {
        return deadLine;
    }

    public void setTimeStamp(Optional<Timestamp> timeStamp) {
        assert timeStamp != null;
        this.timeStamp = timeStamp;
    }

    public Optional<Timestamp> getTimeStamp() {
        return timeStamp;
    }

    public void setFrequency(Optional<Frequency> frequency) {
        assert frequency != null;
        this.frequency = frequency;
    }

    public Optional<Frequency> getFrequency() {
        return frequency;
    }

    public void setTags(Optional<UniqueTagList> tags) {
        assert tags != null;
        this.tags = tags;
    }

    public Optional<UniqueTagList> getTags() {
        return tags;
    }

    public void setIsCompleted(Optional<Status> status) {
        assert status != null;
        this.status = status;
    }

    public Optional<Status> getStatus() {
        return status;
    }

}
```
###### \java\utask\model\task\Status.java
``` java
public class Status {
    public static final String MESSAGE_STATUS_CONSTRAINTS = "Task status should be complete/incomplete"
            + " case insensitive, and it should not be blank";
    public static final String STATUS_COMPLETE = "Complete";
    public static final String STATUS_INCOMPLETE = "Incomplete";

    /*
     * The first character of the status must not be a whitespace, otherwise " "
     * (a blank string) becomes a valid input.
     */
    public static final String STATUS_VALIDATION_REGEX = "^(COMPLETE|complete|Complete|INCOMPLETE|"
            + "incomplete|Incomplete)$";

    public final Boolean value;

    /**
     * Validates given status.
     *
     * @throws IllegalValueException
     *             if given name string is invalid.
     */
    public Status(String input) throws IllegalValueException {
        assert input != null;
        String trimmedName = input.trim();
        if (!isValidBoolean(trimmedName)) {
            throw new IllegalValueException(MESSAGE_STATUS_CONSTRAINTS);
        }
        this.value = checkValue(input);
    }

    private Boolean checkValue(String strToEvaluate)
            throws IllegalValueException {
        char value = strToEvaluate.toLowerCase().charAt(0);
        switch (value) {
        case 't':
            return true;
        case 'y':
            return true;
        case 'c':
            return true;
        case 'f':
            return false;
        case 'n':
            return false;
        case 'i':
            return false;
        default:
            throw new IllegalValueException(MESSAGE_STATUS_CONSTRAINTS);
        }
    }

    private Status() {
        this.value = false;
    }

    public static Status getEmptyStatus() {
        return new Status();
    }

    public boolean isEmpty() {
        return "".equals(value);
    }

    public boolean isStatusComplete() {
        return value;
    }

    /**
     * Returns true if a given string is a valid true/false or yes/no.
     */
    public static boolean isValidBoolean(String test) {
        return test.matches(STATUS_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        if (value) {
            return STATUS_COMPLETE;
        } else {
            return STATUS_INCOMPLETE;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                        && this.value.equals(((Status) other).value)); // state
                                                                       // check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### \java\utask\model\task\Task.java
``` java
    public void setStatus(Status status) {
        this.status = status;
    }

    @Override
    public Status getStatus() {
        return status;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setFrequency(replacement.getFrequency());
        this.setStatus(replacement.getStatus());
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, frequency, tags, status);
    }

    @Override
    public String toString() {
        return getAsText();
    }
}
```
###### \java\utask\model\task\TaskType.java
``` java
public enum TaskType {
    EVENT("event"),
    DEADLINE("deadline"),
    FLOATING("floating"),
    UNKNOWN("?");

    String key;

    TaskType(String key) {
        this.key = key;
    }

    TaskType() {
    }

    @Override
    public String toString() {
        return key;
    }

}
```
###### \java\utask\model\task\UniqueTaskList.java
``` java
    /**
     * Updates the task in the list held by {@code taskToUpdate} with
     * {@code editedTask}.
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be
     *             equivalent to another existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(ReadOnlyTask readOnlyTaskToUpdate,
            ReadOnlyTask readOnlyEditedTask) throws DuplicateTaskException {
        assert readOnlyTaskToUpdate != null;
        assert readOnlyEditedTask != null;

        // fetch index of task to update
        int index = internalList.indexOf(readOnlyTaskToUpdate);

        // casting ReadOnlyTask to Task
        Task taskToUpdate = (Task) readOnlyTaskToUpdate;
        Task editedTask = (Task) readOnlyEditedTask;

        // if not same type of task and editedTask already in internalList
        // throw DuplicateTaskException()
        if (!taskToUpdate.equals(editedTask)
                && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        // replace original task with modified task
        internalList.set(index, (Task) editedTask);

        // TODO: The code below is just a workaround to notify observers of the
        // updated task.
        // The right way is to implement observable properties in the Task
        // class.
        // Then, TaskCard should then bind its text labels to those observable
        // properties.
        // internalList.set(index, taskToUpdate);
    }

    public void updateTask(int readOnlyTaskToUpdate,
            ReadOnlyTask readOnlyEditedTask) throws DuplicateTaskException {
        assert readOnlyTaskToUpdate >= 0;
        assert readOnlyEditedTask != null;

        // casting ReadOnlyTask to Task
        Task taskToUpdate = internalList.get(readOnlyTaskToUpdate);
        Task editedTask = (Task) readOnlyEditedTask;

        // if not same type of task and editedTask already in internalList
        // throw DuplicateTaskException()
        if (!taskToUpdate.equals(editedTask)
                && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        // if taskToUpdate and editedTask are same class, then update
        // taskToUpdate attributes
        // else update internalList
        // at index held by taskToUpdate with editedTask
        if (taskToUpdate.getClass().equals(editedTask.getClass())) {
            taskToUpdate.resetData(editedTask);
            internalList.set(readOnlyTaskToUpdate, taskToUpdate);
        } else {
            internalList.set(readOnlyTaskToUpdate, (Task) editedTask);
        }

        // TODO: The code below is just a workaround to notify observers of the
        // updated task.
        // The right way is to implement observable properties in the Task
        // class.
        // Then, TaskCard should then bind its text labels to those observable
        // properties.
        // internalList.set(index, taskToUpdate);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException
     *             if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public void setTasks(UniqueTaskList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTasks(List<? extends ReadOnlyTask> tasks)
            throws DuplicateTaskException {
        final UniqueTaskList replacement = new UniqueTaskList();
        for (final ReadOnlyTask task : tasks) {
            replacement.add(new EventTask(task));
        }
        setTasks(replacement);
    }

    public UnmodifiableObservableList<Task> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTaskList // instanceof handles nulls
                        && this.internalList
                                .equals(((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates'
     * property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would
     * fail because there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {
    }

}
```
###### \java\utask\model\UTask.java
``` java
    /**
     * Updates the original task in the list {@code taskToEdit} with {@code editedReadOnlyTask}.
     * {@code UTask}'s tag list will be updated with the tags of {@code editedReadOnlyTask}.
     * @see #syncMasterTagListWith(Task)
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(ReadOnlyTask taskToEdit, ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert taskToEdit != null;
        assert editedReadOnlyTask != null;

        syncMasterTagListWith((Task) editedReadOnlyTask);
        tasks.updateTask(taskToEdit, editedReadOnlyTask);
    }

    public void updateTask(int taskToEdit, ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert taskToEdit >= 0;
        assert editedReadOnlyTask != null;

        syncMasterTagListWith((Task) editedReadOnlyTask);
        tasks.updateTask(taskToEdit, editedReadOnlyTask);
    }
```
###### \java\utask\staging\ui\UTTaskListCard.java
``` java
    private void createTags(ReadOnlyTask task) {
        UniqueTagList tags = task.getTags();
        for (Tag tag : tags) {
            Label label = createLabel(tag.getTagname().toString(),
                    tag.getTagcolorindex().getTagColorIndexAsInt());
            hbTagContainer.getChildren().add(label);
        }
    }

    private Label createLabel(String name, int colorIndex) {
        Label label = new Label(name);
        addStylingPropertiesToLabel(label, colorIndex);
        return label;
    }

    private void addStylingPropertiesToLabel(Label label, int colorIndex) {
        label.setAlignment(Pos.CENTER);
        ;
        label.setTextAlignment(TextAlignment.CENTER);
        label.setTextOverrun(OverrunStyle.CLIP);
        label.setMinWidth(15.0);
        label.setStyle(String.format(LABEL_CSS,
                TagColorHelper.getColorValueFromIndex(colorIndex)));
        HBox.setMargin(label, new Insets(5, 5, 5, 0));
    }
```
