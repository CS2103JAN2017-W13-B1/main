# A0138423J
###### \java\utask\commons\util\UpdateUtil.java
``` java
public class UpdateUtil {
    public static final String TO_BE_REMOVED = "-";

    public static ReadOnlyTask fetchTaskToEdit(int index) {
        assert index >= 0;
        List<ReadOnlyTask> lastShownList = FilteredListHelper.getInstance()
                .getUnderlyingListByIndex(index);
        int actualInt = FilteredListHelper.getInstance()
                .getActualIndexFromDisplayIndex(index);

        return lastShownList.get(actualInt);
    }

    /**
     * Checks {@code updatedDeadline} and {@code updatedTimestamp} to see
     * whether both are empty or not. Subsequently, based on the statuses, this
     * method will determine the type of editedTask. Types are pre-set based on
     * Enum {@code TaskType}
     */
    public static TaskType typeOfEditedTask(Deadline updatedDeadline,
            Timestamp updatedTimestamp) {
        assert updatedDeadline != null;
        assert updatedTimestamp != null;

        Boolean isDeadlineEmpty = false;
        if (updatedDeadline.equals(Deadline.getEmptyDeadline())) {
            isDeadlineEmpty = true;
        }
        Boolean isTimestampEmpty = false;
        if (updatedTimestamp.equals(Timestamp.getEmptyTimestamp())) {
            isTimestampEmpty = true;
        }
        if (!isDeadlineEmpty && !isTimestampEmpty) {
            return TaskType.EVENT;
        } else if (!isDeadlineEmpty && isTimestampEmpty) {
            return TaskType.DEADLINE;
        } else if (isDeadlineEmpty && isTimestampEmpty) {
            return TaskType.FLOATING;
        }
        return TaskType.UNKNOWN;
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    public static Task createEditedTask(ReadOnlyTask taskToEdit, String value)
            throws IllegalValueException {
        assert taskToEdit != null;
        assert value != null;

        Task placeholder = null;
        switch (typeOfEditedTask(taskToEdit.getDeadline(),
                taskToEdit.getTimestamp())) {
        case FLOATING:
            placeholder = new FloatingTask(taskToEdit.getName(),
                    taskToEdit.getFrequency(), taskToEdit.getTags(),
                    new Status(value.toString()));
            break;
        case DEADLINE:
            placeholder = new DeadlineTask(taskToEdit.getName(),
                    taskToEdit.getDeadline(), taskToEdit.getFrequency(),
                    taskToEdit.getTags(), new Status(value));
            break;
        case EVENT:
            placeholder = new EventTask(taskToEdit.getName(),
                    taskToEdit.getDeadline(), taskToEdit.getTimestamp(),
                    taskToEdit.getFrequency(), taskToEdit.getTags(),
                    new Status(value.toString()));
            break;
        default:
            assert false : "Should never come to this default";
        }
        return placeholder;
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    public static Task createEditedTask(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Name updatedName = editTaskDescriptor.getName()
                .orElseGet(taskToEdit::getName);
        Status updatedIsCompleted = editTaskDescriptor.getStatus()
                .orElseGet(taskToEdit::getStatus);
        Deadline updatedDeadline = updateOrRemoveDeadline(taskToEdit,
                editTaskDescriptor, attributeToRemove);
        Timestamp updatedTimestamp = updateOrRemoveTimestamp(taskToEdit,
                editTaskDescriptor, attributeToRemove, updatedDeadline);
        Frequency updatedFrequency = updateOrRemoveFrequency(taskToEdit,
                editTaskDescriptor, attributeToRemove);
        UniqueTagList updatedTags = updateOrRemoveUniqueTagList(taskToEdit,
                editTaskDescriptor, attributeToRemove);

        Task placeholder = null;
        switch (typeOfEditedTask(updatedDeadline, updatedTimestamp)) {
        case FLOATING:
            placeholder = new FloatingTask(updatedName, updatedFrequency,
                    updatedTags, updatedIsCompleted);
            break;
        case DEADLINE:
            placeholder = new DeadlineTask(updatedName, updatedDeadline,
                    updatedFrequency, updatedTags, updatedIsCompleted);
            break;
        case EVENT:
            placeholder = new EventTask(updatedName, updatedDeadline,
                    updatedTimestamp, updatedFrequency, updatedTags,
                    updatedIsCompleted);
            break;
        default:
            assert false : "Should never come to this default";
        }
        return placeholder;
    }

    /**
     * Creates and returns a {@code Deadline} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove Deadline field based on
     * {@code attributeToRemove}
     */
    private static Deadline updateOrRemoveDeadline(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Deadline updatedDeadline = editTaskDescriptor.getDeadline()
                .orElseGet(taskToEdit::getDeadline);
        if (attributeToRemove.contains(Attribute.DEADLINE)) {
            updatedDeadline = Deadline.getEmptyDeadline();
        }
        return updatedDeadline;
    }

    /**
     * Creates and returns a {@code Timestamp} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove Timestamp field based on
     * {@code attributeToRemove}
     */
    private static Timestamp updateOrRemoveTimestamp(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove,
            Deadline updatedDeadline) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Timestamp timestampToUpdate = editTaskDescriptor.getTimeStamp()
              .orElseGet(taskToEdit::getTimestamp);

        if (!timestampToUpdate.equals(taskToEdit.getTimestamp())
                && !attributeToRemove.contains(Attribute.TIMESTAMP)) {
            timestampToUpdate = Timestamp
                    .getUpdateTimestampWithDeadline(timestampToUpdate,
                            updatedDeadline);
        }

        if (attributeToRemove.contains(Attribute.TIMESTAMP)) {
            timestampToUpdate = Timestamp.getEmptyTimestamp();
        }
        return timestampToUpdate;
    }

    /**
     * Creates and returns a {@code UniqueTagList} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove UniqueTagList field based on
     * {@code attributeToRemove}
     */
    private static Frequency updateOrRemoveFrequency(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        Frequency updatedFrequency = editTaskDescriptor.getFrequency()
                .orElseGet(taskToEdit::getFrequency);
        if (attributeToRemove.contains(Attribute.FREQUENCY)) {
            updatedFrequency = Frequency.getEmptyFrequency();
        }
        return updatedFrequency;
    }

    /**
     * Creates and returns a {@code UniqueTagList} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}. Subsequently,
     * checks to see if there is any need to remove UniqueTagList field based on
     * {@code attributeToRemove}
     */
    private static UniqueTagList updateOrRemoveUniqueTagList(
            ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor,
            ArrayList<Attribute> attributeToRemove) {
        assert taskToEdit != null;
        assert editTaskDescriptor != null;
        assert attributeToRemove != null;

        UniqueTagList updatedTags = editTaskDescriptor.getTags()
                .orElseGet(taskToEdit::getTags);
        if (attributeToRemove.contains(Attribute.TAG)) {
            updatedTags = new UniqueTagList();
        }
        return updatedTags;
    }
}
```
###### \java\utask\logic\commands\DoneCommand.java
``` java
/**
 * Edits the Status of an existing task in the uTask.
 */
public class DoneCommand extends Command implements ReversibleCommand {
    private final Logger logger = LogsCenter.getLogger(DoneCommand.class);

    public static final String COMMAND_WORD = "done";
    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";
    public static final String STATUS_TO = "COMPLETE";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the status to Complete of the task specified "
            + "by the index number used in the last task listing. \n"
            + "Parameters: " + COMMAND_FORMAT + "\n" + "Example: "
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_DONE_TASK_SUCCESS = "Done task: %1$s";
    public static final String MESSAGE_NOT_DONE = "A number for index must be provided.";
    public static final String MESSAGE_DUPLICATE_STATUS = "This task is already completed in uTask.";
    public static final String MESSAGE_DUPLICATE_TASK = "A similar completed task is already found in uTask.";
    public static final String MESSAGE_INTERNAL_ERROR = "Error updating Status.";

    private final int filteredTaskListIndex;
    private ReadOnlyTask taskToEdit;
    private Task editedTask;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     */
    public DoneCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (filteredTaskListIndex >= model.getTotalSizeOfLists()) {
            throw new CommandException(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        // Retrieve task to be edited from save file
        taskToEdit = UpdateUtil.fetchTaskToEdit(filteredTaskListIndex);
        // If value already completed, inform the user
        if (taskToEdit.getStatus().isStatusComplete()) {
            throw new CommandException(MESSAGE_DUPLICATE_STATUS);
        }
        editedTask = null;
        try {
            editedTask = UpdateUtil.createEditedTask(taskToEdit, STATUS_TO);
            if (model.getFilteredTaskList().contains(editedTask)) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            model.updateTask(taskToEdit, editedTask);
            model.addUndoCommand(this);
            notifyUI(taskToEdit);
        } catch (IllegalValueException e) {
            throw new CommandException(MESSAGE_INTERNAL_ERROR);
        }
        logger.fine(String.format(MESSAGE_DONE_TASK_SUCCESS, editedTask));
        return new CommandResult(
                String.format(MESSAGE_DONE_TASK_SUCCESS, editedTask));
    }

    @Override
    public void undo() throws Exception {
        model.updateTask(editedTask, taskToEdit);
        notifyUI(taskToEdit);
    }

    @Override
    public void redo() throws Exception {
        model.updateTask(taskToEdit, editedTask);
        notifyUI(editedTask);
    }
}
```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
/**
 * Edits the details of an existing task in the uTask.
 */
public class UndoneCommand extends Command implements ReversibleCommand {
    private final Logger logger = LogsCenter.getLogger(UndoneCommand.class);

    public static final String COMMAND_WORD = "undone";
    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";
    public static final String STATUS_TO = "INCOMPLETE";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the status to Incomplete of the task specified "
            + "by the index number used in the last task listing. \n"
            + "Parameters: " + COMMAND_FORMAT + "\n" + "Example: "
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNDONE_TASK_SUCCESS = "Undone task: %1$s";
    public static final String MESSAGE_NOT_DONE = "A number for index must be provided.";
    public static final String MESSAGE_DUPLICATE_STATUS = "This task is already incompleted in uTask.";
    public static final String MESSAGE_DUPLICATE_TASK = "A similar incomplete task is already found in uTask.";
    public static final String MESSAGE_INTERNAL_ERROR = "Error updating Status.";

    private final int filteredTaskListIndex;
    private ReadOnlyTask taskToEdit;
    private Task editedTask;

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     */
    public UndoneCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        if (filteredTaskListIndex >= model.getTotalSizeOfLists()) {
            throw new CommandException(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        // Retrieve task to be edited from save file
        taskToEdit = UpdateUtil.fetchTaskToEdit(filteredTaskListIndex);
        // If value already incomplete, inform the user
        if (!taskToEdit.getStatus().isStatusComplete()) {
            throw new CommandException(MESSAGE_DUPLICATE_STATUS);
        }
        editedTask = null;
        try {
            editedTask = UpdateUtil.createEditedTask(taskToEdit, STATUS_TO);
            if (model.getFilteredTaskList().contains(editedTask)) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            model.updateTask(taskToEdit, editedTask);
            model.addUndoCommand(this);

            notifyUI(editedTask);
        } catch (IllegalValueException e) {
            throw new CommandException(MESSAGE_INTERNAL_ERROR);
        }
        logger.fine(String.format(MESSAGE_UNDONE_TASK_SUCCESS, editedTask));
        return new CommandResult(
                String.format(MESSAGE_UNDONE_TASK_SUCCESS, editedTask));
    }

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    @Override
    public void undo() throws Exception {
        model.updateTask(editedTask, taskToEdit);
        notifyUI(taskToEdit);
    }

```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    @Override
    public void redo() throws Exception {
        model.updateTask(taskToEdit, editedTask);
        notifyUI(editedTask);
    }
}
```
###### \java\utask\logic\parser\DoneCommandParser.java
``` java
public class DoneCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the DoneCommand
     * and returns an DoneCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        }
        return new DoneCommand(index.get());
    }

}
```
###### \java\utask\logic\parser\ParserUtil.java
``` java
    /**
     * Splits a preamble string into ordered fields.
     *
     * @return A list of size {@code numFields} where the ith element is the ith
     *         field value if specified in the input, {@code Optional.empty()}
     *         otherwise.
     */
    public static List<Optional<String>> splitPreamble(String preamble,
            int numFields) {
        return Arrays
                .stream(Arrays.copyOf(preamble.split("\\s+", numFields),
                        numFields))
                .map(Optional::ofNullable).collect(Collectors.toList());
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if
     * {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name)
            throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> deadline} into an
     * {@code Optional<Deadline>} if {@code deadline} is present.
     */
    public static Optional<Deadline> parseDeadline(Optional<String> deadline)
            throws IllegalValueException {
        assert deadline != null;

        return deadline.isPresent() ? Optional.of(new Deadline(deadline.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> frequency} into an
     * {@code Optional<Frequency>} if {@code frequency} is present.
     */
    public static Optional<Frequency> parseFrequency(Optional<String> frequency)
            throws IllegalValueException {
        assert frequency != null;
        return frequency.isPresent()
                ? Optional.of(new Frequency(frequency.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> timestamp} into an
     * {@code Optional<Timestamp>} if {@code timestamp} is present.
     */
    public static Optional<Timestamp> parseTimestamp(Optional<String> date, Optional<String> timestamp)
            throws IllegalValueException {
        assert timestamp != null;

        if (date.isPresent() && timestamp.isPresent()) {
            return Optional.of(new Timestamp(date.get(), timestamp.get()));
        }

        return timestamp.isPresent()
                ? Optional.of(new Timestamp(timestamp.get()))
                : Optional.empty();
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code UniqueTagList}.
     */
    public static UniqueTagList parseTags(Collection<String> tags)
            throws IllegalValueException {
        assert tags != null;
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(new TagName(tagName), new TagColorIndex("2")));
        }
        return new UniqueTagList(tagSet);
    }

    /**
     * Parses a {@code Optional<String> status} into an
     * {@code Optional<Status>} if {@code status} is present.
     */
    public static Optional<Status> parseStatus(
            Optional<String> status) throws IllegalValueException {
        assert status != null;
        return status.isPresent()
                ? Optional.of(new Status(status.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<TagName> name} into an {@code Optional<TagName>} if
     * {@code name} is present.
     */
    public static Optional<TagName> parseTagName(Optional<String> optional)
            throws IllegalValueException {
        assert optional != null;
        return optional.isPresent() ? Optional.of(new TagName(optional.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<TagColorIndex> colorIndex} into an
     * {@code Optional<TagColorIndex>} if {@code colorIndex} is present.
     */
    public static Optional<TagColorIndex> parseColorIndex(Optional<String> optional)
            throws IllegalValueException {
        assert optional != null;

        return optional.isPresent() ? Optional.of(new TagColorIndex(optional.get()))
                : Optional.empty();
    }
```
###### \java\utask\logic\parser\UndoneCommandParser.java
``` java
public class UndoneCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the DoneCommand
     * and returns an DoneCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoneCommand.MESSAGE_USAGE));
        }
        return new UndoneCommand(index.get());
    }

}
```
###### \java\utask\logic\parser\UpdateCommandParser.java
``` java
public class UpdateCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = prepareArgumentTokenizer(args);
        Optional<Integer> index = getTaskIndex(argsTokenizer);
        if (!index.isPresent()) {
            return new IncorrectCommand(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        ArrayList<Attribute> attributesToRemove = new ArrayList<Attribute>();
        try {
            editTaskDescriptor = setEditTaskDescriptor(argsTokenizer);
            attributesToRemove = getListOfAttributeToRemove(argsTokenizer);
        } catch (IllegalValueException ive) {
            System.out.println(ive.toString());
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(UpdateCommand.MESSAGE_NOT_EDITED);
        }

        return new UpdateCommand(index.get(), editTaskDescriptor,
                attributesToRemove);
    }

    /**
     * Parses the given {@code args} of arguments in the context of the
     * EditCommand and returns an prepared ArgumentTokenizer
     */
    private ArgumentTokenizer prepareArgumentTokenizer(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_NAME,
                PREFIX_DEADLINE, PREFIX_TIMESTAMP, PREFIX_FREQUENCY, PREFIX_TAG,
                PREFIX_DONE);
        argsTokenizer.tokenize(args);
        return argsTokenizer;
    }

    /**
     * Parses {@code argsTokenizer} into {@code Optional<Integer>}. If
     * {@code argsTokenizer} contain only one element which is an empty string,
     * it will be parsed into a {@code Optional<Integer>} containing zero
     * integer.
     */
    private Optional<Integer> getTaskIndex(ArgumentTokenizer argsTokenizer) {
        List<Optional<String>> preambleFields = ParserUtil
                .splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);
        return preambleFields.get(0).flatMap(ParserUtil::parseIndex);
    }

    /**
     * Parses each attribute found in {@code argsTokenizer} into
     * {@code EditTaskDescriptor}.
     */
    private EditTaskDescriptor setEditTaskDescriptor(
            ArgumentTokenizer argsTokenizer) throws IllegalValueException {
        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        editTaskDescriptor.setName(
                ParserUtil.parseName(argsTokenizer.getValue(PREFIX_NAME)));
        editTaskDescriptor.setDeadline(ParserUtil
                .parseDeadline(argsTokenizer.getValue(PREFIX_DEADLINE)));
        editTaskDescriptor.setTimeStamp(ParserUtil
                .parseTimestamp(argsTokenizer.getValue(PREFIX_DEADLINE), argsTokenizer.getValue(PREFIX_TIMESTAMP)));
        editTaskDescriptor.setTags(parseTagsForEdit(
                ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
        editTaskDescriptor.setFrequency(ParserUtil
                .parseFrequency(argsTokenizer.getValue(PREFIX_FREQUENCY)));
        editTaskDescriptor.setIsCompleted(
                ParserUtil.parseStatus(argsTokenizer.getValue(PREFIX_DONE)));
        return editTaskDescriptor;
    }

    /**
     * Parses each attribute found in {@code argsTokenizer} checking whether it
     * matches {@code TO_BE_REMOVED}. If any of the inputs matches, the matching
     * ENUM Attribute will be added to {@code ArrayList<Attribute>}.
     */
    private ArrayList<Attribute> getListOfAttributeToRemove(
            ArgumentTokenizer argsTokenizer) {
        ArrayList<Attribute> attributesToRemove = new ArrayList<Attribute>();
        if (argsTokenizer.tryGet(PREFIX_DEADLINE).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.DEADLINE);
            attributesToRemove.add(Attribute.TIMESTAMP);
        }
        if (argsTokenizer.tryGet(PREFIX_TIMESTAMP).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.TIMESTAMP);
        }
        if (argsTokenizer.tryGet(PREFIX_TAG).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.TAG);
        }
        if (argsTokenizer.tryGet(PREFIX_FREQUENCY).equals(TO_BE_REMOVED)) {
            attributesToRemove.add(Attribute.FREQUENCY);
        }
        return attributesToRemove;
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags)
            throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("")
                ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### \java\utask\model\Model.java
``` java
    /**
     * Updates the task {@code taskToEdit} with {@code editedTask}.
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code filteredTaskListIndex} < 0 or >= the size of the filtered list.
     */
    void updateTask(ReadOnlyTask taskToEdit, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException;

    void addTag(Tag tag) throws UniqueTagList.DuplicateTagException;

    void deleteTag(Tag tag);

    void updateTag(Tag tagToReplace, Tag updatedTag) throws UniqueTagList.DuplicateTagException;

    List<Tag> getTags();

```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public synchronized void updateTask(ReadOnlyTask taskToEdit, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert taskToEdit != null;
        assert editedTask != null;

        uTask.updateTask(taskToEdit, editedTask);
        refresh();
    }

    @Override
    public void addTag(Tag tag) throws DuplicateTagException {
        assert tag != null;
        uTask.addTag(tag);
        refresh();
    }

    @Override
    public void deleteTag(Tag tag) {
        assert tag != null;
        uTask.deleteTag(tag);
        refresh();
    }

    @Override
    public void updateTag(Tag tagToReplace, Tag updatedTag) {
        assert tagToReplace != null;
        assert updatedTag != null;
        uTask.updateTag(tagToReplace, updatedTag);
        refresh();
    }

    @Override
    public List<Tag> getTags() {
        return uTask.getTagList();
    }
```
###### \java\utask\model\ModelManager.java
``` java
    private void refresh() {
        FilteredListHelper.getInstance().refresh();
        updateFilteredListToShowAll();
        sortFilteredTaskList(sortingConfig);
    }

```
###### \java\utask\model\tag\Tag.java
``` java
/**
 * Represents a Tag in the address book. Guarantees: immutable; name is valid as
 * declared in {@link #isValidTagName(String)}
 */
public class Tag {

    protected TagName tagName;
    protected TagColorIndex tagColorIndex;

    /**
     * Every field must be present and not null.
     */
    public Tag(TagName tagName, TagColorIndex tagColorIndex) {
        assert !CollectionUtil.isAnyNull(tagName, tagColorIndex);

        this.tagName = tagName;
        this.tagColorIndex = tagColorIndex;
    }

    public Tag(Tag tag) {
        assert tag != null;

        this.tagName = tag.getTagName();
        this.tagColorIndex = tag.getTagColorIndex();
    }

    public Tag() {
    }

    public TagName getTagName() {
        return tagName;
    }

    public void setTagName(TagName tagname) {
        this.tagName = tagname;
    }

    public TagColorIndex getTagColorIndex() {
        return tagColorIndex;
    }

    public void setTagColorIndex(TagColorIndex tagcolorindex) {
        this.tagColorIndex = tagcolorindex;
    }

    public void setTag(Tag updatedTag) {
        this.tagName = updatedTag.tagName;
        this.tagColorIndex = updatedTag.tagColorIndex;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                        && this.isSameStateAs((Tag) other));
    }

    private boolean isSameStateAs(Tag other) {
        return other.getTagName().equals(this.getTagName());
        // && other.getTagcolorindex().equals(this.getTagcolorindex());
    }

    @Override
    public int hashCode() {
        return Objects.hash(tagName);
    }

    /**
     * Format state as text for viewing.
     */
    public String toString() {
        return '[' + tagName.toString() + ']' + '['
                + ColorType.values()[tagColorIndex.getTagColorIndexAsInt()]
                        .name()
                + ']';
    }

}
```
###### \java\utask\model\tag\TagColorIndex.java
``` java
public class TagColorIndex {

    public static final String MESSAGE_TAG_INDEX_CONSTRAINTS = "Tags Color Index"
            + " should be based on the provided colors.";
    public static final String MESSAGE_TAG_WRONG_COLOR = "Sorry! Selected color is not available. Please try again";
    public static final String TAGCOLORINDEX_VALIDATION_REGEX = "($|[0-8]{1})";
    public static final String TAGCOLORINDEX_ENUM_REGEX = "(BLACK)|(BLUE)|(CYAN)|(GREEN)|(ORANGE)|(PINK)|(PURPLE)|"
            + "(RED)|(YELLOW)";

    public final Integer tagColorIndex;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException
     *             if given name string is invalid.
     */
    public TagColorIndex(String value) throws IllegalValueException {
        assert value != null;
        String trimmedValue = value.trim();
        int colorIndex = -1;
        if (!isValidColorIndex(trimmedValue)) {
            throw new IllegalValueException(MESSAGE_TAG_INDEX_CONSTRAINTS + TagColorHelper.getListOfSupportedColor());
        }

        if ("".equals(trimmedValue)) {
            colorIndex = getRandomColorIndex();
        } else if (1 == trimmedValue.length()) {
            colorIndex = Integer.parseInt(value);
        } else {
            colorIndex = ColorType.valueOf(trimmedValue.toUpperCase())
                    .ordinal();
        }
        this.tagColorIndex = colorIndex;
    }

    public TagColorIndex(TagColorIndex value) throws IllegalValueException {
        assert value != null;
        String trimmedValue = value.toString();
        int colorIndex = -1;
        if (!isValidColorIndex(trimmedValue)) {
            throw new IllegalValueException(MESSAGE_TAG_INDEX_CONSTRAINTS + TagColorHelper.getListOfSupportedColor());
        }

        if ("".equals(trimmedValue)) {
            colorIndex = getRandomColorIndex();
        } else if (1 == trimmedValue.length()) {
            colorIndex = Integer.parseInt(trimmedValue);
        } else {
            colorIndex = ColorType.valueOf(trimmedValue.toUpperCase())
                    .ordinal();
        }
        this.tagColorIndex = colorIndex;
    }

    private int getRandomColorIndex() {
        Random random = new Random();
        return random.nextInt(ColorType.values().length);
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidColorIndex(String test) {
        return (test.matches(TAGCOLORINDEX_VALIDATION_REGEX)
                || test.toUpperCase().matches(TAGCOLORINDEX_ENUM_REGEX));
    }

    public Integer getTagColorIndexAsInt() {
        return tagColorIndex;
    }

    @Override
    public String toString() {
        return tagColorIndex.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TagColorIndex // instanceof handles nulls
                        && this.tagColorIndex
                                .equals(((TagColorIndex) other).tagColorIndex)); // state
        // check
    }

    @Override
    public int hashCode() {
        return tagColorIndex.hashCode();
    }

}
```
###### \java\utask\model\tag\TagName.java
``` java
public class TagName {

    public static final String TAGNAME_VALIDATION_REGEX = "^[a-zA-Z0-9]+$";

    public final String tagName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException
     *             if given name string is invalid.
     */
    public TagName(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(Messages.MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    public TagName(TagName name) throws IllegalValueException {
        assert name != null;
        if (!isValidName(name.toString())) {
            throw new IllegalValueException(Messages.MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = name.toString();
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(TAGNAME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return tagName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TagName // instanceof handles nulls
                        && this.tagName.equals(((TagName) other).tagName)); // state
                                                                           // check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

}
```
###### \java\utask\model\task\Attribute.java
``` java
public enum Attribute {
    DEADLINE("deadline"),
    TIMESTAMP("timestamp"),
    STATUS("status"),
    FREQUENCY("frequency"),
    TAG("tag"),
    UNKNOWN("?");

    String key;

    Attribute(String key) {
        this.key = key;
    }

    @Override
    public String toString() {
        return key;
    }

}
```
###### \java\utask\model\task\EditTaskDescriptor.java
``` java
public class EditTaskDescriptor {
    private Optional<Name> name = Optional.empty();
    private Optional<Deadline> deadLine = Optional.empty();
    private Optional<Timestamp> timeStamp = Optional.empty();
    private Optional<Frequency> frequency = Optional.empty();
    private Optional<UniqueTagList> tags = Optional.empty();
    private Optional<Status> status = Optional.empty();

    public EditTaskDescriptor() {
    }

    public EditTaskDescriptor(EditTaskDescriptor toCopy) {
        name = toCopy.getName();
        deadLine = toCopy.getDeadline();
        timeStamp = toCopy.getTimeStamp();
        frequency = toCopy.getFrequency();
        tags = toCopy.getTags();
        status = toCopy.getStatus();
    }

    /**
     * Returns true if at least one field is edited.
     */
    public boolean isAnyFieldEdited() {
        return CollectionUtil.isAnyPresent(this.name, this.deadLine,
                this.timeStamp, this.frequency, this.tags,
                this.status);
    }

    public void setName(Optional<Name> name) {
        assert name != null;
        this.name = name;
    }

    public Optional<Name> getName() {
        return name;
    }

    public void setDeadline(Optional<Deadline> deadLine) {
        assert deadLine != null;
        this.deadLine = deadLine;
    }

    public Optional<Deadline> getDeadline() {
        return deadLine;
    }

    public void setTimeStamp(Optional<Timestamp> timeStamp) {
        assert timeStamp != null;
        this.timeStamp = timeStamp;
    }

    public Optional<Timestamp> getTimeStamp() {
        return timeStamp;
    }

    public void setFrequency(Optional<Frequency> frequency) {
        assert frequency != null;
        this.frequency = frequency;
    }

    public Optional<Frequency> getFrequency() {
        return frequency;
    }

    public void setTags(Optional<UniqueTagList> tags) {
        assert tags != null;
        this.tags = tags;
    }

    public Optional<UniqueTagList> getTags() {
        return tags;
    }

    public void setIsCompleted(Optional<Status> status) {
        assert status != null;
        this.status = status;
    }

    public Optional<Status> getStatus() {
        return status;
    }

}
```
###### \java\utask\model\task\Status.java
``` java
public class Status {
    public static final String MESSAGE_STATUS_CONSTRAINTS = "Task status should be complete/incomplete"
            + " case insensitive, and it should not be blank";
    public static final String STATUS_COMPLETE = "Complete";
    public static final String STATUS_INCOMPLETE = "Incomplete";

    /*
     * The first character of the status must not be a whitespace, otherwise " "
     * (a blank string) becomes a valid input.
     */
    public static final String STATUS_VALIDATION_REGEX = "^(COMPLETE|complete|Complete|INCOMPLETE|"
            + "incomplete|Incomplete)$";

    public final Boolean value;

    /**
     * Validates given status.
     *
     * @throws IllegalValueException
     *             if given name string is invalid.
     */
    public Status(String input) throws IllegalValueException {
        assert input != null;
        String trimmedName = input.trim();
        if (!isValidBoolean(trimmedName)) {
//            assert false : "Illegal Value!";
            throw new IllegalValueException(MESSAGE_STATUS_CONSTRAINTS);
        }
        this.value = checkValue(input);
    }

    private Boolean checkValue(String strToEvaluate)
            throws IllegalValueException {
        char value = strToEvaluate.toLowerCase().charAt(0);
        if ('c' == value) {
            return true;
        } else {
            return false;
        }
    }

    private Status() {
        this.value = false;
    }

    public static Status getEmptyStatus() {
        return new Status();
    }

    public boolean isEmpty() {
        return "".equals(value);
    }

    public boolean isStatusComplete() {
        return value;
    }

    /**
     * Returns true if a given string is a valid true/false or yes/no.
     */
    public static boolean isValidBoolean(String test) {
        return test.matches(STATUS_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        if (value) {
            return STATUS_COMPLETE;
        } else {
            return STATUS_INCOMPLETE;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                        && this.value.equals(((Status) other).value)); // state
                                                                       // check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### \java\utask\model\task\Task.java
``` java
    public void setStatus(Status status) {
        this.status = status;
    }

    @Override
    public Status getStatus() {
        return status;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setFrequency(replacement.getFrequency());
        this.setStatus(replacement.getStatus());
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, frequency, tags, status);
    }

    @Override
    public String toString() {
        return getAsText();
    }
}
```
###### \java\utask\model\task\TaskType.java
``` java
public enum TaskType {
    EVENT("event"),
    DEADLINE("deadline"),
    FLOATING("floating"),
    UNKNOWN("?");

    String key;

    TaskType(String key) {
        this.key = key;
    }

    @Override
    public String toString() {
        return key;
    }

}
```
###### \java\utask\model\task\UniqueTaskList.java
``` java
    /**
     * Updates the task in the list held by {@code taskToUpdate} with
     * {@code editedTask}.
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be
     *             equivalent to another existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(ReadOnlyTask readOnlyTaskToUpdate,
            ReadOnlyTask readOnlyEditedTask) throws DuplicateTaskException {
        assert readOnlyTaskToUpdate != null;
        assert readOnlyEditedTask != null;

        // fetch index of task to update
        int index = internalList.indexOf(readOnlyTaskToUpdate);

        // casting ReadOnlyTask to Task
        Task taskToUpdate = (Task) readOnlyTaskToUpdate;
        Task editedTask = (Task) readOnlyEditedTask;

        // if not same type of task and editedTask already in internalList
        // throw DuplicateTaskException()
        if (!taskToUpdate.equals(editedTask)
                && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        // replace original task with modified task
        internalList.set(index, (Task) editedTask);
    }

    public void updateTaskWithUpdatedTag (Tag tagToReplace, Tag updatedTag) {
        for (Task x : internalList) {
            for (Tag t : x.getTags()) {
                if (t.equals(tagToReplace)) {
                    t.setTag(updatedTag);
                }
            }
        }
    }

    public void deleteTaskWithDeletedTag (Tag tagToDelete) {
        for (Task x : internalList) {
            UniqueTagList tempList = x.getTags();
            for (Tag t : x.getTags()) {
                if (t.equals(tagToDelete)) {
                    tempList.delete(t);
                }
            }
            x.setTags(tempList);
        }
    }
```
###### \java\utask\model\UTask.java
``` java
    /**
     * Updates the original task in the list {@code taskToEdit} with
     * {@code editedReadOnlyTask}. {@code UTask}'s tag list will be updated with
     * the tags of {@code editedReadOnlyTask}.
     *
     * @see #syncMasterTagListWith(Task)
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be
     *             equivalent to another existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(ReadOnlyTask taskToEdit,
            ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert taskToEdit != null;
        assert editedReadOnlyTask != null;

        syncMasterTagListWith((Task) editedReadOnlyTask);
        tasks.updateTask(taskToEdit, editedReadOnlyTask);
    }
```
###### \java\utask\ui\dialogs\TagColorDialog.java
``` java
public class TagColorDialog extends Dialog {
    private static final String HAS_TAGS_HEADING = "Tags";
    private static final String NO_TAGS_MESSAGE = "Try adding some tags first!";
    private static final String NO_TAGS_HEADING = ":( NO TAGS";
    private static final String LABEL_CSS = "-fx-padding: 1 3 1 3; -fx-text-fill: WHITE; -fx-background-color: %s;";


    public TagColorDialog(StackPane parent) {
        super(parent);
    }

    private void initialize(List<Tag> tags) {
        List<Node> displayTags = new ArrayList<Node>();

        for (Tag tag : tags) {
            Label label = createLabel(tag.getTagName().toString(),
                    tag.getTagColorIndex().getTagColorIndexAsInt());
            Node displayTag = setLabelSizingForDialogDisplay(label);
            displayTags.add(displayTag);
        }

        if (displayTags.size() > 0) {
            FlowPane pane = new FlowPane();
            pane.getChildren().addAll(displayTags);
            contentLayout.setHeading(new Label(HAS_TAGS_HEADING));
            contentLayout.setBody(pane);
        } else {
            contentLayout.setHeading(new Label(NO_TAGS_HEADING));
            contentLayout.setBody(new Label(NO_TAGS_MESSAGE));
        }
    }

    private Node setLabelSizingForDialogDisplay(Label label) {
        label.setMinHeight(20);
        label.setMaxHeight(20);
        label.setPrefHeight(20);
        label.setMinWidth(75);
        label.setMaxWidth(75);
        label.setPrefWidth(75);

        VBox vBox = new VBox();
        vBox.setPadding(new Insets(2, 2, 2, 2));
        vBox.getChildren().add(label);
        return vBox;
    }

    public void show(List<Tag> tags) {
        initialize(tags);
        super.show();
    }

    private Label createLabel(String name, int colorIndex) {
        Label label = new Label(name);
        addStylingPropertiesToLabel(label, colorIndex);
        return label;
    }

    private void addStylingPropertiesToLabel(Label label, int colorIndex) {
        label.setAlignment(Pos.CENTER);
        label.setTextAlignment(TextAlignment.CENTER);
        label.setTextOverrun(OverrunStyle.CLIP);
        label.setMinWidth(15.0);
        label.setStyle(String.format(LABEL_CSS, TagColorHelper.getColorValueFromIndex(colorIndex)));
        HBox.setMargin(label, new Insets(5, 5, 5, 0));
    }
}
```
###### \java\utask\ui\TaskListCard.java
``` java
    private void createTags(ReadOnlyTask task) {
        UniqueTagList tags = task.getTags();
        for (Tag tag : tags) {
            Label label = createLabel(tag.getTagName().toString(),
                    tag.getTagColorIndex().getTagColorIndexAsInt());
            hbTagContainer.getChildren().add(label);
        }
    }
```
