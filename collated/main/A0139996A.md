# A0139996A
###### \java\utask\logic\commands\CreateCommand.java
``` java
    public void undo() throws TaskNotFoundException {
        model.deleteTask(toAdd);
    }

    public void redo() throws DuplicateTaskException {
        model.addTask(toAdd);
    }
}
```
###### \java\utask\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {

        for (int targetIndex : targetList) {
            if (model.getTotalSizeOfLists() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            if (model.getTotalSizeOfLists() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            //- 1 as helper method is using zero-based indexing
            List<ReadOnlyTask> lastShownList =
                    UTListHelper.getInstance().getUnderlyingListOfListViewByIndex(targetIndex - 1);

            int actualInt = UTListHelper.getInstance().getActualIndexFromDisplayIndex(targetIndex - 1);
            taskToDelete = lastShownList.get(actualInt);

            //TODO: Find better a elegant solution
            //Needed to prevent TaskListPaneSelectionChangedEvent from triggering, which can go into a loop
            UTListViewHelper.getInstance().clearSelectionOfAllListViews();

            try {
                model.deleteTask(taskToDelete);
                model.addUndoCommand(this);
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS));
    }

    @Override
    public void undo() throws Exception {
        model.addTask((Task) taskToDelete);
    }

    @Override
    public void redo() throws Exception {
        model.deleteTask((Task) taskToDelete);
    }

}
```
###### \java\utask\logic\commands\DoneCommand.java
``` java
    @Override
    public void undo() throws Exception {
        createEditedTask(taskToEdit, false);
    }

    @Override
    public void redo() throws Exception {
        createEditedTask(taskToEdit, true);
    }
}
```
###### \java\utask\logic\commands\EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        if (filteredTaskListIndex >= model.getTotalSizeOfLists()) {
            throw new CommandException(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        List<ReadOnlyTask> lastShownList = UTListHelper.getInstance()
                .getUnderlyingListOfListViewByIndex(filteredTaskListIndex);

        int actualInt = UTListHelper.getInstance()
                .getActualIndexFromDisplayIndex(filteredTaskListIndex);

        taskToEdit = lastShownList.get(actualInt);

        // create modified task from existing task
        editedTask = createEditedTask(taskToEdit, editTaskDescriptor,
                attributeToRemove);

        try {
            model.updateTask(taskToEdit, editedTask);
            model.addUndoCommand(this);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        return new CommandResult(
                String.format(MESSAGE_EDIT_TASK_SUCCESS, editedTask));
    }

```
###### \java\utask\logic\commands\RedoCommand.java
``` java
package utask.logic.commands;

import utask.commons.core.Messages;
import utask.logic.commands.exceptions.CommandException;
import utask.logic.commands.inteface.ReversibleCommand;

public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redo undone commands. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_REDO_SUCCESS = "Redo: %1$s command";

    public final int index;

    public RedoCommand(int index) {
        this.index = index;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (index > model.getRedoCommandCount()) {
            throw new CommandException(Messages.MESSAGE_INVALID_REDO_RANGE);
        }

        ReversibleCommand redoCommand = model.getRedoCommand();

        try {
            redoCommand.redo();
            final ReversibleCommand undoCommand = redoCommand;
            model.addUndoCommand(undoCommand);
        } catch (Exception e) {
            //TODO: Is it sensible to add it back to the stack?
            //Will it work in the later in time of execution?
            model.addUndoCommand(redoCommand);
            throw new CommandException(Messages.MESSAGE_REDO_ERROR);
        }

        return new CommandResult(String.format(MESSAGE_REDO_SUCCESS, index));
    }
}
```
###### \java\utask\logic\commands\SelectCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {

        //UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
//      if (lastShownList.size() < targetIndex) {
//      throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
//       }
        if (model.getTotalSizeOfLists() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 1));
        return new CommandResult(String.format(MESSAGE_SELECT_TASK_SUCCESS, targetIndex));

    }

}
```
###### \java\utask\logic\commands\UndoCommand.java
``` java
package utask.logic.commands;

import utask.commons.core.Messages;
import utask.logic.commands.exceptions.CommandException;
import utask.logic.commands.inteface.ReversibleCommand;

public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo previous commands. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + "\n"
            +  COMMAND_WORD + " 1";

    public static final String MESSAGE_UNDO_SUCCESS = "Undo: %1$s command";

    public final int index;

    public UndoCommand(int index) {
        this.index = index;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (index > model.getUndoCommandCount()) {
            throw new CommandException(Messages.MESSAGE_INVALID_UNDO_RANGE);
        }

        ReversibleCommand undoCommand = model.getUndoCommand();

        try {
            undoCommand.undo();
            final ReversibleCommand redoCommand = undoCommand;
            model.addRedoCommand(redoCommand);
        } catch (Exception e) {
            //TODO: Is it sensible to add it back to the stack?
            //Will it work in the later in time of execution?
            model.addUndoCommand(undoCommand);
            throw new CommandException(Messages.MESSAGE_UNDO_ERROR);
        }

        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, index));
    }
}
```
###### \java\utask\logic\commands\UndoneCommand.java
``` java
    @Override
    public void undo() throws Exception {
        createEditedTask(taskToEdit, true);
    }

    @Override
    public void redo() throws Exception {
        createEditedTask(taskToEdit, false);
    }
}
```
###### \java\utask\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getDueFilteredTaskList() {
        return model.getDueFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getTodayFilteredTaskList() {
        return model.getTodayFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getTomorrowFilteredTaskList() {
        return model.getTomorrowFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFutureFilteredTaskList() {
        return model.getFutureFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFloatingFilteredTaskList() {
        return model.getFloatingFilteredTaskList();
    }
}
```
###### \java\utask\logic\parser\RedoCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.RedoCommand;

/**
 * Parses input arguments and creates a new UndoCommand object
 */
public class RedoCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the UndoCommand
     * and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent() && index.get() > 0) {
            return new RedoCommand(index.get());
        } else if (!index.isPresent()) {
            return new RedoCommand(1);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, RedoCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\logic\parser\UndoCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.UndoCommand;

/**
 * Parses input arguments and creates a new UndoCommand object
 */
public class UndoCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the UndoCommand
     * and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent() && index.get() > 0) {
            return new UndoCommand(index.get());
        } else if (!index.isPresent()) {
            return new UndoCommand(1);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public void addUndoCommand(ReversibleCommand undoCommand) {
        undoStack.push(undoCommand);
    }

    @Override
    public ReversibleCommand getUndoCommand() {
        return undoStack.pop();
    }

    @Override
    public int getUndoCommandCount() {
        return undoStack.size();
    }

    @Override
    public void addRedoCommand(ReversibleCommand redoCommand) {
        redoStack.push(redoCommand);
    }

    @Override
    public ReversibleCommand getRedoCommand() {
        return redoStack.pop();
    }

    @Override
    public int getRedoCommandCount() {
        return redoStack.size();
    }
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public void updateTask(ReadOnlyTask taskToEdit, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert taskToEdit != null;
        assert editedTask != null;

        uTask.updateTask(taskToEdit, editedTask);
        UTListHelper.getInstance().refresh();
        indicateUTaskChanged();
    }

    /** Gets total size of tasks in underlying lists of listviews*/
    @Override
    public int getTotalSizeOfLists() {
        return UTListHelper.getInstance().getTotalSizeOfAllList();
    }
    //@author

    private FilteredList<ReadOnlyTask> getTasksFliteredListByExactDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new ExactDateQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getTasksFliteredListByBeforeGivenDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new DateBeforeQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getTasksFliteredListByAfterGivenDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new DateAfterQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getFloatingTaskFliteredListByEmptyDeadlineAndTimestamp() {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new EmptyDeadlineAndTimestampQualifier()));
        return task;
    }
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getDueFilteredTaskList() {
        return new UnmodifiableObservableList<>(dueTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getTodayFilteredTaskList() {
        return new UnmodifiableObservableList<>(todayTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getTomorrowFilteredTaskList() {
        return new UnmodifiableObservableList<>(tomorrowTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFutureFilteredTaskList() {
        return new UnmodifiableObservableList<>(futureTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFloatingFilteredTaskList() {
        return new UnmodifiableObservableList<>(floatingTasks);
    }
```
###### \java\utask\model\ModelManager.java
``` java
    public void updateFilteredTaskListByKeywords(String keywords) {
        filteredTasks.setPredicate(task -> {
            // If filter text is empty, display all persons.
            if (keywords == null || keywords.isEmpty()) {
                return true;
            }

            //Set filter text as lower case, so to be case insensitive
            String lowerCaseFilter = keywords.toLowerCase();

            //TODO: Build comprehensive search
            return task.getName().fullName.toLowerCase().contains(lowerCaseFilter) ||
                   task.getTags().getAllTagNames().toLowerCase().contains(lowerCaseFilter);
        });
    }

    private void updateFilteredList(FilteredList<ReadOnlyTask> list, Expression expression) {
        list.setPredicate(expression::satisfies);
    }

```
###### \java\utask\model\ModelManager.java
``` java
    private class ExactDateQualifier implements Qualifier {
        private Date date;

        ExactDateQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            if (task.getDeadline().isEmpty()) {
                return false;
            }

            try {
                Date taskDate = task.getDeadline().getDate();
                return taskDate.getYear() == date.getYear()
                        && taskDate.getMonth() == date.getMonth()
                        && taskDate.getDay() == date.getDay();
            } catch (ParseException e) {
                assert false : "Date is in wrong format";
            }

            return false;
        }

        @Override
        public String toString() {
            return "date=" + date;
        }
    }

    private class DateBeforeQualifier implements Qualifier {
        private Date date;

        DateBeforeQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isEmpty()) {
                return false;
            }

            try {
                return task.getDeadline().getDate().before(date);
            } catch (ParseException e) {
                assert false : "Date is in wrong format";
            }
            return false;
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class DateAfterQualifier implements Qualifier {
        private Date date;

        DateAfterQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            if (task.getDeadline().isEmpty()) {
                return false;
            }

            try {
                return task.getDeadline().getDate().after(date);
            } catch (ParseException e) {
                assert false : "Date is in wrong format";
            }

            return false;
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class EmptyDeadlineAndTimestampQualifier implements Qualifier {
        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isEmpty() && task.getTimestamp().isEmpty()) {
                return true;
            } else {
                return false;
            }
        }

        @Override
        public String toString() {
            return "deadline&timestamp=empty";
        }
    }
}
```
###### \java\utask\staging\ui\events\FindRequestEvent.java
``` java
package utask.staging.ui.events;

import utask.commons.events.BaseEvent;

public class FindRequestEvent extends BaseEvent {

    public final String findKeywords;

    public FindRequestEvent(String findKeywords) {
        this.findKeywords = findKeywords;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\staging\ui\events\TaskListPanelSelectionChangedEvent.java
``` java
package utask.staging.ui.events;

import javafx.scene.control.ListView;
import utask.commons.events.BaseEvent;
import utask.model.task.ReadOnlyTask;

/**
 * Represents a selection change in the Person List Panel
 */
public class TaskListPanelSelectionChangedEvent extends BaseEvent {

    private final ReadOnlyTask newSelection;
    private final ListView<ReadOnlyTask> sender;

    public TaskListPanelSelectionChangedEvent(ListView<ReadOnlyTask> sender, ReadOnlyTask newSelection) {
        this.newSelection = newSelection;
        this.sender = sender;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ListView<ReadOnlyTask> getSender() {
        return sender;
    }

    public ReadOnlyTask getNewSelection() {
        return newSelection;
    }
}
```
###### \java\utask\staging\ui\helper\SuggestionHelper.java
``` java
package utask.staging.ui.helper;

import java.util.HashMap;

import utask.logic.commands.CreateCommand;
import utask.logic.commands.FindCommand;

public class SuggestionHelper {

    private static final HashMap<String, String> suggestionMap = new HashMap<>();

    static {
        suggestionMap.put(CreateCommand.COMMAND_WORD, CreateCommand.COMMAND_WORD + " " + CreateCommand.COMMAND_FORMAT);
        suggestionMap.put(FindCommand.COMMAND_WORD, FindCommand.COMMAND_WORD + " " + CreateCommand.COMMAND_FORMAT);
    }

    //TODO: Upgrade to balanced tree for a more dynamic suggestion
    public static final String getInputSuggestionOfPreamble(String preamble) {
        //If we do not recognise the command, then don't show suggestion
        if (!suggestionMap.containsKey(preamble)) {
            return "";
        }

        return suggestionMap.get(preamble);
    }
}
```
###### \java\utask\staging\ui\helper\TagColorHelper.java
``` java
package utask.staging.ui.helper;

import java.util.Random;

public class TagColorHelper {

    public static int getSize() {
        return ColorType.values().length;
    }

    public static String getARandomColor() {
        ColorType color = randomEnum(ColorType.class);
        return color.toString();
    }

    public static String getColorValueFromIndex (int colorIndex) {
        return getColorTypeFromIndex(colorIndex).toString();
    }

    private static ColorType getColorTypeFromIndex (int colorIndex) {
        assert colorIndex >= 0 : "Color index must be equals or greater than 0";
        assert colorIndex < getSize() : "Color index out of bounds of ColorType";
        return ColorType.values()[colorIndex];
    }

    public static String getColorValueFromName (String name) {
        return getColorTypeFromName(name.toUpperCase()).toString();
    }

    public static ColorType getColorTypeFromName (String name) {
        assert name != null : "Provided color name is null";
        return ColorType.valueOf(name);
    }

    private static <T extends Enum<?>> T randomEnum(Class<T> c) {
        Random random = new Random();
        int r = random.nextInt(c.getEnumConstants().length);
        return c.getEnumConstants()[r];
    }

    public static String getListOfSupportedColor() {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < ColorType.values().length; i++) {
            sb.append(ColorType.values()[i].name() + " ");
        }

        return sb.toString();
    }

    public enum ColorType {
        BLACK("#000"),
        BLUE("#2196F3"),
        CYAN("#00BCD4"),
        GREEN("#009688"),
        ORANGE("#FF5722"),
        PINK("#F06292"),
        PURPLE("#673AB7"),
        RED("#B71C1C"),
        YELLOW("#FFA000");

        private final String text;

        private ColorType(final String text) {
            this.text = text;
        }

        @Override
        public String toString() {
            return text;
        }
    }
}
```
###### \java\utask\staging\ui\stubs\SearchCommand.java
``` java
package utask.staging.ui.stubs;

import utask.commons.core.EventsCenter;
import utask.logic.commands.Command;
import utask.logic.commands.CommandResult;
import utask.logic.commands.exceptions.CommandException;
import utask.staging.ui.events.FindRequestEvent;

public class SearchCommand extends Command {

    public static final String COMMAND_WORD = "search";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Search a task to uTask.";

    public static final String MESSAGE_SUCCESS = "Searching for %s\n"
                                                + "Press [ESC] to return";

    private final String searchKeywords;

    /**
     * Creates an SearchCommand using raw values.
     */
    public SearchCommand(String searchKeywords) {
        this.searchKeywords = searchKeywords;
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredTaskListByKeywords(searchKeywords);
        EventsCenter.getInstance().post(new FindRequestEvent(""));
        return new CommandResult(String.format(MESSAGE_SUCCESS, searchKeywords));
    }

}
```
###### \java\utask\staging\ui\UTCommandBox.java
``` java
package utask.staging.ui;

import java.util.logging.Logger;

import javafx.application.Platform;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import utask.commons.core.LogsCenter;
import utask.commons.events.ui.NewResultAvailableEvent;
import utask.commons.events.ui.ShowHelpRequestEvent;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.logic.commands.CommandResult;
import utask.logic.commands.exceptions.CommandException;
import utask.staging.ui.events.KeyboardEscapeKeyPressedEvent;
import utask.staging.ui.helper.SuggestionHelper;

public class UTCommandBox extends StagingUiPart<Region> {

    private static final String FXML = "UTCommandBox.fxml";
    public static final String ERROR_STYLE_CLASS = "error-textfield";

    private final Logger logger = LogsCenter.getLogger(UTCommandBox.class);
    private final Logic logic;

    @FXML
    private Pane rootPane;

    @FXML
    private TextField commandTextField;

    @FXML
    private Label lblSuggestion;

    private String lastValidCommandEntry = "";

    public UTCommandBox(Pane parent, Logic logic) {
        super(FXML);
        this.logic = logic;
        addEventHandlerToControls();
        addControlsToParent(parent);
        addCommandBoxBehaviour();
    }

    private void addCommandBoxBehaviour() {
        Platform.runLater(() -> {
            commandTextField.requestFocus();
        });
    }

    private void addControlsToParent(Pane parent) {
        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void addEventHandlerToControls() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                handleKeyPressed(ke);
            }
        });
    }

    /**
     * Show full suggested command format on recognised command pattern.
     */
    private void handleKeyPressed(KeyEvent ke) {
        //TODO: If special key handled, dont propagate
        handleSpecialKeyCombination(ke);

        //TODO: Upgrade to binary tree
        String input = commandTextField.getText();

        if (!"".equals(input)) {
            input = (input.toLowerCase().split(" "))[0];
            String suggestion = SuggestionHelper.getInputSuggestionOfPreamble(input);
            lblSuggestion.setText(suggestion);
        }
    }

    private void handleSpecialKeyCombination(KeyEvent ke) {
        KeyCode keyPressed = ke.getCode();

        switch (keyPressed) {
        case ENTER :
            handleCommandInputChanged();
            break;
        case ESCAPE :
            raise(new KeyboardEscapeKeyPressedEvent());
            break;
        case F1 :
            raise(new ShowHelpRequestEvent());
            break;
        case UP :
            commandTextField.setText(lastValidCommandEntry);
            break;
        default:
            break;
        }
    }

```
###### \java\utask\staging\ui\UTListHelper.java
``` java
package utask.staging.ui;

import java.util.ArrayList;
import java.util.HashMap;

import com.google.common.eventbus.Subscribe;

import javafx.collections.transformation.FilteredList;
import utask.commons.core.EventsCenter;
import utask.commons.events.model.UTaskChangedEvent;
import utask.model.task.ReadOnlyTask;

/*
 * UTListHelper uses facade and singleton pattern
 * It provides an interface to simplify the manage of multiple underlying filterlist.
 *
 * */
public class UTListHelper {
    private static UTListHelper instance = null;
    private final ArrayList<FilteredList<ReadOnlyTask>> lists;
    private final HashMap<FilteredList<ReadOnlyTask>, Integer> offsetMap;

    private UTListHelper() {
        lists = new ArrayList<FilteredList<ReadOnlyTask>>();
        offsetMap = new HashMap<FilteredList<ReadOnlyTask>, Integer>();
        EventsCenter.getInstance().registerHandler(this);
    }

    public static UTListHelper getInstance() {
        if (instance == null) {
            instance = new UTListHelper();
        }

        return instance;
    }

    public void addListView(FilteredList<ReadOnlyTask>... list) {
        assert list != null;
//        assert list[0].get(0) instanceof ReadOnlyTask;

        for (int i = 0; i < list.length; i++) {
            addListView(list[i]);
        }
    }

    public void addListView(FilteredList<ReadOnlyTask> list) {
        assert list != null;
        lists.add(list);
    }

    public FilteredList<ReadOnlyTask> getUnderlyingListOfListViewByIndex(int index) {
        assert (index >= 0);

        FilteredList<ReadOnlyTask> list = getActualListViewFromDisplayIndex(index);

        assert(list != null);

        return list;
    }

    /*
     * Normalise the given to index to actual numbering in listview
     *
     * @param index is zero-based
     *
     * */
    public int getActualIndexFromDisplayIndex(int index) {
        FilteredList<ReadOnlyTask> lw = getActualListViewFromDisplayIndex(index);

        int actualInt = getActualIndexOfListView(lw, index);

        return actualInt;
    }

    /*
     * Normalise the given to index to actual numbering in listview
     *
     * @param index is zero-based
     *
     * */
    private int getActualIndexOfListView(FilteredList<ReadOnlyTask> listView, int index) {
        int offset = offsetMap.get(listView);

        if (index < offset) { //No need to normalise
            return index;
        }

        return index - offset;
    }

    /*
     * Searches for a listview given by the index
     *
     * @param index is zero-based
     *
     * */
    public FilteredList<ReadOnlyTask> getActualListViewFromDisplayIndex(int index) {
        int  totalSize = 0;

        for (FilteredList<ReadOnlyTask> l : lists) {

            totalSize += l.size();

            if (index < totalSize) {
                return l;
            }
        }

        assert false : "This line is suppose to be unreachable";
        return null;
    }

    /**
     *  Returns total sizes of all listview
     *
     *  Recalculation is necessary every time
     */
    public int getTotalSizeOfAllList() {

        assert(lists.size() > 0) :
            this.getClass() + " was used for the first time. Please add ListViews before calling this method";

        int  totalSize = 0;

        for (FilteredList<ReadOnlyTask> lv : lists) {
            totalSize += lv.size();
        }

        return totalSize;
    }

    public void refresh() {
        addToOffsetMap(lists.get(0), 1); //First list starts counting from 1

        if (lists.size() > 1) { //There's no point to refresh one list, otherwise
            int totalSize = 0;

            //Traverse and update next listview index based on previous size
            for (int i = 1; i < lists.size(); i++) {
                FilteredList<ReadOnlyTask> prevListView = lists.get(i - 1);
                FilteredList<ReadOnlyTask> currListView = lists.get(i);

                totalSize += prevListView.size();
                addToOffsetMap(currListView, totalSize); //Temporary cache this value for faster calculation
            }
        }
    }

    private void addToOffsetMap(FilteredList<ReadOnlyTask> lv, int offset) {
        offsetMap.put(lv, offset);
    }

    @Subscribe
    public void handleUTaskChangedEvent(UTaskChangedEvent e) {
        refresh();
    }
}
```
###### \java\utask\staging\ui\UTListViewHelper.java
``` java
package utask.staging.ui;

import java.util.ArrayList;
import java.util.HashMap;

import com.google.common.eventbus.Subscribe;

import javafx.application.Platform;
import javafx.scene.control.ListView;
import utask.commons.core.EventsCenter;
import utask.commons.events.model.UTaskChangedEvent;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.events.TaskListPanelSelectionChangedEvent;
import utask.staging.ui.helper.TaskListViewCell;

/*
 * UTListViewHelper uses facade and singleton pattern
 * It coordinates multiple listview to ensure their index numbers are in running sequence
 *
 * */
public class UTListViewHelper {
    private static UTListViewHelper instance = null;
    private final ArrayList<ListView<ReadOnlyTask>> listViews;
    private final HashMap<ListView<ReadOnlyTask>, Integer> offsetMap;

    private UTListViewHelper() {
        listViews = new ArrayList<ListView<ReadOnlyTask>>();
        offsetMap = new HashMap<ListView<ReadOnlyTask>, Integer>();
        EventsCenter.getInstance().registerHandler(this);
    }

    public static UTListViewHelper getInstance() {
        if (instance == null) {
            instance = new UTListViewHelper();
        }

        return instance;
    }

    public void addListView(ListView<ReadOnlyTask> lv) {
        listViews.add(lv);
        addDefaultCellFactory(lv);
    }

    public void updateListViews() {
        Platform.runLater(() -> {
            addToOffsetMap(listViews.get(0), 1); //First list starts counting from 1

            if (listViews.size() > 1) { //There's no point to refresh one list, otherwise
                int totalSize = 0;

                //Traverse and update next listview index based on previous size
                for (int i = 1; i < listViews.size(); i++) {
                    ListView<ReadOnlyTask> prevListView = listViews.get(i - 1);
                    ListView<ReadOnlyTask> currListView = listViews.get(i);

                    totalSize += prevListView.getItems().size();

                    final int value = totalSize; //Required by Java compiler
                    currListView.setCellFactory(l -> new TaskListViewCell(value));

                    addToOffsetMap(currListView, value); //Temporary cache this value for faster calculation
                }
            }
        });
    }


    //TODO: Possible to use lazy rendering to prevent double rendering
    private void addDefaultCellFactory(ListView<ReadOnlyTask> lv) {
        lv.setCellFactory(l -> new TaskListViewCell(0));
    }

    private void addToOffsetMap(ListView<ReadOnlyTask> lv, int offset) {
        offsetMap.put(lv, offset);
    }

    /**
     *  Returns total sizes of all listview
     *
     *  Recalculation is necessary every time
     */
//    public int getTotalSizeOfAllListViews() {
//
//        assert(listViews.size() > 0) :
//            "UTListViewHelper was used for the first time. Please add ListViews before calling this method";
//
//        int  totalSize = 0;
//
//        for (ListView<ReadOnlyTask> lv : listViews) {
//            totalSize += lv.getItems().size();
//        }
//
//        return totalSize;
//    }

    /*
     * Normalise the given to index to actual numbering in listview
     *
     * @param index is zero-based
     *
     * */
//    public int getActualIndexFromDisplayIndex(int index) {
//        ListView<ReadOnlyTask> lw = getActualListViewFromDisplayIndex(index);
//
//        int actualInt = getActualIndexOfListView(lw, index);
//
//        return actualInt;
//    }

    /*
     * Normalise the given to index to actual numbering in listview
     *
     * @param index is zero-based
     *
     * */
    private int getActualIndexOfListView(ListView<ReadOnlyTask> listView, int index) {
        int offset = offsetMap.get(listView);

        if (index < offset) { //No need to normalise
            return index;
        }

        return index - offset;
    }

    /*
     * Searches for a listview given by the index
     *
     * @param index is zero-based
     *
     * */
    public ListView<ReadOnlyTask> getActualListViewFromDisplayIndex(int index) {
        int  totalSize = 0;

        for (ListView<ReadOnlyTask> lv : listViews) {

            totalSize += lv.getItems().size();

            if (index < totalSize) {
                return lv;
            }
        }

        return null;
    }

//    public ObservableList<ReadOnlyTask> getUnderlyingListOfListViewByIndex(int index) {
//        assert (index >= 0);
//
//        ListView<ReadOnlyTask> listView = getActualListViewFromDisplayIndex(index);
//
//        assert(listView != null);
//
//        return listView.getItems();
//    }

    public void clearSelectionOfAllListViews() {
        for (ListView<ReadOnlyTask> lv : listViews) {
            lv.getSelectionModel().clearSelection();
        }
    }

    public void scrollTo(int index) {
        assert (index >= 0);

        ListView<ReadOnlyTask> listView = getActualListViewFromDisplayIndex(index);

        assert(listView != null);

        scrollTo(listView, index);
    }

    private void scrollTo(ListView<ReadOnlyTask> listView, int index) {
        Platform.runLater(() -> {
            int actualIndex = getActualIndexOfListView(listView, index);

            clearSelectionOfAllListViews();

            listView.scrollTo(actualIndex);
            listView.getSelectionModel().select(actualIndex);
        });
    }

    @Subscribe
    public void handleTaskListPanelSelectionChangedEvent(TaskListPanelSelectionChangedEvent e) {
        clearSelectionOfAllListViews();
        ListView<ReadOnlyTask> sender = e.getSender();
        sender.getSelectionModel().select(e.getNewSelection());
    }

    @Subscribe
    public void handleUTaskChangedEvent(UTaskChangedEvent e) {
        updateListViews();
    }
}
```
###### \java\utask\staging\ui\UTMainWindow.java
``` java
    public UTMainWindow(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.logic = logic;
        this.config = config;

        // Configure the UI
        setTitle(config.getAppTitle());
        setIcon(ICON);

        setWindowDefaultSize(prefs);
        setWindowMinSize();

        Scene scene = createScene();
        setStyleSheets(scene);
        this.primaryStage.setScene(scene);
        setEventHandlers();
        setAccelerators();
    }

    /*
     * Creates Scene
     * JFXDecorator is used to create 'material' styled window frame
     * */
    private Scene createScene() {
        JFXDecorator decorator = new JFXDecorator(this.primaryStage, getRoot(), false, true, true);
        decorator.setPrefSize(MIN_WIDTH, MIN_HEIGHT);
        decorator.setCustomMaximize(true);
        Scene scene = new Scene(decorator);
        return scene;
    }

    /*
     * Sets required CSS Stylesheets to a scene
     *
     * Note that fonts CSS has to be set first
     * */
    private void setStyleSheets(Scene scene) {
        scene.getStylesheets().add(UTMainWindow.class.getResource("/css/jfoenix-fonts.css").toExternalForm());
        scene.getStylesheets().add(UTMainWindow.class.getResource("/css/jfoenix-design.css").toExternalForm());
        scene.getStylesheets().add(UTMainWindow.class.getResource("/css/utask.css").toExternalForm());
    }

    /**
     * Sets the accelerator of a Button
     *
     * @param keyCombination the KeyCombination value of the accelerator
     */
    private void setAccelerator(Button control, KeyCombination keyCombination) {
        control.getScene().getAccelerators().put(keyCombination, new Runnable() {
            @Override
            public void run() {
                handleHelp();
            }
        });
    }

    private void setAccelerators() {
        setAccelerator(btnHelp, KeyCombination.valueOf("F1"));
    }

    private void setEventHandlers() {
        btnHelp.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                handleHelp();
            }
        });
    }

    void fillInnerParts() {
        new UTTaskListPanel(personListPanelPlaceholder, logic);
        todoListPanel = new UTTodoListPanel(todoListPanelPlaceholder, logic);
        new UTResultDisplay(resultDisplayPlaceholder);
        new UTStatusBarFooter(statusbarPlaceholder, config.getUTaskFilePath());
        new UTCommandBox(commandBoxPlaceholder, logic);
        new UTSearchTaskOverlay(topPlaceholder, logic);
    }

    public UTTodoListPanel getTodoListPanel() {
        return todoListPanel;
    }

```
###### \java\utask\staging\ui\UTSearchTaskOverlay.java
``` java
package utask.staging.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.animation.TranslateTransition;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import javafx.fxml.FXML;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumn.SortType;
import javafx.scene.control.TableView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.util.Duration;
import utask.commons.core.LogsCenter;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.events.FindRequestEvent;
import utask.staging.ui.events.KeyboardEscapeKeyPressedEvent;

public class UTSearchTaskOverlay extends StagingUiPart<Region> {

    private static final Logger logger = LogsCenter.getLogger(UTSearchTaskOverlay.class);
    private static final String FXML = "UTSearchTaskOverlay.fxml";

    private static final int SEARCHPANE_HIDDEN_X_POS = -3000;
    private final TranslateTransition openTransitionEffect = new TranslateTransition(new Duration(350), getRoot());
    private final TranslateTransition closeTransitionEffect = new TranslateTransition(new Duration(350), getRoot());

    @FXML
    private AnchorPane rootPane;

    @FXML
    private TableView<ReadOnlyTask> searchTable;

    @FXML
    private TableColumn<ReadOnlyTask, Number> columnIndex;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnName;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnDeadline;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnComplete;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnTimestamp;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnFrequency;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnTag;

    private ObservableList<ReadOnlyTask> masterData;

    private Pane parent;
    private boolean isSearchOverlayShown = false;

    private FilteredList<ReadOnlyTask> filteredData;
    private Logic logic;

    public UTSearchTaskOverlay(Pane parent, Logic logic) {
        super(FXML);

        assert(parent != null && logic != null);
        this.parent = parent;
        this.logic = logic;

        masterData = logic.getFilteredTaskList();
        initialize();
        registerAsAnEventHandler(this);
        rootPane.setTranslateX(SEARCHPANE_HIDDEN_X_POS);
        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(searchTable, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void initialize() {
        //Initialize the columns.
        addCellFactoriesToColumn();

        //Wrap the ObservableList in a FilteredList (initially display all data).
        filteredData = new FilteredList<>(masterData, p -> true);

        //Wrap the FilteredList in a SortedList.
        SortedList<ReadOnlyTask> sortedData = new SortedList<>(filteredData);

        //Bind the SortedList comparator to the TableView comparator.
        sortedData.comparatorProperty().bind(searchTable.comparatorProperty());

        //Add sorted (and filtered) data to the table.
        searchTable.setItems(sortedData);
    }

    private void addCellFactoriesToColumn() {

        //TODO: Try bean property
        //columnName.setCellValueFactory(cellData -> cellData.getValue().getNameProperty());

        columnIndex.setCellValueFactory(cellData-> new ReadOnlyObjectWrapper<Number>(
                                    searchTable.getItems().indexOf(cellData.getValue()) + 1));
        columnName.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getName().fullName));
        columnComplete.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getIsCompleted().value));
        columnDeadline.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getDeadline().value));
        columnTimestamp.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getTimestamp().value));
        columnFrequency.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getFrequency().value));
        columnTag.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getTags().getAllTagNames()));
        columnIndex.setSortable(false);
    }

    private void sort(TableColumn<ReadOnlyTask, String> column) {
        sort(column, SortType.ASCENDING);
    }

    private void sort(TableColumn<ReadOnlyTask, String> column, SortType sortOrder) {
        searchTable.getSortOrder().clear();
        columnName.setSortType(sortOrder);
        searchTable.getSortOrder().addAll(column);
    }

    public void filterResultsByKeywords(FilteredList<ReadOnlyTask> filteredData, String keywords) {
        filteredData.setPredicate(task -> {
            // If filter text is empty, display all persons.
            if (keywords == null || keywords.isEmpty()) {
                return true;
            }

            // Compare first name and last name of every person with filter text.
            String lowerCaseFilter = keywords.toLowerCase();

//            if (task.getFirstName().toLowerCase().contains(lowerCaseFilter)) {
//                return true; // Filter matches first name.
//            } else if (task.getLastName().toLowerCase().contains(lowerCaseFilter)) {
//                return true; // Filter matches last name.
//            }

            //TODO: Build comprehensive search
            return task.getName().fullName.toLowerCase().contains(lowerCaseFilter) ||
            task.getTags().getAllTagNames().toLowerCase().contains(lowerCaseFilter);

            //return false; // Does not match.
        });
    }

    public void delete() {
        ReadOnlyTask remove = searchTable.getSelectionModel().getSelectedItem();

        if (remove != null) {
            masterData.remove(remove);
            //TODO: Do actual remove
        }
    }

    public void openIfSearchIsNotShowing() {
        if (!isSearchOverlayShown) {
            openTransitionEffect.setToX(0);
            openTransitionEffect.play();
            isSearchOverlayShown = true;
        }
    }

    public void closeIfSearchIsShowing() {
        if (isSearchOverlayShown) {
            closeTransitionEffect.setToX(SEARCHPANE_HIDDEN_X_POS);
            closeTransitionEffect.play();
            isSearchOverlayShown = false;
        }
    }

    @Subscribe
    private void handleSearchRequestEvent(FindRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        //filterResultsByKeywords(filteredData, event.findKeywords.trim());
        openIfSearchIsNotShowing();
    }

    @Subscribe
    private void handleKeyboardEscapeKeyPressedEvent(KeyboardEscapeKeyPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        closeIfSearchIsShowing();
    }
}
```
###### \java\utask\staging\ui\UTTaskListPanel.java
``` java
package utask.staging.ui;

import java.util.logging.Logger;

import com.jfoenix.controls.JFXListView;

import javafx.beans.binding.Bindings;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import utask.commons.core.LogsCenter;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.events.TaskListPanelSelectionChangedEvent;

public class UTTaskListPanel extends StagingUiPart<Region> {
    private static final String FXML = "UTTaskListPanel.fxml";
    private static final double CARD_HEIGHT = UTTaskListCard.CARD_HEIGHT;
    private final Logger logger = LogsCenter.getLogger(UTTaskListPanel.class);

    @FXML
    private ScrollPane rootPane;

    @FXML
    private VBox container;

    public UTTaskListPanel(Pane parent, Logic logic) {
        super(FXML);

        assert (parent != null && logic != null);

        addControlsToParent(parent, logic);
    }

    private void addControlsToParent(Pane parent, Logic logic) {
        //TODO: Use proper logic methods to populate
        createLabelledListViewControl(container, logic.getDueFilteredTaskList(), "Due");
        createLabelledListViewControl(container, logic.getTodayFilteredTaskList(), "Today");
        createLabelledListViewControl(container, logic.getTomorrowFilteredTaskList(), "Tomorrow");
        createLabelledListViewControl(container, logic.getFutureFilteredTaskList(), "Future");

        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);

        //TODO: This is not the right place to call!
        UTListViewHelper.getInstance().updateListViews();
    }

    private void createLabelledListViewControl(Pane parent, ObservableList<ReadOnlyTask> tasks, String labelName) {

        assert(tasks != null);

        Label label = createLabel(labelName);
        JFXListView<ReadOnlyTask> listView = createListView();
        listView.setId("lst" + labelName);

        addLabelledListViewToParent(parent, label, listView);

        setConnections(listView, tasks);
        addStylingPropertiesToLabelBasedOnListViewSize(listView, label);
        addStylingPropertiesToListView(listView);
    }

    private Label createLabel(String name) {
        Label label = new Label(name);
        label.getStyleClass().add("list-label");
        return label;
    }

    private JFXListView<ReadOnlyTask> createListView() {
        JFXListView<ReadOnlyTask> list = new JFXListView<ReadOnlyTask>();
        list.getStyleClass().add("jfx-list-view");
        list.getStyleClass().add("custom-jfx-list-view1");
        return list;
    }

    private void addLabelledListViewToParent(Pane parent, Label label, JFXListView<ReadOnlyTask> list) {
        parent.getChildren().add(label);
        parent.getChildren().add(list);
    }

    private void addStylingPropertiesToListView(JFXListView<ReadOnlyTask> listView) {
        listView.minHeightProperty().bind(Bindings.size(listView.getItems()).multiply(CARD_HEIGHT));
        listView.visibleProperty().bind(Bindings.size(listView.getItems()).greaterThan(0));
        listView.managedProperty().bind(listView.visibleProperty());
    }

    /**
     * If listview has no items, it will not be visible.
     * Use managedProperty to invoke redrawing on UI
     */
    private void addStylingPropertiesToLabelBasedOnListViewSize(JFXListView<ReadOnlyTask> listView, Label label) {
        label.visibleProperty().bind(Bindings.size(listView.getItems()).greaterThan(0));
        label.managedProperty().bind(label.visibleProperty());
    }

    private void setConnections(ListView<ReadOnlyTask> listView, ObservableList<ReadOnlyTask> tasks) {
        listView.setItems(tasks);
        UTListViewHelper.getInstance().addListView(listView);
        setEventHandlerForSelectionChangeEvent(listView);
    }

```
###### \java\utask\staging\ui\UTTodoListPanel.java
``` java
package utask.staging.ui;

import java.util.logging.Logger;

import com.jfoenix.controls.JFXListView;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ListView;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import utask.commons.core.LogsCenter;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.events.TaskListPanelSelectionChangedEvent;

public class UTTodoListPanel extends StagingUiPart<Region> {
    private static final String FXML = "UTTodoListPanel.fxml";
    private final Logger logger = LogsCenter.getLogger(UTTodoListPanel.class);

    @FXML
    private VBox rootPane;

    @FXML
    private JFXListView<ReadOnlyTask> lstTodoTasks;

    public UTTodoListPanel(Pane parent, Logic logic) {
        super(FXML);

        assert(parent != null && logic != null);

        addStylingPropertiesToControls();
        setConnections(lstTodoTasks, logic.getFloatingFilteredTaskList());

        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void addStylingPropertiesToControls() {
        lstTodoTasks.getStyleClass().add("jfx-list-view");
        lstTodoTasks.getStyleClass().add("custom-jfx-list-view1");
        lstTodoTasks.setStyle("-jfx-expanded : true;");
    }

    private void setConnections(ListView<ReadOnlyTask> listView, ObservableList<ReadOnlyTask> tasks) {
        listView.setItems(tasks);

        //Add listview to helper for chain counting
        UTListViewHelper.getInstance().addListView(listView);
        setEventHandlerForSelectionChangeEvent(listView);
    }

```
###### \resources\staging\UTCommandBox.fxml
``` fxml
<?import com.jfoenix.controls.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>
<?import java.net.URL?>

<VBox fx:id="rootPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<JFXTextField fx:id="commandTextField" labelFloat="true"
			prefHeight="35.0" promptText="Enter your commands here..."
			styleClass="subhead">
			<VBox.margin>
				<Insets top="15.0" />
			</VBox.margin>
		</JFXTextField>
		<Label fx:id="lblSuggestion" minWidth="600.0" prefHeight="27.0"
			textFill="#3c1aff">
			<padding>
				<Insets left="3.0" />
			</padding>
		</Label>
	</children>
	<VBox.margin>
		<Insets bottom="5.0" left="15.0" right="15.0" top="5.0" />
	</VBox.margin>
</VBox>
```
###### \resources\staging\UTSearchTaskOverlay.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<AnchorPane fx:id="rootPane" HBox.hgrow="ALWAYS" VBox.vgrow="ALWAYS"
	xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<TableView fx:id="searchTable" prefHeight="-1.0" prefWidth="-1.0"
			tableMenuButtonVisible="false">
			<columns>
				<TableColumn fx:id="columnIndex" minWidth="50.0" maxWidth="50.0" text="#" />
				<TableColumn fx:id="columnName" minWidth="200" text="a. Task Name" />
				<TableColumn fx:id="columnComplete" minWidth="50" text="b. Completed" />
				<TableColumn fx:id="columnDeadline" minWidth="100" text="c. Deadline" />
				<TableColumn fx:id="columnTimestamp" minWidth="100" text="d. Timestamp" />
				<TableColumn fx:id="columnFrequency" minWidth="100" text="e. Repeat" />
				<TableColumn fx:id="columnTag" minWidth="200" text="f. Tags" />
			</columns>
			<columnResizePolicy>
				<TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
			</columnResizePolicy>
		</TableView>
	</children>

	<padding>
		<Insets bottom="15.0" left="10.0" right="10.0" top="15.0" />
	</padding>
</AnchorPane>
```
###### \resources\staging\UTTaskListCard.fxml
``` fxml

<?import com.jfoenix.controls.JFXCheckBox?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<HBox maxHeight="75.0" minHeight="75.0" minWidth="120.0" prefHeight="75.0" prefWidth="120.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <VBox HBox.hgrow="NEVER">
         <HBox.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </HBox.margin>
         <children>
            <Label fx:id="lblId" alignment="TOP_CENTER" contentDisplay="TOP" minWidth="30.0" text="999" VBox.vgrow="NEVER">
               <font>
                  <Font name="System Bold" size="16.0" />
               </font>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </Label>
            <JFXCheckBox fx:id="chkDone" alignment="TOP_CENTER" contentDisplay="CENTER" focusTraversable="false" minWidth="30.0" mnemonicParsing="false" text="" textAlignment="CENTER" VBox.vgrow="NEVER">
               <font>
                  <Font size="1.0" />
               </font>
               <VBox.margin>
                  <Insets top="5.0" />
               </VBox.margin>
            </JFXCheckBox>
         </children>
      </VBox>
      <VBox HBox.hgrow="ALWAYS">
         <children>
            <Label fx:id="lblName" alignment="TOP_CENTER" contentDisplay="TOP" focusTraversable="false" graphicTextGap="0.0" text="Lorem ipsum dolor sit amet, ipsum harum sed ea, ne posse putent nam, mei et dicit quodsi. Brute eripuit explicari." wrapText="true">
               <font>
                  <Font size="16.0" />
               </font>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </Label>
            <HBox fx:id="hbTagContainer" prefHeight="20.0">
            <!--
            <children>
                  <Label alignment="CENTER" contentDisplay="CENTER" minWidth="15.0" style="-fx-background-color: RED;" text="Important" textAlignment="CENTER" textFill="WHITE" textOverrun="CLIP">
                     <HBox.margin>
                        <Insets bottom="5.0" left="0.0" right="5.0" top="5.0" />
                     </HBox.margin>
                     <padding>
                        <Insets bottom="1.0" left="1.0" right="1.0" top="1.0" />
                     </padding>
                  </Label>
               </children>
              -->
            </HBox>
            <Label fx:id="lblDate" prefHeight="20.0" text="" textFill="#1a00ff" />
         </children>
         <HBox.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </HBox.margin>
      </VBox>
   </children>
</HBox>
```
