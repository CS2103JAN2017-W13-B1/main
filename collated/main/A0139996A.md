# A0139996A
###### \java\utask\commons\events\ui\FindRequestEvent.java
``` java
//An event to notify FindTaskOverlay to show its UI
public class FindRequestEvent extends BaseEvent {
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\commons\events\ui\KeyboardEscapeKeyPressedEvent.java
``` java
/*
 * This event is used to notify all subscribe that escape key has been press,
 * which results in the dismissal of dialogs and overlay
 * */
public class KeyboardEscapeKeyPressedEvent extends BaseEvent {
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\commons\events\ui\ShowAliasDialogEvent.java
``` java
/*
 * This event is used to notify UTMainWindow to show a alias dialog
 * */
public class ShowAliasDialogEvent extends BaseEvent {

    public final Map<String, String> map;

    public ShowAliasDialogEvent(Map<String, String> map) {
        this.map = map;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\commons\events\ui\ShowTagColorDialogEvent.java
``` java
/*
 * This event is used to notify MainWindow to show a tag color dialog
 * */
public class ShowTagColorDialogEvent extends BaseEvent {

    public final List<Tag> tags;

    public ShowTagColorDialogEvent(List<Tag> tags) {
        this.tags = tags;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\commons\events\ui\ShowTaskOfInterestInFindTaskOverlayEvent.java
``` java
/*
 * This event is used to notify FindTaskOverlay to select last added or updated task
 * */
public class ShowTaskOfInterestInFindTaskOverlayEvent extends BaseEvent {

    public final ReadOnlyTask task;

    public ShowTaskOfInterestInFindTaskOverlayEvent(ReadOnlyTask task) {
        this.task = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\commons\events\ui\ShowTaskOfInterestInMainWindowEvent.java
``` java
/*
 * This event is used to notify ListViewHelper to select last added or updated task
 * */
public class ShowTaskOfInterestInMainWindowEvent extends BaseEvent {

    public final ReadOnlyTask task;

    public ShowTaskOfInterestInMainWindowEvent(ReadOnlyTask task) {
        this.task = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\commons\events\ui\TaskListPanelSelectionChangedEvent.java
``` java
/**
 * Represents a selection change in the Task List Panel
 */
public class TaskListPanelSelectionChangedEvent extends BaseEvent {

    private final ReadOnlyTask newSelection;
    private final ListView<ReadOnlyTask> sender;

    public TaskListPanelSelectionChangedEvent(ListView<ReadOnlyTask> sender, ReadOnlyTask newSelection) {
        this.newSelection = newSelection;
        this.sender = sender;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ListView<ReadOnlyTask> getSender() {
        return sender;
    }

    public ReadOnlyTask getNewSelection() {
        return newSelection;
    }
}
```
###### \java\utask\commons\events\ui\UpdateSortInFindTaskOverlayEvent.java
``` java
/*
 * This event is used to notify ListViewHelper to select last added or updated task
 * */
public class UpdateSortInFindTaskOverlayEvent extends BaseEvent {

    public final String columnAlphabet;
    public final String orderBy;

    public UpdateSortInFindTaskOverlayEvent(String columnAlphabet, String orderBy) {
        this.columnAlphabet = columnAlphabet;
        this.orderBy = orderBy;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\commons\util\DateUtil.java
``` java
/*Helper functions for handling date parsing and creation of date object.*/
public class DateUtil {
    private static final int HOUR_START_INDEX = 0;
    private static final int HOUR_END_INDEX = 2;
    private static final int MINUTE_START_INDEX = 2;
    private static final int MINUTE_END_INDEX = 4;
    //The positon of the last character of the string + 1, is the same as the end of hhmm string
    private static final int VALID_HHMM_LENGTH = MINUTE_END_INDEX;
    private static final String DISPLAYED_FORMATTED_TIME = "HHmm";
    private static final String ALPHABET_PATTERN = "[a-zA-Z ]+";
    private static final List<SimpleDateFormat> knownPatterns;
    private static final Map<String, Integer> wordPatterns;

    private static final int DAYS_DIFFERENCE_TODAY = 0;
    private static final int DAYS_DIFFERENCE_TOMORROW = 1;

    private static final String[] SUPPORTED_DATE_FORMAT = {"ddMMyy"};
    private static final String[] WAYS_TO_SPELL_TODAY = {"today"};
    private static final String[] WAYS_TO_SPELL_TOMORROW = {"tomorrow", "tmr", "tmrw", "next day"};

    private static final Calendar calendar;

    static {
        calendar = Calendar.getInstance();
        knownPatterns = new ArrayList<SimpleDateFormat>();
        addSupportedDateFormatToKnownPattern(SUPPORTED_DATE_FORMAT);

        wordPatterns = new HashMap<String, Integer>();
        addWordsToWordPattern(WAYS_TO_SPELL_TODAY, DAYS_DIFFERENCE_TODAY);
        addWordsToWordPattern(WAYS_TO_SPELL_TOMORROW, DAYS_DIFFERENCE_TOMORROW);
    }

    private static void addWordsToWordPattern(String[] waysArray, int value) {
        for (int i = 0; i < waysArray.length; i++) {
            String key = waysArray[i];
            wordPatterns.put(key, value);
        }
    }

    private static void addSupportedDateFormatToKnownPattern(String[] dates) {
        for (int i = 0; i < dates.length; i++) {
            String key = dates[i];
            SimpleDateFormat dateFormat = new SimpleDateFormat(key);
            dateFormat.setLenient(false);
            knownPatterns.add(dateFormat);
        }
    }

    //Verifies that we know how to parse the string
    public static boolean isWordAValidDate(String string) {
        if (!string.isEmpty() && parseStringToDate(string).isPresent()) {
            return true;
        }

        return false;
    }

    //Parse the string and return as Optional<Date>
    public static Optional<Date> parseStringToDate(String string) {
        assert string != null && !string.isEmpty();

        if (string.matches(ALPHABET_PATTERN)) { //If it only contain alphabetical characters
            return parseStringByWord(string);
        } else {
            for (SimpleDateFormat pattern : knownPatterns) {
                try {
                    Date date = pattern.parse(string);
                    return Optional.of(date);
                } catch (ParseException pe) {
                    //Continue to check for other patterns
                }
            }
        }
        return Optional.empty();
    }
    private static Optional<Date> parseStringByWord(String string) {
        if (wordPatterns.containsKey(string)) {
            int offset = wordPatterns.get(string);

            Date date = new Date();
            date = clearTimeInDate(date);
            date = addDayOfMonthToDate(date, offset);
            return Optional.of(date);
        }

        return Optional.empty();
    }

    public static Date addHHMMStringToDate(Date date, String hhmm) {
        assert hhmm != null && !hhmm.isEmpty() && hhmm.length() == VALID_HHMM_LENGTH;
        assert date != null;

        String hh = hhmm.substring(HOUR_START_INDEX, HOUR_END_INDEX);
        String mm = hhmm.substring(MINUTE_START_INDEX, MINUTE_END_INDEX);

        int hours = Integer.parseInt(hh);
        int minutes = Integer.parseInt(mm);
        date = addHoursToDate(date, hours);
        date = addMinutesToDate(date, minutes);

        return date;
    }

    //hours in HH 24hrs
    private static Date addHoursToDate(Date date, int hours) {
        calendar.setTime(date);
        calendar.add(Calendar.HOUR_OF_DAY, hours);
        return calendar.getTime();
    }

    private static Date addMinutesToDate(Date date, int minutes) {
        calendar.setTime(date);
        calendar.add(Calendar.MINUTE, minutes);
        return calendar.getTime();
    }

    private static Date addDayOfMonthToDate(Date date, int dayOfMonth) {
        calendar.setTime(date);
        calendar.add(Calendar.DAY_OF_MONTH, dayOfMonth);
        return calendar.getTime();
    }

    public static String getFormattedTime(Date date) {
        assert date != null;
        SimpleDateFormat formatter = new SimpleDateFormat(DISPLAYED_FORMATTED_TIME);
        String formattedTime = formatter.format(date);
        return formattedTime;
    }

    private static Date clearTimeInDate(Date date) {
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        return calendar.getTime();
    }

    public static Date getEmptyDate() {
        Date now = new Date();
        now = clearTimeInDate(now);
        calendar.setTime(now);
        calendar.set(Calendar.DAY_OF_MONTH, 0);
        calendar.set(Calendar.MONTH, 0);
        calendar.set(Calendar.YEAR, 0);
        return calendar.getTime();
    }

    //Composite two dates together, which is used in updating of timestamp
    public static Date getDateUsingTimeComponentAndDateComponent(Date time, Date date) {
        assert time != null && date != null;
        calendar.setTime(date);
        calendar.set(Calendar.HOUR, time.getHours());
        calendar.set(Calendar.MINUTE, time.getMinutes());
        calendar.set(Calendar.SECOND, time.getSeconds());
        return calendar.getTime();
    }
}
```
###### \java\utask\logic\commands\Command.java
``` java
    /**
     * Provides a way to notify UI to selected task of interest
     */
    protected void notifyUI(ReadOnlyTask task) {
        assert task != null : "Incorrect usage: Task should not be null";

        if (model.isFindOverlayShowing()) {
            EventsCenter.getInstance().post(new ShowTaskOfInterestInFindTaskOverlayEvent(task));
        } else {
            EventsCenter.getInstance().post(new ShowTaskOfInterestInMainWindowEvent(task));
        }
    }
```
###### \java\utask\logic\commands\CreateCommand.java
``` java
    public void undo() throws Exception {
        notifyUI(toAdd);

        //Access to deleteTask() must be delayed to prevent race condition with notifyUI
        new DelayedExecution((e)-> {
            try {
                model.deleteTask(toAdd);
            } catch (TaskNotFoundException pnfe) {
                //TODO: Display error using another async channel
                assert false : "The target task cannot be missing";
            }
        }).run();
    }

    public void redo() throws DuplicateTaskException {
        model.addTask(toAdd);
        notifyUI(toAdd);
    }
```
###### \java\utask\logic\commands\CreateDeadlineTaskCommand.java
``` java
public class CreateDeadlineTaskCommand extends CreateCommand {

    public CreateDeadlineTaskCommand(String name, String deadline,
            String frequency, Set<String> tags, String status)
            throws IllegalValueException {
        super(frequency, tags, status);

        this.toAdd = new DeadlineTask(new Name(name), new Deadline(deadline),
                this.frequency, new UniqueTagList(tagSet),
                this.status);
    }
}
```
###### \java\utask\logic\commands\CreateEventTaskCommand.java
``` java
public class CreateEventTaskCommand extends CreateCommand {

    public CreateEventTaskCommand(String name, String deadline,
            String timestamp, String frequency, Set<String> tags,
            String status) throws IllegalValueException {
        super(frequency, tags, status);

        this.toAdd = new EventTask(new Name(name), new Deadline(deadline),
                new Timestamp(deadline, timestamp), this.frequency,
                new UniqueTagList(tagSet), this.status);
    }
}
```
###### \java\utask\logic\commands\CreateFloatingTaskCommand.java
``` java
public class CreateFloatingTaskCommand extends CreateCommand {

    public CreateFloatingTaskCommand(String name, String frequency,
            Set<String> tags, String status) throws IllegalValueException {
        super(frequency, tags, status);

        this.toAdd = new FloatingTask(new Name(name), this.frequency,
                new UniqueTagList(tagSet), this.status);
    }
}
```
###### \java\utask\logic\commands\inteface\ReversibleCommand.java
``` java
//Commands that can be undo or redo must implement this interface
public interface ReversibleCommand {
    void undo() throws Exception;
    void redo() throws Exception;
}
```
###### \java\utask\logic\commands\ListAliasCommand.java
``` java
/**
 * Shows alias in a dialog in the uTask to the user.
 */
public class ListAliasCommand extends Command {
    public static final String COMMAND_WORD = "listalias";
    public static final String COMMAND_FORMAT = "";
    public static final String MESSAGE_SUCCESS = "Showing all alias";

    @Override
    public CommandResult execute() {
        Map<String, String> map = AliasCommandMap.getInstance().getAliasMap();
        EventsCenter.getInstance().post(new ShowAliasDialogEvent(map));
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\utask\logic\commands\ListTagCommand.java
``` java
/**
 * Shows tag in a dialog in the uTask to the user.
 */
public class ListTagCommand extends Command {
    public static final String COMMAND_WORD = "listtag";
    public static final String COMMAND_FORMAT = "";
    public static final String MESSAGE_SUCCESS = "Showing all tags";

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowTagColorDialogEvent(model.getTags()));
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\utask\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redo undone commands. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_REDO_SUCCESS = "Redo: %1$s command";

    public final int index;

    public RedoCommand(int index) {
        this.index = index;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (index > model.getRedoCommandCount()) {
            throw new CommandException(Messages.MESSAGE_INVALID_REDO_RANGE);
        }

        try {
            for (int i = 0; i < index; i++) {
                ReversibleCommand redoCommand = model.getRedoCommand();
                redoCommand.redo();
                final ReversibleCommand undoCommand = redoCommand;
                model.addUndoCommand(undoCommand);
            }
        } catch (Exception e) {
            throw new CommandException(Messages.MESSAGE_REDO_ERROR);
        }

        return new CommandResult(String.format(MESSAGE_REDO_SUCCESS, index));
    }
}
```
###### \java\utask\logic\commands\SelectCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        if (model.getTotalSizeOfLists() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        if (model.isFindOverlayShowing()) {
            EventsCenter.getInstance().post(new JumpToListInFindTaskOverlayEvent(targetIndex - 1));
        } else {
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 1));
        }

        return new CommandResult(String.format(MESSAGE_SELECT_TASK_SUCCESS, targetIndex));
    }

}
```
###### \java\utask\logic\commands\SortInFindCommand.java
``` java
/**
 * Sorts in find overlay
 */
public class SortInFindCommand extends Command {

    //TODO: Very similar with Jiahao general sort
    public static final String COMMAND_WORD = "sort";
    public static final String MESSAGE_SUCCESS = "Tasks list has been sorted";

    public static final String COMMAND_FORMAT = "COLUMN_ALPHABET [ ASC | DSC ]";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Sort tasks. "
            + "Parameters: " + COMMAND_FORMAT + "\n";

    private final String column;
    private final String orderBy;

    public SortInFindCommand(String column, String orderBy) {
        this.column = column;
        this.orderBy = orderBy;
    }

    @Override
    public CommandResult execute() throws CommandException {
        EventsCenter.getInstance().post(new UpdateSortInFindTaskOverlayEvent(column, orderBy));
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\utask\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo previous commands. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + "\n"
            +  COMMAND_WORD + " 1";

    public static final String MESSAGE_UNDO_SUCCESS = "Undo: %1$s command";

    public final int index;

    public UndoCommand(int index) {
        this.index = index;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (index > model.getUndoCommandCount()) {
            throw new CommandException(Messages.MESSAGE_INVALID_UNDO_RANGE);
        }

        try {
            for (int i = 0; i < index; i++) {
                ReversibleCommand undoCommand = model.getUndoCommand();
                undoCommand.undo();
                final ReversibleCommand redoCommand = undoCommand;
                model.addRedoCommand(redoCommand);
            }
        } catch (Exception e) {
            throw new CommandException(Messages.MESSAGE_UNDO_ERROR);
        }

        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, index));
    }
}
```
###### \java\utask\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getDueFilteredTaskList() {
        return model.getDueFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getTodayFilteredTaskList() {
        return model.getTodayFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getTomorrowFilteredTaskList() {
        return model.getTomorrowFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFutureFilteredTaskList() {
        return model.getFutureFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFloatingFilteredTaskList() {
        return model.getFloatingFilteredTaskList();
    }

    @Override
    public void setIfFindOverlayShowing(boolean isShowing) {
        model.setIfFindOverlayShowing(isShowing);
    }
}
```
###### \java\utask\logic\parser\ParserUtil.java
``` java
    public static String parseColumnAlphabetOfSortInFind(String command) throws IllegalValueException {
        assert command != null && !command.isEmpty();

        Matcher matcher = SORT_IN_FIND_FORMAT.matcher(command);

        String column = "";

        if (matcher.matches()) {
            column = matcher.group("columnAlphabet");
        } else {
            throw new IllegalValueException(SortInFindCommand.MESSAGE_USAGE);
        }

        return column;
    }

    public static String parseOrderByOfSortInFind(String command) throws IllegalValueException {
        assert command != null && !command.isEmpty();

        Matcher matcher = SORT_IN_FIND_FORMAT.matcher(command);

        String orderBy = "";

        if (matcher.matches()) {
            orderBy = matcher.group("orderBy");

            //Since orderBy is optional, matcher::group may return a null ptr.
            if (orderBy == null) {
                orderBy = "";
            }
        } else {
            throw new IllegalValueException(SortInFindCommand.MESSAGE_USAGE);
        }

        return orderBy;
    }
}
```
###### \java\utask\logic\parser\RedoCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.RedoCommand;

/**
 * Parses input arguments and creates a new RedoCommand object
 */
public class RedoCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the RedoCommand
     * and returns an ReodoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);

        if (index.isPresent() && index.get() > 0) {
            //If given value is in valid range of positive integer
            return new RedoCommand(index.get());
        } else if (args.isEmpty()) {
            //User input only redo, so autofill it with a 1
            return new RedoCommand(1);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, RedoCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\logic\parser\SortInFindCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import utask.commons.exceptions.IllegalValueException;
import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.SortInFindCommand;

/**
 * Parses input arguments and creates a new SortInFindCommand object
 */
public class SortInFindCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SortCommandParser
     * and returns an SortInFindCommandParser object for execution.
     */
    public Command parse(String args) {
        try {
            String input = args.trim().toLowerCase();
            String column = ParserUtil.parseColumnAlphabetOfSortInFind(input);
            String orderBy = ParserUtil.parseOrderByOfSortInFind(input);

            if (!column.isEmpty()) {
                return new SortInFindCommand(column, orderBy);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(ive.getMessage()));
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, SortInFindCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\logic\parser\UndoCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.UndoCommand;

/**
 * Parses input arguments and creates a new UndoCommand object
 */
public class UndoCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the UndoCommand
     * and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);

        if (index.isPresent() && index.get() > 0) {
            //If given value is in valid range of positive integer
            return new UndoCommand(index.get());
        } else if (args.isEmpty()) {
            //User input only undo, so autofill it with a 1
            return new UndoCommand(1);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public void addUndoCommand(ReversibleCommand undoCommand) {
        undoStack.push(undoCommand);
    }

    @Override
    public ReversibleCommand getUndoCommand() {
        return undoStack.pop();
    }

    @Override
    public int getUndoCommandCount() {
        return undoStack.size();
    }

    @Override
    public void addRedoCommand(ReversibleCommand redoCommand) {
        redoStack.push(redoCommand);
    }

    @Override
    public ReversibleCommand getRedoCommand() {
        return redoStack.pop();
    }

    @Override
    public int getRedoCommandCount() {
        return redoStack.size();
    }
```
###### \java\utask\model\ModelManager.java
``` java
    /** Gets total size of tasks in underlying lists of listviews*/
    @Override
    public int getTotalSizeOfLists() {
        return FilteredListHelper.getInstance().getTotalSizeOfAllList();
    }

    @Override
    public void setIfFindOverlayShowing(boolean isShowing) {
        FilteredListHelper.getInstance().setIfFindOverlayShowing(isShowing);
    }

    @Override
    public boolean isFindOverlayShowing() {
        return FilteredListHelper.getInstance().isFindOverlayShowing();
    }

    @Override
    public List<ReadOnlyTask> getUnderlyingListByIndex(int displayIndex) {
        return FilteredListHelper.getInstance().getUnderlyingListByIndex(displayIndex);
    }

    @Override
    public int getActualIndexFromDisplayIndex(int displayIndex) {
        return FilteredListHelper.getInstance().getActualIndexFromDisplayIndex(displayIndex);
    }

    private FilteredList<ReadOnlyTask> getTasksFliteredListByExactDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new ExactDateQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getTasksFliteredListByBeforeGivenDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new DateBeforeQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getTasksFliteredListByAfterGivenDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new DateAfterQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getFloatingTaskFliteredListByEmptyDeadlineAndTimestamp() {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new EmptyDeadlineAndTimestampQualifier()));
        return task;
    }
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getDueFilteredTaskList() {
        return new UnmodifiableObservableList<>(dueTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getTodayFilteredTaskList() {
        return new UnmodifiableObservableList<>(todayTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getTomorrowFilteredTaskList() {
        return new UnmodifiableObservableList<>(tomorrowTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFutureFilteredTaskList() {
        return new UnmodifiableObservableList<>(futureTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFloatingFilteredTaskList() {
        return new UnmodifiableObservableList<>(floatingTasks);
    }
```
###### \java\utask\model\ModelManager.java
``` java
    public void updateFilteredTaskListByKeywords(String keywords) {
        filteredFindTasks.setPredicate(task -> {
            // If filter text is empty, display all persons.
            if (keywords == null || keywords.isEmpty()) {
                return true;
            }

            //Set filter text as lower case, so to be case insensitive
            String lowerCaseFilter = keywords.toLowerCase();

            //TODO: Build comprehensive search
            return task.getName().fullName.toLowerCase().contains(lowerCaseFilter) ||
                   task.getTags().getAllTagNames().toLowerCase().contains(lowerCaseFilter);
        });
    }

    private void updateFilteredList(FilteredList<ReadOnlyTask> list, Expression expression) {
        list.setPredicate(expression::satisfies);
    }

```
###### \java\utask\model\ModelManager.java
``` java
    private class ExactDateQualifier implements Qualifier {
        private Date date;

        ExactDateQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            if (task.getDeadline().isEmpty()) {
                return false;
            }

            Date taskDate = task.getDeadline().getDate();

            return taskDate.getYear() == date.getYear()
                    && taskDate.getMonth() == date.getMonth()
                    && taskDate.getDate() == date.getDate()
                    && !task.getStatus().isStatusComplete();
        }

        @Override
        public String toString() {
            return "date=" + date;
        }
    }

    private class DateBeforeQualifier implements Qualifier {
        private Date date;

        DateBeforeQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isEmpty()) {
                return false;
            }

            return task.getDeadline().getDate().before(date)
                    && !task.getStatus().isStatusComplete();
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class DateAfterQualifier implements Qualifier {
        private Date date;

        DateAfterQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            if (task.getDeadline().isEmpty()) {
                return false;
            }

            return task.getDeadline().getDate().after(date)
                    && !task.getStatus().isStatusComplete();
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class EmptyDeadlineAndTimestampQualifier implements Qualifier {
        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isEmpty() && task.getTimestamp().isEmpty() && !task.getStatus().isStatusComplete()) {
                return true;
            } else {
                return false;
            }
        }

        @Override
        public String toString() {
            return "deadline&timestamp=empty";
        }
    }

    @Override
    public UserPrefs getUserPrefs() {
        return userPrefs;
    }
}
```
###### \java\utask\ui\CommandBox.java
``` java
/*
 * CommandBox handles the UI Logic of commandTextField, which includes suggestions and last command entered.
 * */
public class CommandBox extends UiPart<Region> {

    private static final String FXML = "CommandBox.fxml";
    public static final String ERROR_TEXTFIELD_STYLE_CLASS = "command-textfield-error";
    public static final String ERROR_SUGGESTION_STYLE_CLASS = "suggestion-error";

    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private final Logic logic;

    @FXML
    private Pane rootPane;

    @FXML
    private TextField commandTextField;

    @FXML
    private Label lblSuggestion;

    private List<String> lastValidCommandList;
    private int currentPositionInLastValidCommandList = -1;

    public CommandBox(Pane parent, Logic logic) {
        super(FXML);
        this.logic = logic;

        lastValidCommandList = new ArrayList<String>();
        addEventHandlerToControls();
        addControlsToParent(parent);
        addCommandBoxBehaviour();
    }

    private void addCommandBoxBehaviour() {
        Platform.runLater(() -> {
            commandTextField.requestFocus();
        });
    }

    private void addControlsToParent(Pane parent) {
        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    //Adds eventhandler to commandTextField
    private void addEventHandlerToControls() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                handleSpecialKeyCombination(ke);
            }
        });

        commandTextField.setOnKeyReleased(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                handleKeyPressed(ke);
            }
        });
    }

    /**
     * Show full suggested command format on recognized command pattern.
     */
    private void handleKeyPressed(KeyEvent ke) {
        String input = commandTextField.getText();

        if (!input.trim().isEmpty()) {
            input = (input.toLowerCase().split(" "))[0];
            String suggestion = SuggestionHelper.getInstance().getInputSuggestionOfPreamble(input);
            lblSuggestion.setText(suggestion);
        } else {
            lblSuggestion.setText("");
        }
    }

    private void handleSpecialKeyCombination(KeyEvent ke) {
        KeyCode keyPressed = ke.getCode();

        switch (keyPressed) {
        case ENTER :
            handleCommandInputChanged();
            currentPositionInLastValidCommandList = lastValidCommandList.size() - 1;
            break;
        case ESCAPE :
            raise(new KeyboardEscapeKeyPressedEvent());
            break;
        case F1 :
            raise(new ShowHelpRequestEvent());
            break;
        case UP :
            handleArrowUpKeyPressed();
            break;
        case DOWN :
            handleArrowDownKeyPressed();
            break;
        default:
            setStyleToIndicateCommandSuccess();
            break;
        }
    }

    private void handleArrowDownKeyPressed() {
        if (currentPositionInLastValidCommandList >= 0
                && currentPositionInLastValidCommandList < lastValidCommandList.size() - 1) {

            if (currentPositionInLastValidCommandList < lastValidCommandList.size() - 1) {
                currentPositionInLastValidCommandList++;
            }

            displayLastValidCommand();
        }
    }

    private void handleArrowUpKeyPressed() {
        if (currentPositionInLastValidCommandList >= 0) {
            displayLastValidCommand();

            if (currentPositionInLastValidCommandList > 0) {
                currentPositionInLastValidCommandList--;
            }
        }
    }

    private void displayLastValidCommand() {
        commandTextField.setText(lastValidCommandList.get(currentPositionInLastValidCommandList));
        Platform.runLater(()-> {
            commandTextField.positionCaret(commandTextField.getLength());
        });
    }

    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_TEXTFIELD_STYLE_CLASS);
        lblSuggestion.getStyleClass().remove(ERROR_SUGGESTION_STYLE_CLASS);
    }

    /**
     * Sets the command box style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        commandTextField.getStyleClass().add(ERROR_TEXTFIELD_STYLE_CLASS);
        lblSuggestion.getStyleClass().add(ERROR_SUGGESTION_STYLE_CLASS);
    }

```
###### \java\utask\ui\dialogs\Dialog.java
``` java
/*
 * Dialog enables displaying of information on MainWindow as popup dialog, which can be dismissed with esc key.
 * It uses Decorator pattern and leaves the actual UI implementation of its subclass.
 *
 * E.g. TagColorDialog extends it and add a FlowPane with tags as text labels
 *      AliasDialog extends it and add a VBox with alias as text labels
 * */
public abstract class Dialog {
    private static final String DIALOG_BUTTON_TEXT = "CLOSE [ESC]";
    private static final String DIALOG_BUTTON_CSS = "-fx-text-fill: -fx-utask-accentcolor";
    private static final Logger logger = LogsCenter.getLogger(Dialog.class);
    private final JFXDialog dialog;
    protected final JFXDialogLayout contentLayout;
    private boolean isShowing = false;

    public Dialog(StackPane parent) {
        assert parent != null : "Parent cannot be null";

        dialog = new JFXDialog();
        contentLayout = new JFXDialogLayout();
        initialize(parent);
        EventsCenter.getInstance().registerHandler(this);
    }

    private void initialize(StackPane parent) {
        dialog.setDialogContainer(parent);
        dialog.setContent(contentLayout);
        dialog.setTransitionType(DialogTransition.CENTER);

        JFXButton closeButton = new JFXButton(DIALOG_BUTTON_TEXT);
        closeButton.setStyle(DIALOG_BUTTON_CSS);
        closeButton.setOnAction((event) -> {
            onClose();
        });

        contentLayout.setActions(closeButton);
    }

    protected void show() {
        logger.fine("Showing dialog window for detailed view of alias, tag colors or message.");
        isShowing = true;
        dialog.show();
    }

    private void onClose() {
        isShowing = false;
        dialog.close();
    }

    @Subscribe
    private void handleKeyboardEscapeKeyPressedEvent(KeyboardEscapeKeyPressedEvent event) {
        if (isShowing) {
            logger.info(LogsCenter.getEventHandlingLogMessage(event));
            onClose();
        }
    }
}
```
###### \java\utask\ui\FindTaskOverlay.java
``` java
/*
 * FindTaskOverlay handles the UI Logic of find tableview,
 * which includes display (rendering of data to the correct column) and sort.
 * */
public class FindTaskOverlay extends UiPart<Region> {

    private static final String ASCENDING_ORDER = "asc";
    private static final String DESCENDING_ORDER = "dsc";
    private static final Logger logger = LogsCenter.getLogger(FindTaskOverlay.class);
    private static final String FXML = "FindTaskOverlay.fxml";

    private static final int SEARCHPANE_HIDDEN_X_POS = -3000;
    private final TranslateTransition openTransitionEffect = new TranslateTransition(new Duration(350), getRoot());
    private final TranslateTransition closeTransitionEffect = new TranslateTransition(new Duration(350), getRoot());

    @FXML
    private AnchorPane rootPane;

    @FXML
    private TableView<ReadOnlyTask> searchTable;

    @FXML
    private TableColumn<ReadOnlyTask, Number> columnIndex;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnName;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnDeadline;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnComplete;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnTimestamp;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnFrequency;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnTag;

    private ObservableList<ReadOnlyTask> masterData;

    private boolean isSearchOverlayShown = false;

    private FilteredList<ReadOnlyTask> filteredData;
    private Logic logic;

    public FindTaskOverlay(Pane parent, Logic logic) {
        super(FXML);

        assert(parent != null && logic != null);
        this.logic = logic;

        masterData = logic.getFilteredTaskList();
        initialize();
        registerAsAnEventHandler(this);
        rootPane.setTranslateX(SEARCHPANE_HIDDEN_X_POS);
        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(searchTable, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void initialize() {
        //Initialize the columns.
        addCellFactoriesToColumn();

        //Wrap the ObservableList in a FilteredList (initially display all data).
        filteredData = new FilteredList<>(masterData, p -> true);

        //Wrap the FilteredList in a SortedList.
        SortedList<ReadOnlyTask> sortedData = new SortedList<>(filteredData);

        //Bind the SortedList comparator to the TableView comparator.
        sortedData.comparatorProperty().bind(searchTable.comparatorProperty());

        //Add sorted (and filtered) data to the table.
        searchTable.setItems(sortedData);
    }

    private void addCellFactoriesToColumn() {
        columnIndex.setCellValueFactory(cellData-> new ReadOnlyObjectWrapper<Number>(
                                    searchTable.getItems().indexOf(cellData.getValue()) + 1));
        columnName.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getName().fullName));
        columnComplete.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getStatus().toString()));
        columnDeadline.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getDeadline().toString()));
        columnTimestamp.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getTimestamp().toString()));
        columnFrequency.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getFrequency().value));
        columnTag.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getTags().getAllTagNames()));
        columnIndex.setSortable(false);
    }

    private void sort(String columnAlphabet, String orderBy) {
        TableColumn<ReadOnlyTask, String> column = getColumnToSortFromStringColumnAlphabet(columnAlphabet);
        SortType sortType = getSortTypeFromStringOrderBy(orderBy);
        sort(column, sortType);
    }

    private void sort(TableColumn<ReadOnlyTask, String> column, SortType sortOrder) {
        searchTable.getSortOrder().clear();
        column.setSortType(sortOrder);
        searchTable.getSortOrder().add(column);
    }

    /*
     * Gets the first alphabet letter in the TableView column which is in the FXML file
     * This prevent the use of magic numbers or constants
     * */
    private String getColumnAlphabetOfTableColumn(TableColumn<ReadOnlyTask, String> column) {
        String columnName = column.getText();
        assert !columnName.isEmpty();

        return column.getText().substring(0, 1); //Substring to get first letter
    }

    //Dynamically find TableColumn based on the first alphabet in the display FXML
    private TableColumn<ReadOnlyTask, String> getColumnToSortFromStringColumnAlphabet(String columnAlphabet) {

        if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnName))) {
            return columnName;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnComplete))) {
            return columnComplete;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnDeadline))) {
            return columnDeadline;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnTimestamp))) {
            return columnTimestamp;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnFrequency))) {
            return columnFrequency;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnTag))) {
            return columnTag;
        }

        assert false : "Incorrect Usage. Column alphabet provided should be shown in the UI";
        return null;
    }

    private SortType getSortTypeFromStringOrderBy(String orderBy) {
        SortType sortType;

        switch (orderBy) {
        case DESCENDING_ORDER :
            sortType = SortType.DESCENDING;
            break;
        case ASCENDING_ORDER :
        default:
            sortType = SortType.ASCENDING;
            break;
        }
        return sortType;
    }

    public void openIfSearchIsNotShowing() {
        if (!isSearchOverlayShown) {
            openTransitionEffect.setToX(0);
            openTransitionEffect.play();
            isSearchOverlayShown = true;
        }
    }

    public void closeIfSearchIsShowing() {
        if (isSearchOverlayShown) {
            closeTransitionEffect.setToX(SEARCHPANE_HIDDEN_X_POS);
            closeTransitionEffect.play();
            isSearchOverlayShown = false;
            logic.setIfFindOverlayShowing(false);
        }
    }

    @Subscribe
    private void handleFindRequestEvent(FindRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        openIfSearchIsNotShowing();
    }

    @Subscribe
    private void handleKeyboardEscapeKeyPressedEvent(KeyboardEscapeKeyPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        closeIfSearchIsShowing();
    }

    @Subscribe
    private void handleShowTaskOfInterestInFindTaskOverlayEvent(ShowTaskOfInterestInFindTaskOverlayEvent event) {
        assert isSearchOverlayShown : "This event should only be propagated when find overlay is showing";

        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        int index = searchTable.getItems().indexOf(event.task);
        scrollTo(index);
    }

    @Subscribe
    private void handleUpdateSortInFindTaskOverlayEvent(UpdateSortInFindTaskOverlayEvent event) {
        assert isSearchOverlayShown : "This event should only be propagated when find overlay is showing";

        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        sort(event.columnAlphabet, event.orderBy);
    }

    @Subscribe
    private void handleJumpToListInFindTaskOverlayEvent(JumpToListInFindTaskOverlayEvent event) {
        assert isSearchOverlayShown : "This event should only be propagated when find overlay is showing";
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        scrollTo(event.targetIndex);
    }

    private void scrollTo(int index) {
        searchTable.scrollTo(index);
        searchTable.getSelectionModel().select(index);
    }
}
```
###### \java\utask\ui\helper\DelayedExecution.java
``` java
/**
 *  Provides a way to delay execution of a block of code in order to prevent race conditions
 *  Inspired by: http://tomasmikula.github.io/blog/2014/06/04/timers-in-javafx-and-reactfx.html
 */
public class DelayedExecution {
    private static final int DEFAULT_WAIT_TIME = 300;
    private Timeline function;

    public DelayedExecution(EventHandler<ActionEvent> delegate) {
        this(DEFAULT_WAIT_TIME, delegate);
    }

    public DelayedExecution(int waitTimeInMilliSeconds, EventHandler<ActionEvent> delegate) {
        assert delegate != null : "Function cannot be null";
        assert waitTimeInMilliSeconds >= 0 : "Time to wait cannot be negative";

        KeyFrame keyFrame = new KeyFrame(Duration.millis(waitTimeInMilliSeconds), delegate);
        function = new Timeline(keyFrame);
    }

    public void run() {
        function.play();
    }
}
```
###### \java\utask\ui\helper\FilteredListHelper.java
``` java
/*
 * FilteredListHelper uses facade and singleton pattern
 * It provides an interface to simplify the manage of multiple underlying FliterList.
 *
 * */
public class FilteredListHelper extends ListHelper<FilteredList<ReadOnlyTask>, ReadOnlyTask> {
    private static final Logger logger = LogsCenter.getLogger(FilteredListHelper.class);
    private static final String NAMED_LIST_FIND_FILTERED_LIST = "FindFilteredList";

    private static FilteredListHelper instance = null;
    private boolean isFindOverlayShowing = false;
    private final HashMap<String, FilteredList<ReadOnlyTask>> namedList;

    private FilteredListHelper() {
        namedList = new HashMap<String, FilteredList<ReadOnlyTask>>();
        EventsCenter.getInstance().registerHandler(this);
    }

    public static FilteredListHelper getInstance() {
        if (instance == null) {
            instance = new FilteredListHelper();
        }

        return instance;
    }

    /*
     * Currently unused publicly, so use private access modifier
     * Uses Multiton pattern idea to retrieve named instance
     *
     * Named instance will not be chain processed with other lists
     * */
    private void addNamedList(String name, FilteredList<ReadOnlyTask> list) {
        assert name != "" && !name.isEmpty() : "Name provided for NamedList is invalid";
        assert list != null : "NamedList cannot be null";

        namedList.put(name, list);
    }

    public void addFindFilteredList(FilteredList<ReadOnlyTask> list) {
        addNamedList(NAMED_LIST_FIND_FILTERED_LIST, list);
    }

    private FilteredList<ReadOnlyTask> getFindFilteredList() {
        return namedList.get(NAMED_LIST_FIND_FILTERED_LIST);
    }

    //Exposes function in a name that does not reveal actual implementation
    public void refresh() {
        updateOffsetMap();
    }

    //Exposes function in a name that does not reveal actual implementation
    public FilteredList<ReadOnlyTask> getUnderlyingListByIndex(int index) {
        if (isFindOverlayShowing) {
            logger.info("FindOverlay is showing");
            return getFindFilteredList();
        }
        return getActualListFromDisplayIndex(index);
    }

    /*
     * Normalise the given to index to actual numbering in ListView
     *
     * @param index is zero-based
     *
     * */
    public int getActualIndexFromDisplayIndex(int index) {
        assert index >= 0;

        if (isFindOverlayShowing) {
            logger.info("FindOverlay is showing");
            return index; //WYSIWYG
        }

        FilteredList<ReadOnlyTask> lw = getActualListFromDisplayIndex(index);
        int actualInt = getActualIndexOfList(lw, index);

        return actualInt;
    }

    /**
     *  Returns total sizes of all ListView
     *
     *  Recalculation is necessary every time
     */
    public int getTotalSizeOfAllList() {

        assert(lists.size() > 0) :
            this.getClass() + " was used for the first time. Please add a ListView before calling this method";

        if (isFindOverlayShowing) {
            //TODO: Use Multiton
            FilteredList<ReadOnlyTask> list = getFindFilteredList();
            return list.size();
        }

        int totalSize = 0;

        for (FilteredList<ReadOnlyTask> lv : lists) {
            totalSize += lv.size();
        }

        return totalSize;
    }

    public void setIfFindOverlayShowing(boolean isShowing) {
        isFindOverlayShowing = isShowing;
    }

    public boolean isFindOverlayShowing() {
        return isFindOverlayShowing;
    }

    @Subscribe
    public void handleUTaskChangedEvent(UTaskChangedEvent e) {
        updateOffsetMap();
    }
}
```
###### \java\utask\ui\helper\ListHelper.java
``` java
/* ListHelper groups similar method used by FilterListHelper and ListViewHelper
 *
 * Due to how different the actual generic type T is in the concrete classes,
 * it necessary have a common abstraction to get item size.
 *
 * As ListView and FliterList have no common ascendant or interface.
 *
 * So, to prevent the need to cast generic types to get item size.
 * E.g.    ((FilteredList) T).size()
 *         ((ListView) T).getItems().size()
 *
 **/
public abstract class ListHelper<T extends Collection<E>, E> {

    protected final ArrayList<T> lists;
    protected final HashMap<T, Integer> offsetMap;

    protected ListHelper() {
        lists = new ArrayList<T>();
        offsetMap = new HashMap<T, Integer>();
    }

    public void addList(T list) {
        assert list != null;
        lists.add(list);
    }

    public void addList(T... list) {
        assert list != null;
        for (int i = 0; i < list.length; i++) {
            addList(list[i]);
        }
    }

    protected void addToOffsetMap(T list, int offset) {
        offsetMap.put(list, offset);
    }

    /*
     * Normalize the given to index to actual numbering in list
     *
     * @param index is zero-based
     * */
    protected int getActualIndexOfList(T list, int index) {
        int offset = offsetMap.get(list);
        return index - offset;
    }

    protected void updateOffsetMap() {
        assert lists.size() > 0 : "Incorrect usage. Add lists first before using methods";

        addToOffsetMap(lists.get(0), 0); //First list starts counting from 0

        if (lists.size() > 1) { //There's no point to refresh one list, otherwise
            int totalSize = 0;

            //Traverse and update next OffsetMap based on previous size
            for (int i = 1; i < lists.size(); i++) {
                T prevListView = lists.get(i - 1);
                T currListView = lists.get(i);

                totalSize += prevListView.size(); //Uses collection interface as to access different underlying function
                addToOffsetMap(currListView, totalSize); //Temporary cache this value for faster calculation
            }
        }
    }

    /*
     * Searches for a listview given by the index
     *
     * @param index is zero-based
     *
     * */
    public T getActualListFromDisplayIndex(int index) {
        assert index >= 0;
        int totalSize = 0;

        for (T l : lists) {
            totalSize += l.size(); //Uses collection interface as to access different underlying function

            if (index < totalSize) {
                return l;
            }
        }

        assert false : "This line is suppose to be unreachable. Display Index provided was " + index;
        return null;
    }

    //Exposed for JUnit testing to remove state.
    //Reflection can be use access this while still keeping teh access private
    public void clear() {
        lists.clear();
        offsetMap.clear();
    }
}
```
###### \java\utask\ui\helper\ListViewHelper.java
``` java
/*
 * ListViewHelper uses facade and singleton pattern
 * It coordinates multiple ListViews to ensure their index numbers are in running sequence
 * and also provides utility functions for retrieving and scrolling.
 *
 * */
public class ListViewHelper extends ListHelper<UTListView<ReadOnlyTask>, ReadOnlyTask> {
    private static ListViewHelper instance = null;
    private final Logger logger = LogsCenter.getLogger(ListViewHelper.class);

    private ListViewHelper() {
        EventsCenter.getInstance().registerHandler(this);
    }

    public static ListViewHelper getInstance() {
        if (instance == null) {
            instance = new ListViewHelper();
        }

        return instance;
    }

    public void addList(UTListView<ReadOnlyTask> lv) {
        super.addList(lv);
        addDefaultCellFactory(lv);
        setEventHandlerForSelectionChangeEvent(lv);
    }

    private void addDefaultCellFactory(ListView<ReadOnlyTask> lv) {
        final int startIndex = 0;
        lv.setCellFactory(l -> new TaskListViewCell(startIndex));
    }

    //This function may look like updateOffsetMap() in parent but it has different algorithm
    //Careful attention is needed correctly refractor this and not to break this
    public void updateListViews() {
        Platform.runLater(() -> {
            addToOffsetMap(lists.get(0), 0); //First list starts counting from 1

            if (lists.size() > 1) { //There's no point to refresh one list, otherwise
                int totalSize = 0;

                //Traverse and update next listview index based on previous size
                for (int i = 1; i < lists.size(); i++) {
                    UTListView<ReadOnlyTask> prevListView = lists.get(i - 1);
                    UTListView<ReadOnlyTask> currListView = lists.get(i);

                    totalSize += prevListView.getItems().size();

                    final int value = totalSize; //Required by Java compiler
                    currListView.setCellFactory(l -> new TaskListViewCell(value));

                    addToOffsetMap(currListView, value); //Temporary cache this value for faster calculation
                }
            }
        });
    }

    private ListView<ReadOnlyTask> getActualListViewFromReadOnlyTask(ReadOnlyTask task) {
        for (ListView<ReadOnlyTask> lv : lists) {
            if (lv.getItems().contains(task)) {
                return lv;
            }
        }

        assert false : "Incorrect usage. ReadOnlyTask does not exists in ListView";
        return null;
    }

    /*
     * Gets display index of a ReadOnlyTask
     * */
    public int getDisplayedIndexFromReadOnlyTask(ReadOnlyTask task) {
        assert task != null;
        //Ensures the correctness when updating
        //i.e. Update that move a task from today list down to future list
        //Therefore, the lists after today list may have outdated offset of size + 1
        updateOffsetMap();

        ListView<ReadOnlyTask> list = getActualListViewFromReadOnlyTask(task);

        int position = list.getItems().indexOf(task); //Current position of task in list in zero-based indexing
        int offset = offsetMap.get(list);

        return offset + position;
    }

    private void clearSelectionOfAllListViews() {
        for (ListView<ReadOnlyTask> lv : lists) {
            lv.getSelectionModel().clearSelection();
        }
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {

        assert (index >= 0);
            UTListView<ReadOnlyTask> listView = getActualListFromDisplayIndex(index);

            assert(listView != null);

            int actualIndex = getActualIndexOfList(listView, index);

            EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(listView, actualIndex));
            scrollTo(listView, actualIndex);
        });
    }

    private void scrollTo(ListView<ReadOnlyTask> listView, int actualIndex) {
        listView.scrollTo(actualIndex);
        listView.getSelectionModel().select(actualIndex);
    }

    private void setEventHandlerForSelectionChangeEvent(ListView<ReadOnlyTask> listView) {
        listView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    //oldValue null and newValue !=null limits event propagation to only actual selection
                    //This prevents TaskListPaneSelectionChangedEvent from triggering during delete, update and done,
                    //which can go into a loop
                    if (oldValue == null && newValue != null) {
                        logger.fine("Selection in listview panel changed to : '" + newValue + "'");
                        EventsCenter.getInstance().post(new TaskListPanelSelectionChangedEvent(listView, newValue));
                    }
                });
    }

    @Subscribe
    public void handleTaskListPanelSelectionChangedEvent(TaskListPanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        clearSelectionOfAllListViews();
        ListView<ReadOnlyTask> sender = event.getSender();
        sender.getSelectionModel().select(event.getNewSelection());
    }

    @Subscribe
    public void handleUTaskChangedEvent(UTaskChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        updateListViews();
    }

    @Subscribe
    public void handleShowTaskOfInterestInMainWindowEvent(ShowTaskOfInterestInMainWindowEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        int displayIndex = getDisplayedIndexFromReadOnlyTask(event.task);
        scrollTo(displayIndex);
    }
}
```
###### \java\utask\ui\helper\SuggestionHelper.java
``` java
/*
 * Provides suggestion of command.
 *
 * SuggestionMap has to be updated statically to include new commands.
 *
 * To update dynamically, reflection can be used to read classes in Command packge.
 * However, this may result in slow startup speed.
 * */
public class SuggestionHelper {
    private final Logger logger = LogsCenter.getLogger(SuggestionHelper.class);
    private final SortedMap<String, String> suggestionMap =  new TreeMap<String, String>();
    private final StringBuilder sb;

    private static SuggestionHelper instance;

    private SuggestionHelper() {
        EventsCenter.getInstance().registerHandler(this);
        sb = new StringBuilder();
        suggestionMap.put(AliasCommand.COMMAND_WORD, AliasCommand.COMMAND_WORD + " " + AliasCommand.COMMAND_FORMAT);
        suggestionMap.put(UnaliasCommand.COMMAND_WORD, UnaliasCommand.COMMAND_WORD + " "
                + UnaliasCommand.COMMAND_FORMAT);

        suggestionMap.put(CreateCommand.COMMAND_WORD, CreateCommand.COMMAND_WORD + " " + CreateCommand.COMMAND_FORMAT);
        suggestionMap.put(SelectCommand.COMMAND_WORD, SelectCommand.COMMAND_WORD + " " + SelectCommand.COMMAND_FORMAT);
        suggestionMap.put(UpdateCommand.COMMAND_WORD, UpdateCommand.COMMAND_WORD + " " + UpdateCommand.COMMAND_FORMAT);
        suggestionMap.put(DeleteCommand.COMMAND_WORD, DeleteCommand.COMMAND_WORD + " " + DeleteCommand.COMMAND_FORMAT);

        suggestionMap.put(FindCommand.COMMAND_WORD, FindCommand.COMMAND_WORD + " " + FindCommand.COMMAND_FORMAT);
        suggestionMap.put(ClearCommand.COMMAND_WORD, ClearCommand.COMMAND_WORD + " " + ClearCommand.COMMAND_FORMAT);

        suggestionMap.put(DoneCommand.COMMAND_WORD, DoneCommand.COMMAND_WORD + " " + DoneCommand.COMMAND_FORMAT);
        suggestionMap.put(UndoneCommand.COMMAND_WORD, UndoneCommand.COMMAND_WORD + " " + UndoneCommand.COMMAND_FORMAT);

        suggestionMap.put(ExitCommand.COMMAND_WORD, ExitCommand.COMMAND_WORD + " " + ExitCommand.COMMAND_FORMAT);
        suggestionMap.put(HelpCommand.COMMAND_WORD, HelpCommand.COMMAND_WORD + " " + HelpCommand.COMMAND_FORMAT);

        suggestionMap.put(ListCommand.COMMAND_WORD, ListCommand.COMMAND_WORD + " " + ListCommand.COMMAND_FORMAT);
        suggestionMap.put(ListTagCommand.COMMAND_WORD, ListTagCommand.COMMAND_WORD + " "
                + ListTagCommand.COMMAND_FORMAT);
        suggestionMap.put(ListAliasCommand.COMMAND_WORD, ListAliasCommand.COMMAND_WORD + " "
                + ListAliasCommand.COMMAND_FORMAT);

        suggestionMap.put(RelocateCommand.COMMAND_WORD, RelocateCommand.COMMAND_WORD
                          + " " + RelocateCommand.COMMAND_FORMAT);

        suggestionMap.put(RedoCommand.COMMAND_WORD, RedoCommand.COMMAND_WORD + " " + RedoCommand.COMMAND_FORMAT);
        suggestionMap.put(UndoCommand.COMMAND_WORD, UndoCommand.COMMAND_WORD + " " + UndoCommand.COMMAND_FORMAT);

        suggestionMap.put(CreateTagCommand.COMMAND_WORD, CreateTagCommand.COMMAND_WORD + " "
                + CreateTagCommand.COMMAND_FORMAT);

        suggestionMap.put(DeleteTagCommand.COMMAND_WORD, DeleteTagCommand.COMMAND_WORD + " "
                + DeleteTagCommand.COMMAND_FORMAT);
        suggestionMap.put(UpdateTagCommand.COMMAND_WORD, UpdateTagCommand.COMMAND_WORD + " "
                + UpdateTagCommand.COMMAND_FORMAT);
        suggestionMap.put(CreateTagCommand.COMMAND_WORD, CreateTagCommand.COMMAND_WORD + " "
                + CreateTagCommand.COMMAND_FORMAT);

        //Dynamic Suggested
        suggestionMap.put(SortCommand.COMMAND_WORD, SortCommand.COMMAND_WORD + " " + SortCommand.COMMAND_FORMAT);
    }

    public static SuggestionHelper getInstance() {
        if (instance == null) {
            instance = new SuggestionHelper();
        }

        return instance;
    }

    public final String getInputSuggestionOfPreamble(String preamble) {
        assert preamble != "" && preamble != null;

        Set<Entry<String, String>> results = filterPrefix(suggestionMap, preamble).entrySet();

        if (results.size() == 0) { //If don't recognize the command then show all possible commands
            return showAllSuggetions();
        } else if (results.size() == 1) {
            Entry<String, String> result = results.iterator().next();

            return result.getValue();
        } else if (suggestionMap.containsKey(preamble)) {
            //Lazy search; Give command format as soon as we have a match
            //e.g. create and createtag. Give create command format when it matches
            return suggestionMap.get(preamble);
        } else { //results.size() > 2
            sb.setLength(0); // clears stringbuilder

            for (Map.Entry<String, String> entry : results) {
                sb.append(entry.getKey() + "  ");
            }

            return sb.toString();
        }
    }

    /*
     * Adapted from http://stackoverflow.com/questions/6713239/partial-search-in-hashmap
     * */
    private static <V> SortedMap<String, V> filterPrefix(SortedMap<String, V> baseMap, String prefix) {
        if (prefix.length() > 0) {
            char nextLetter = (char) (prefix.charAt(prefix.length() - 1) + 1);
            String end = prefix.substring(0, prefix.length() - 1) + nextLetter;
            return baseMap.subMap(prefix, end);
        }
        return baseMap;
    }

    private String showAllSuggetions() {
        sb.setLength(0); // clears stringbuilder

        for (Entry<String, String> entry : suggestionMap.entrySet()) {
            String command = entry.getKey();
            sb.append(command + "  ");
        }

        return sb.toString();
    }

```
###### \java\utask\ui\helper\TagColorHelper.java
``` java
/*
 * TagColorHelper provides helpful utility helpers for its internal enum ColorType.
 *
 * To add more colors, add more constants to ColorType enum.
 * The utility methods in TagColorHelper will work with size changes.
 * */
public class TagColorHelper {

    public static int getSize() {
        return ColorType.values().length;
    }

    public static String getARandomColor() {
        ColorType color = randomEnum(ColorType.class);
        return color.toString();
    }

    public static String getColorNameFromIndex(int colorIndex) {
        return getColorTypeFromIndex(colorIndex).name();
    }

    public static String getColorValueFromIndex(int colorIndex) {
        return getColorTypeFromIndex(colorIndex).toString();
    }

    private static ColorType getColorTypeFromIndex (int colorIndex) {
        assert colorIndex >= 0 : "Color index must be equals or greater than 0";
        assert colorIndex < getSize() : "Color index out of bounds of ColorType";
        return ColorType.values()[colorIndex];
    }

    public static String getColorValueFromName (String name) {
        return getColorTypeFromName(name.toUpperCase()).toString();
    }

    public static ColorType getColorTypeFromName (String name) {
        assert name != null : "Provided color name is null";
        return ColorType.valueOf(name);
    }

    private static <T extends Enum<?>> T randomEnum(Class<T> c) {
        Random random = new Random();
        int r = random.nextInt(c.getEnumConstants().length);
        return c.getEnumConstants()[r];
    }

    public static String getListOfSupportedColor() {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < ColorType.values().length; i++) {
            sb.append(ColorType.values()[i].name() + " ");
        }

        return sb.toString();
    }

    public enum ColorType {
        BLACK("#000"),
        BLUE("#2196F3"),
        CYAN("#00BCD4"),
        GREEN("#009688"),
        ORANGE("#FF5722"),
        PINK("#F06292"),
        PURPLE("#673AB7"),
        RED("#B71C1C"),
        YELLOW("#FFA000");

        private final String text;

        private ColorType(final String text) {
            this.text = text;
        }

        @Override
        public String toString() {
            return text;
        }
    }
}
```
###### \java\utask\ui\helper\TaskListViewCell.java
``` java
/*
 * TaskListViewCell renders TaskListCard in ListViews.
 * Note it extends JFXListCell, which ensure correct material styling are applied.
 * */
public class TaskListViewCell extends JFXListCell<ReadOnlyTask> {

    private int offset;

    public TaskListViewCell(int offset) {
        updateOffset(offset);
    }

    private void updateOffset(int offset) {
        this.offset = offset + 1;
    }

    @Override
    public void updateItem(ReadOnlyTask task, boolean empty) {
        super.updateItem(task, empty);

        if (empty || task == null) {
            setGraphic(null);
            setText(null);
        } else {
            setGraphic(new TaskListCard(task, getIndex() + offset).getRoot());
        }
    }
}
```
###### \java\utask\ui\helper\UTListView.java
``` java
/**
 *  As ListHelper works with generic of Collection type, it is required to implement Collection.
 *
 *  Although, ListView has a underlying collection, we are using the helper for UI manipulation.
 *  Thus, the need to abstract different methods to prevent the need to cast generic types to get item size.
 *
 *  E.g.    ((FilteredList) T).size()
 *         ((ListView) T).getItems().size()
 *
 * This demonstrates the use of adapter pattern, where incompatible types are adapted so they can work together.
 **/
public class UTListView<T> extends JFXListView<T> implements Collection<T> {

    @Override
    public int size() {
        return getItems().size();
    }

    @Override
    public boolean isEmpty() {
        return getItems().isEmpty();
    }

    @Override
    public boolean contains(Object o) {
        return getItems().contains(o);
    }

    @Override
    public Iterator<T> iterator() {
        return getItems().iterator();
    }

    @Override
    public Object[] toArray() {
        return getItems().toArray();
    }

    @Override
    public <T> T[] toArray(T[] a) {
        return getItems().toArray(a);
    }

    @Override
    public boolean add(T e) {
        return getItems().add(e);
    }

    @Override
    public boolean remove(Object o) {
        return getItems().remove(o);
    }

    @Override
    public boolean containsAll(Collection<?> c) {
        return getItems().containsAll(c);
    }

    @Override
    public boolean addAll(Collection<? extends T> c) {
        return getItems().addAll(c);
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        return getItems().removeAll(c);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return getItems().retainAll(c);
    }

    @Override
    public void clear() {
        getItems().clear();
    }
}
```
###### \java\utask\ui\MainWindow.java
``` java
    public MainWindow(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.logic = logic;
        this.config = config;

        // Configure the UI
        setTitle(config.getAppTitle());
        setIcon(ICON);

        setWindowDefaultSize(prefs);
        setWindowMinSize();

        Scene scene = createScene();
        setStyleSheets(scene);
        primaryStage.setScene(scene);
        setEventHandlers();
        setAccelerators();


        EventsCenter.getInstance().registerHandler(this);
    }

    /*
     * Creates Scene
     * JFXDecorator is used to create 'material' styled window frame
     * */
    protected Scene createScene() {
        JFXDecorator decorator = new JFXDecorator(this.primaryStage, getRoot(), false, true, true);
        decorator.setPrefSize(MIN_WIDTH, MIN_HEIGHT);
        decorator.setCustomMaximize(true);
        Scene scene = new Scene(decorator);
        return scene;
    }

    /*
     * Sets required CSS Stylesheets to a scene
     *
     * Note that fonts CSS has to be set first
     * */
    private void setStyleSheets(Scene scene) {
        scene.getStylesheets().add(MainWindow.class.getResource("/css/jfoenix-fonts.css").toExternalForm());
        scene.getStylesheets().add(MainWindow.class.getResource("/css/jfoenix-design.css").toExternalForm());
        scene.getStylesheets().add(MainWindow.class.getResource("/css/utask.css").toExternalForm());
    }

    /**
     * Sets the accelerator of a Button
     *
     * @param keyCombination the KeyCombination value of the accelerator
     */
    private void setAccelerator(Button control, KeyCombination keyCombination) {
        control.getScene().getAccelerators().put(keyCombination, new Runnable() {
            @Override
            public void run() {
                handleHelp();
            }
        });
    }

    private void setAccelerators() {
        setAccelerator(btnHelp, KeyCombination.valueOf(F1_KEY));
    }

    private void setEventHandlers() {
        btnHelp.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                handleHelp();
            }
        });
    }

    void fillInnerParts() {
        new TaskListPanel(personListPanelPlaceholder, logic);
        todoListPanel = new TodoListPanel(todoListPanelPlaceholder, logic);
        new ResultDisplay(resultDisplayPlaceholder);
        new StatusBarFooter(statusbarPlaceholder, config.getUTaskFilePath());
        new CommandBox(commandBoxPlaceholder, logic);
        new FindTaskOverlay(topPlaceholder, logic);
    }

    public TodoListPanel getTodoListPanel() {
        return todoListPanel;
    }
```
###### \java\utask\ui\MainWindow.java
``` java
    @Subscribe
    private void handleShowTagColorDialogEvent(ShowTagColorDialogEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        new TagColorDialog(rootPane).show(event.tags);
    }

    @Subscribe
    private void handleShowAliasDialogEvent(ShowAliasDialogEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        new AliasDialog(rootPane).show(event.map);
    }
```
###### \java\utask\ui\TaskListCard.java
``` java
/*
 * TaskListCard contains information on how a Task card would appear in TodoListPanel and TaskListPanel
 * */
public class TaskListCard extends UiPart<Region> {
    public static final double CARD_HEIGHT = 102.0;
    private static final String FXML = "TaskListCard.fxml";
    private static final String LABEL_CSS = "-fx-padding: 1 3 1 3; -fx-text-fill: WHITE; -fx-background-color: %s;";
    private static final String LABEL_STRIKETHROUGH_STYLE = "label-text-done";

    // UI Element use Leszynski naming convention. Prefix is the element type
    @FXML
    private Label lblId;

    @FXML
    private CheckBox chkDone;

    @FXML
    private Label lblName;

    @FXML
    private HBox hbTagContainer;

    @FXML
    private Label lblDate;

    private final ReadOnlyTask task;

    public TaskListCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        assert (task != null && displayedIndex > 0);
        this.task = task;
        setTaskInfoToControls(task, displayedIndex);
        addStylingProperitesOnCompletion();
        EventsCenter.getInstance().registerHandler(this);
    }

    private void setTaskInfoToControls(ReadOnlyTask task, int displayedIndex) {
        lblName.setText(task.getName().fullName);
        lblId.setText(displayedIndex + " ");
        String friendlyDate = buildFriendlyDateToDisplay(task);
        lblDate.setText(friendlyDate);
        createTags(task);
    }

    private String buildFriendlyDateToDisplay(ReadOnlyTask task) {
        StringBuilder sb = new StringBuilder();

        if (!task.getFrequency().isEmpty()) {
            sb.append(task.getFrequency().value + ", ");
        }

        if (!task.getDeadline().isEmpty()) {
            sb.append(getPrettyDate(task));
        }

        if (!task.getTimestamp().isEmpty()) {
            sb.append(", " + task.getTimestamp().toString());
        }

        return sb.toString();
    }

```
###### \java\utask\ui\TaskListPanel.java
``` java
/*
 * TaskListPanel handles the UI Logic of how TaskListPanel appears.
 * It dynamically creates ListView and work with ListViewHelper to ensure they are properly synced.
 * */
public class TaskListPanel extends UiPart<Region> {
    private static final String INNER_LISTVIEW_CSS = "inner-list-view";
    private static final String EXTENDED_JFXLISTVIEW_CSS = "custom-jfx-list-view1";
    private static final String JFXLISTVIEW_CSS = "jfx-list-view";
    private static final String FXML = "TaskListPanel.fxml";
    private static final double CARD_HEIGHT = TaskListCard.CARD_HEIGHT;
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);

    @FXML
    private ScrollPane rootPane;

    @FXML
    private VBox container;

    public TaskListPanel(Pane parent, Logic logic) {
        super(FXML);

        assert (parent != null && logic != null);

        addControlsToParent(parent, logic);
        EventsCenter.getInstance().registerHandler(this);
    }

    private void addControlsToParent(Pane parent, Logic logic) {
        createLabelledListViewControl(container, logic.getDueFilteredTaskList(), "Due");
        createLabelledListViewControl(container, logic.getTodayFilteredTaskList(), "Today");
        createLabelledListViewControl(container, logic.getTomorrowFilteredTaskList(), "Tomorrow");
        createLabelledListViewControl(container, logic.getFutureFilteredTaskList(), "Future");

        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);

        ListViewHelper.getInstance().updateListViews();
    }

    private void createLabelledListViewControl(Pane parent, ObservableList<ReadOnlyTask> tasks, String labelName) {

        assert(tasks != null);

        Label label = createLabel(labelName);
        UTListView<ReadOnlyTask> listView = createListView();
        listView.setId("lst" + labelName);

        addLabelledListViewToParent(parent, label, listView);

        setConnections(listView, tasks);
        addStylingPropertiesToLabelBasedOnListViewSize(listView, label);
        addStylingPropertiesToListView(listView);
    }

    private Label createLabel(String name) {
        Label label = new Label(name);
        label.getStyleClass().add("list-label");
        return label;
    }

    private UTListView<ReadOnlyTask> createListView() {
        UTListView<ReadOnlyTask> list = new UTListView<ReadOnlyTask>();
        list.getStyleClass().add(JFXLISTVIEW_CSS);
        list.getStyleClass().add(EXTENDED_JFXLISTVIEW_CSS);
        return list;
    }

    private void addLabelledListViewToParent(Pane parent, Label label, JFXListView<ReadOnlyTask> list) {
        parent.getChildren().add(label);
        parent.getChildren().add(list);
    }

    private void addStylingPropertiesToListView(JFXListView<ReadOnlyTask> listView) {
        listView.getStyleClass().add(INNER_LISTVIEW_CSS);
        listView.minHeightProperty().bind(Bindings.size(listView.getItems()).multiply(CARD_HEIGHT));
        listView.visibleProperty().bind(Bindings.size(listView.getItems()).greaterThan(0));
        listView.managedProperty().bind(listView.visibleProperty());
    }

    /**
     * If listview has no items, it will not be visible.
     * Use managedProperty to invoke redrawing on UI
     */
    private void addStylingPropertiesToLabelBasedOnListViewSize(JFXListView<ReadOnlyTask> listView, Label label) {
        label.visibleProperty().bind(Bindings.size(listView.getItems()).greaterThan(0));
        label.managedProperty().bind(label.visibleProperty());
    }

    private void setConnections(UTListView<ReadOnlyTask> listView, ObservableList<ReadOnlyTask> tasks) {
        listView.setItems(tasks);
        ListViewHelper.getInstance().addList(listView);
    }

    /*
     * Calculates the vertical value of the scrollbar of scrollbar to display given task of listview at the top
     * */
    private void showCardInScrollPane(ScrollPane pane, Node listView, int numberOfCards) {
        Bounds viewport = pane.getViewportBounds();
        double contentHeight = pane.getContent().getBoundsInLocal().getHeight();
        double nodeMinY = listView.getBoundsInParent().getMinY();
        double cardHeight = TaskListCard.CARD_HEIGHT;

        double topOfList = (nodeMinY + (numberOfCards * cardHeight)) / (contentHeight - viewport.getHeight());
        pane.setVvalue(topOfList);
    }

    /**
     * Checks if given ListView belongs to this class. In other words, on the left side of the UI.
     *
     * It is better handled here as the parent does not need to cast to check root of this UI is scrollPane.
     *
     * @param node is the a listview
     * @param index is the position of item in listview
     */
    private void scrollTo(Node node, int index) {
        assert node != null;
        assert index >= 0;

        if (container.getChildren().contains(node)) {
            showCardInScrollPane(rootPane, node, index);
        }
    }

    @Subscribe
    public void handleToTaskListRequestEvent(JumpToTaskListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        scrollTo(event.targetNode, event.index);
    }
}

```
###### \java\utask\ui\TestUiManager.java
``` java
/*
 * As JFoenix wrap Scene with a JFXDecorator, which breaks testing.
 * TestUIManager is created so that a plain scene can be loaded for testing.
 *
 * This demonstrates the use of Strategy pattern, where subclass can supply different algorithm during runtime.
 * In this case, the algorithm is how to create a Scene
 * */
public class TestUiManager extends UiManager {

    public TestUiManager(Logic logic, Config config, UserPrefs prefs) {
        super(logic, config, prefs);
    }

    @Override
    protected MainWindow createMainWindow(Stage primaryStage) {
        return new TestWindow(primaryStage, config, prefs, logic);
    }
}
```
###### \java\utask\ui\TestWindow.java
``` java
/*
* As JFoenix wrap Scene with a JFXDecorator, which breaks testing.
* TestWindow is created so that a plain scene can be loaded for testing.
*
* This demonstrates the use of Strategy pattern, where subclass can supply different algorithm during runtime.
* In this case, the algorithm is how to create a Scene
* */
public class TestWindow extends MainWindow {

    public TestWindow(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {
        super(primaryStage, config, prefs, logic);
    }

    @Override
    protected Scene createScene() {
        Scene scene = new Scene(getRoot());
        primaryStage.setScene(scene);
        return scene;
    }
}
```
###### \java\utask\ui\TodoListPanel.java
``` java
/*
 * TodoListPanel handles the UI Logic of how TodoListPanel appears.
 * It also work with ListViewHelper to ensure the list are properly synced.
 * */
public class TodoListPanel extends UiPart<Region> {
    private static final String LISTVIEW_EXPAND_CSS = "-jfx-expanded : true;";
    private static final String EXTENDED_JFXLISTVIEW_CSS = "custom-jfx-list-view1";
    private static final String JFXLISTVIEW_CSS = "jfx-list-view";
    private static final String FXML = "TodoListPanel.fxml";

    @FXML
    private VBox rootPane;

    @FXML
    private Label lblTodo;

    @FXML
    private UTListView<ReadOnlyTask> lstTodoTasks;

    public TodoListPanel(Pane parent, Logic logic) {
        super(FXML);

        assert(parent != null && logic != null);

        setConnections(lstTodoTasks, logic.getFloatingFilteredTaskList());

        addStylingPropertiesToListView();
        addStylingPropertiesToLabel();

        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void setConnections(UTListView<ReadOnlyTask> listView, ObservableList<ReadOnlyTask> tasks) {
        listView.setItems(tasks);

        //Add listview to helper for chain counting
        ListViewHelper.getInstance().addList(listView);
    }

    private void addStylingPropertiesToListView() {
        lstTodoTasks.getStyleClass().add(JFXLISTVIEW_CSS);
        lstTodoTasks.getStyleClass().add(EXTENDED_JFXLISTVIEW_CSS);
        lstTodoTasks.setStyle(LISTVIEW_EXPAND_CSS);
    }

    private void addStylingPropertiesToLabel() {
        lblTodo.visibleProperty().bind(Bindings.size(lstTodoTasks.getItems()).greaterThan(0));
        lblTodo.managedProperty().bind(lblTodo.visibleProperty());
    }
}
```
###### \resources\css\utask.css
``` css
.root {
    -fx-font-family: "Roboto";
    -fx-utask-decoratorcolor: #0288D1;
    -fx-utask-primarycolor: #03A9F4;
    -fx-utask-accentcolor : #0097a7;
    -fx-utask-primarytextcolor : #212121;
    -fx-utask-secondarytextcolor : #757575;
    -fx-utask-listselectedcolor : #81d4fa;
    -fx-utask-error-color : #ff1744;
}
```
###### \resources\css\utask.css
``` css
/* Make sure that vertical scrollbar does not appear in inner list*/
.inner-list-view .scroll-bar:vertical .increment-arrow,
.inner-list-view .scroll-bar:vertical .decrement-arrow,
.inner-list-view .scroll-bar:vertical .increment-button,
.inner-list-view .scroll-bar:vertical .decrement-button {
    -fx-padding:0;
}

.label-text-done .text {
    -fx-strikethrough: true;
}

.command-textfield {
    -jfx-focus-color: -fx-utask-accentcolor;
    -fx-font-size: 15.0;
}

.command-textfield-error {
    -jfx-focus-color: -fx-utask-error-color;
}

.suggestion {
    -fx-text-fill: -fx-utask-accentcolor;
}

.suggestion-error {
    -fx-text-fill: -fx-utask-error-color;
}

.date {
    -fx-text-fill: -fx-utask-secondarytextcolor;
    -fx-font-size: 12.0;
}

.results-display {
    -fx-text-fill: -fx-utask-secondarytextcolor;
    -fx-font-size: 12.0;
}

.statusbar {
    -fx-text-fill: -fx-utask-secondarytextcolor;
    -fx-font-size: 12.0;
}

.split-pane {
    -fx-box-border: transparent;
}
.list-label {
    -fx-text-fill: -fx-utask-primarytextcolor;
    -fx-padding: 10 10 10 10;
    -fx-font-size: 16.0;
    -fx-pref-height: 25;
}

```
###### \resources\view\CommandBox.fxml
``` fxml
<?import com.jfoenix.controls.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>
<?import java.net.URL?>

<VBox fx:id="rootPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<JFXTextField fx:id="commandTextField" labelFloat="true"
			prefHeight="35.0" promptText="Enter your commands here..."
			styleClass="command-textfield">
			<VBox.margin>
				<Insets top="15.0" />
			</VBox.margin>
		</JFXTextField>
		<Label fx:id="lblSuggestion" minWidth="600.0" prefHeight="27.0" styleClass="suggestion">
			<padding>
				<Insets left="1.0" top="5.0"/>
			</padding>
		</Label>
	</children>
	<VBox.margin>
		<Insets bottom="5.0" left="15.0" right="15.0" top="5.0" />
	</VBox.margin>
</VBox>
```
###### \resources\view\FindTaskOverlay.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<AnchorPane fx:id="rootPane" HBox.hgrow="ALWAYS" VBox.vgrow="ALWAYS"
	xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<TableView fx:id="searchTable" prefHeight="-1.0" prefWidth="-1.0"
			tableMenuButtonVisible="false">
			<columns>
				<TableColumn fx:id="columnIndex" minWidth="50.0" maxWidth="50.0" text="#" />
				<TableColumn fx:id="columnName" minWidth="200" text="a. Name" />
				<TableColumn fx:id="columnComplete" minWidth="50" text="b. Status" />
				<TableColumn fx:id="columnDeadline" minWidth="100" text="c. By" />
				<TableColumn fx:id="columnTimestamp" minWidth="100" text="d. Time" />
				<TableColumn fx:id="columnFrequency" minWidth="100" text="e. Repeat" />
				<TableColumn fx:id="columnTag" minWidth="200" text="f. Tags" />
			</columns>
			<columnResizePolicy>
				<TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
			</columnResizePolicy>
		</TableView>
	</children>

	<padding>
		<Insets bottom="15.0" left="10.0" right="10.0" top="15.0" />
	</padding>
</AnchorPane>
```
###### \resources\view\TaskListCard.fxml
``` fxml
<?import com.jfoenix.controls.JFXCheckBox?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<HBox fx:id="cardPane" maxHeight="75.0" minHeight="75.0" minWidth="120.0" prefHeight="75.0" prefWidth="120.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <VBox HBox.hgrow="NEVER">
         <HBox.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </HBox.margin>
         <children>
            <Label fx:id="lblId" alignment="TOP_CENTER" contentDisplay="TOP" minWidth="30.0" text="999" VBox.vgrow="NEVER">
               <font>
                  <Font name="System Bold" size="16.0" />
               </font>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </Label>
            <JFXCheckBox fx:id="chkDone" alignment="TOP_CENTER" contentDisplay="CENTER" focusTraversable="false" minWidth="30.0" mnemonicParsing="false" text="" textAlignment="CENTER" VBox.vgrow="NEVER">
               <font>
                  <Font size="1.0" />
               </font>
               <VBox.margin>
                  <Insets top="5.0" />
               </VBox.margin>
            </JFXCheckBox>
         </children>
      </VBox>
      <VBox HBox.hgrow="ALWAYS">
         <children>
            <Label fx:id="lblName" alignment="TOP_CENTER" contentDisplay="TOP" focusTraversable="false" graphicTextGap="0.0" text="Lorem ipsum dolor sit amet, ipsum harum sed ea, ne posse putent nam, mei et dicit quodsi. Brute eripuit explicari." wrapText="true">
               <font>
                  <Font size="16.0" />
               </font>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </Label>
            <HBox fx:id="hbTagContainer" prefHeight="20.0">
            <!-- This snippet is useful for finding a good display size before transferring the values to java code
            <children>
                  <Label alignment="CENTER" contentDisplay="CENTER" minWidth="15.0" style="-fx-background-color: RED;" text="Important" textAlignment="CENTER" textFill="WHITE" textOverrun="CLIP">
                     <HBox.margin>
                        <Insets bottom="5.0" left="0.0" right="5.0" top="5.0" />
                     </HBox.margin>
                     <padding>
                        <Insets bottom="1.0" left="1.0" right="1.0" top="1.0" />
                     </padding>
                  </Label>
               </children>
              -->
            </HBox>
            <Label fx:id="lblDate" styleClass="date" prefHeight="20.0" text=""/>
         </children>
         <HBox.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </HBox.margin>
      </VBox>
   </children>
</HBox>
```
