# A0139996A
###### \java\utask\commons\events\ui\UIUpdateSortInFindOverlayEvent.java
``` java
package utask.commons.events.ui;

import utask.commons.events.BaseEvent;

/*
 * This event is used to notify UTListViewHelper
 *  to select last added or updated task
 * */
public class UIUpdateSortInFindOverlayEvent extends BaseEvent {

    public final String columnAlphabet;
    public final String orderBy;

    public UIUpdateSortInFindOverlayEvent(String columnAlphabet, String orderBy) {
        this.columnAlphabet = columnAlphabet;
        this.orderBy = orderBy;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\logic\commands\Command.java
``` java
    /**
     * Provides a way to notify UI to selected task of interest
     */
    protected void notifyUI(ReadOnlyTask task) {
        assert task != null : "Incorrect usage: Task should not be null";

        if (model.isFindOverlayShowing()) {
            EventsCenter.getInstance().post(new UIShowTaskOfInterestInFindOverlayEvent(task));
        } else {
            EventsCenter.getInstance().post(new UIShowTaskOfInterestInMainWindowEvent(task));
        }
    }
}
```
###### \java\utask\logic\commands\RedoCommand.java
``` java
package utask.logic.commands;

import utask.commons.core.Messages;
import utask.logic.commands.exceptions.CommandException;
import utask.logic.commands.inteface.ReversibleCommand;

public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redo undone commands. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_REDO_SUCCESS = "Redo: %1$s command";

    public final int index;

    public RedoCommand(int index) {
        this.index = index;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (index > model.getRedoCommandCount()) {
            throw new CommandException(Messages.MESSAGE_INVALID_REDO_RANGE);
        }

        ReversibleCommand redoCommand = model.getRedoCommand();

        try {
            redoCommand.redo();
            final ReversibleCommand undoCommand = redoCommand;
            model.addUndoCommand(undoCommand);
        } catch (Exception e) {
            //TODO: Is it sensible to add it back to the stack?
            //Will it work in the later in time of execution?
            model.addUndoCommand(redoCommand);
            throw new CommandException(Messages.MESSAGE_REDO_ERROR);
        }

        return new CommandResult(String.format(MESSAGE_REDO_SUCCESS, index));
    }
}
```
###### \java\utask\logic\commands\SelectCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        if (model.getTotalSizeOfLists() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        if (model.isFindOverlayShowing()) {
            EventsCenter.getInstance().post(new UIJumpToListInFindOverlayEvent(targetIndex - 1));
        } else {
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 1));
        }

        return new CommandResult(String.format(MESSAGE_SELECT_TASK_SUCCESS, targetIndex));
    }

}
```
###### \java\utask\logic\commands\SortInFindCommand.java
``` java
package utask.logic.commands;

import utask.commons.core.EventsCenter;
import utask.commons.events.ui.UIUpdateSortInFindOverlayEvent;
import utask.logic.commands.exceptions.CommandException;

/**
 * Sorts in find overlay
 */
public class SortInFindCommand extends Command {

    //TODO: Very similar with Jiahao general sort
    public static final String COMMAND_WORD = "sort";
    public static final String MESSAGE_SUCCESS = "Tasks list has been sorted";

    public static final String COMMAND_FORMAT = "COLUMN_ALPHABET [ ASC | DSC ]";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Sort tasks. "
            + "Parameters: " + COMMAND_FORMAT + "\n";

    private final String column;
    private final String orderBy;

    public SortInFindCommand(String column, String orderBy) {
        this.column = column;
        this.orderBy = orderBy;
    }

    @Override
    public CommandResult execute() throws CommandException {
        EventsCenter.getInstance().post(new UIUpdateSortInFindOverlayEvent(column, orderBy));
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\utask\logic\commands\UndoCommand.java
``` java
package utask.logic.commands;

import utask.commons.core.Messages;
import utask.logic.commands.exceptions.CommandException;
import utask.logic.commands.inteface.ReversibleCommand;

public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String COMMAND_FORMAT = "[INDEX (must be a positive integer)]";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo previous commands. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + "\n"
            +  COMMAND_WORD + " 1";

    public static final String MESSAGE_UNDO_SUCCESS = "Undo: %1$s command";

    public final int index;

    public UndoCommand(int index) {
        this.index = index;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (index > model.getUndoCommandCount()) {
            throw new CommandException(Messages.MESSAGE_INVALID_UNDO_RANGE);
        }

        ReversibleCommand undoCommand = model.getUndoCommand();

        try {
            undoCommand.undo();
            final ReversibleCommand redoCommand = undoCommand;
            model.addRedoCommand(redoCommand);
        } catch (Exception e) {
            //TODO: Is it sensible to add it back to the stack?
            //Will it work in the later in time of execution?
            model.addUndoCommand(undoCommand);
            throw new CommandException(Messages.MESSAGE_UNDO_ERROR);
        }

        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, index));
    }
}
```
###### \java\utask\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getDueFilteredTaskList() {
        return model.getDueFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getTodayFilteredTaskList() {
        return model.getTodayFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getTomorrowFilteredTaskList() {
        return model.getTomorrowFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFutureFilteredTaskList() {
        return model.getFutureFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFloatingFilteredTaskList() {
        return model.getFloatingFilteredTaskList();
    }

    //TODO: too many of this?
    @Override
    public void setIfFindOverlayShowing(boolean isShowing) {
        model.setIfFindOverlayShowing(isShowing);
    }
}
```
###### \java\utask\logic\parser\ParserUtil.java
``` java
    public static String parseColumnAlphabetOfSortInFind(String command) {
        assert command != null && !command.isEmpty();

        Matcher matcher = SORT_IN_FIND_FORMAT.matcher(command);

        String column = "";

        if (matcher.matches()) {
            column = matcher.group("columnAlphabet");
        }

        return column;
    }

    public static String parseOrderByOfSortInFind(String command) throws IllegalValueException {
        assert command != null && !command.isEmpty();

        Matcher matcher = SORT_IN_FIND_FORMAT.matcher(command);

        String orderBy = "";

        if (matcher.matches()) {
            orderBy = matcher.group("orderBy");

            //Since orderBy is optional, matcher::group may return a null ptr.
            if (orderBy == null) {
                orderBy = "";
            }
        } else {
            throw new IllegalValueException("Sort order must be ASC or DSC");
        }

        return orderBy;
    }
}
```
###### \java\utask\logic\parser\RedoCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.RedoCommand;

/**
 * Parses input arguments and creates a new UndoCommand object
 */
public class RedoCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the UndoCommand
     * and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent() && index.get() > 0) {
            return new RedoCommand(index.get());
        } else if (!index.isPresent()) {
            return new RedoCommand(1);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, RedoCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\logic\parser\SortInFindCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import utask.commons.exceptions.IllegalValueException;
import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.SortInFindCommand;

/**
 * Parses input arguments and creates a new SortInFindCommand object
 */
public class SortInFindCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SortCommandParser
     * and returns an SortInFindCommandParser object for execution.
     */
    public Command parse(String args) {
        try {
            String input = args.trim().toLowerCase();
            String column = ParserUtil.parseColumnAlphabetOfSortInFind(input);
            String orderBy = ParserUtil.parseOrderByOfSortInFind(input);

            if (!column.isEmpty()) {
                return new SortInFindCommand(column, orderBy);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(ive.getMessage()));
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, SortInFindCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\logic\parser\UndoCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.UndoCommand;

/**
 * Parses input arguments and creates a new UndoCommand object
 */
public class UndoCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the UndoCommand
     * and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent() && index.get() > 0) {
            return new UndoCommand(index.get());
        } else if (!index.isPresent()) {
            return new UndoCommand(1);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public void addUndoCommand(ReversibleCommand undoCommand) {
        undoStack.push(undoCommand);
    }

    @Override
    public ReversibleCommand getUndoCommand() {
        return undoStack.pop();
    }

    @Override
    public int getUndoCommandCount() {
        return undoStack.size();
    }

    @Override
    public void addRedoCommand(ReversibleCommand redoCommand) {
        redoStack.push(redoCommand);
    }

    @Override
    public ReversibleCommand getRedoCommand() {
        return redoStack.pop();
    }

    @Override
    public int getRedoCommandCount() {
        return redoStack.size();
    }
```
###### \java\utask\model\ModelManager.java
``` java
    /** Gets total size of tasks in underlying lists of listviews*/
    @Override
    public int getTotalSizeOfLists() {
        return UTFilteredListHelper.getInstance().getTotalSizeOfAllList();
    }

    @Override
    public void setIfFindOverlayShowing(boolean isShowing) {
        UTFilteredListHelper.getInstance().setIfFindOverlayShowing(isShowing);
    }

    @Override
    public boolean isFindOverlayShowing() {
        return UTFilteredListHelper.getInstance().isFindOverlayShowing();
    }


    //TODO: refractor
    @Override
    public List<ReadOnlyTask> getUnderlyingListByIndex(int displayIndex) {
        return UTFilteredListHelper.getInstance().getUnderlyingListByIndex(displayIndex);
    }

    @Override
    public int getActualIndexFromDisplayIndex(int displayIndex) {
        return UTFilteredListHelper.getInstance().getActualIndexFromDisplayIndex(displayIndex);
    }
    //@author

    private FilteredList<ReadOnlyTask> getTasksFliteredListByExactDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new ExactDateQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getTasksFliteredListByBeforeGivenDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new DateBeforeQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getTasksFliteredListByAfterGivenDate(Date date) {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new DateAfterQualifier(date)));
        return task;
    }

    private FilteredList<ReadOnlyTask> getFloatingTaskFliteredListByEmptyDeadlineAndTimestamp() {
        FilteredList<ReadOnlyTask> task = new FilteredList<>(this.uTask.getTaskList());
        updateFilteredList(task, new PredicateExpression(new EmptyDeadlineAndTimestampQualifier()));
        return task;
    }
```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getDueFilteredTaskList() {
        return new UnmodifiableObservableList<>(dueTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getTodayFilteredTaskList() {
        return new UnmodifiableObservableList<>(todayTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getTomorrowFilteredTaskList() {
        return new UnmodifiableObservableList<>(tomorrowTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFutureFilteredTaskList() {
        return new UnmodifiableObservableList<>(futureTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFloatingFilteredTaskList() {
        return new UnmodifiableObservableList<>(floatingTasks);
    }
```
###### \java\utask\model\ModelManager.java
``` java
    public void updateFilteredTaskListByKeywords(String keywords) {
        filteredFindTasks.setPredicate(task -> {
            // If filter text is empty, display all persons.
            if (keywords == null || keywords.isEmpty()) {
                return true;
            }

            //Set filter text as lower case, so to be case insensitive
            String lowerCaseFilter = keywords.toLowerCase();

            //TODO: Build comprehensive search
            return task.getName().fullName.toLowerCase().contains(lowerCaseFilter) ||
                   task.getTags().getAllTagNames().toLowerCase().contains(lowerCaseFilter);
        });
    }

    private void updateFilteredList(FilteredList<ReadOnlyTask> list, Expression expression) {
        list.setPredicate(expression::satisfies);
    }

```
###### \java\utask\model\ModelManager.java
``` java
    private class ExactDateQualifier implements Qualifier {
        private Date date;

        ExactDateQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            if (task.getDeadline().isEmpty()) {
                return false;
            }

            try {
                Date taskDate = task.getDeadline().getDate();

                return taskDate.getYear() == date.getYear()
                        && taskDate.getMonth() == date.getMonth()
                        && taskDate.getDate() == date.getDate()
                        && !task.getStatus().isStatusComplete();
            } catch (ParseException e) {
                assert false : "Date is in wrong format";
            }

            return false;
        }

        @Override
        public String toString() {
            return "date=" + date;
        }
    }

    private class DateBeforeQualifier implements Qualifier {
        private Date date;

        DateBeforeQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isEmpty()) {
                return false;
            }

            try {
                return task.getDeadline().getDate().before(date)
                        && !task.getStatus().isStatusComplete();
            } catch (ParseException e) {
                assert false : "Date is in wrong format";
            }
            return false;
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class DateAfterQualifier implements Qualifier {
        private Date date;

        DateAfterQualifier(Date date) {
            assert date != null;
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            if (task.getDeadline().isEmpty()) {
                return false;
            }

            try {
                return task.getDeadline().getDate().after(date)
                        && !task.getStatus().isStatusComplete();
            } catch (ParseException e) {
                assert false : "Date is in wrong format";
            }

            return false;
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class EmptyDeadlineAndTimestampQualifier implements Qualifier {
        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isEmpty() && task.getTimestamp().isEmpty() && !task.getStatus().isStatusComplete()) {
                return true;
            } else {
                return false;
            }
        }

        @Override
        public String toString() {
            return "deadline&timestamp=empty";
        }
    }

```
###### \java\utask\staging\ui\events\FindRequestEvent.java
``` java
package utask.staging.ui.events;

import utask.commons.events.BaseEvent;

public class FindRequestEvent extends BaseEvent {

    public FindRequestEvent() {
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\utask\staging\ui\events\TaskListPanelSelectionChangedEvent.java
``` java
package utask.staging.ui.events;

import javafx.scene.control.ListView;
import utask.commons.events.BaseEvent;
import utask.model.task.ReadOnlyTask;

/**
 * Represents a selection change in the Task List Panel
 */
public class TaskListPanelSelectionChangedEvent extends BaseEvent {

    private final ReadOnlyTask newSelection;
    private final ListView<ReadOnlyTask> sender;

    public TaskListPanelSelectionChangedEvent(ListView<ReadOnlyTask> sender, ReadOnlyTask newSelection) {
        this.newSelection = newSelection;
        this.sender = sender;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ListView<ReadOnlyTask> getSender() {
        return sender;
    }

    public ReadOnlyTask getNewSelection() {
        return newSelection;
    }
}
```
###### \java\utask\staging\ui\helper\SuggestionHelper.java
``` java
package utask.staging.ui.helper;

import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import utask.commons.core.EventsCenter;
import utask.commons.core.LogsCenter;
import utask.logic.commands.ClearCommand;
import utask.logic.commands.CreateCommand;
import utask.logic.commands.DeleteCommand;
import utask.logic.commands.DoneCommand;
import utask.logic.commands.ExitCommand;
import utask.logic.commands.FindCommand;
import utask.logic.commands.HelpCommand;
import utask.logic.commands.ListCommand;
import utask.logic.commands.RedoCommand;
import utask.logic.commands.RelocateCommand;
import utask.logic.commands.SelectCommand;
import utask.logic.commands.SortCommand;
import utask.logic.commands.SortInFindCommand;
import utask.logic.commands.UpdateCommand;
import utask.staging.ui.events.FindRequestEvent;
import utask.staging.ui.events.KeyboardEscapeKeyPressedEvent;

public class SuggestionHelper {

    private final Logger logger = LogsCenter.getLogger(SuggestionHelper.class);
    private final SortedMap<String, String> suggestionMap =  new TreeMap<String, String>();
    private final StringBuilder sb;

    private static SuggestionHelper instance;

    private SuggestionHelper() {
        EventsCenter.getInstance().registerHandler(this);
        sb = new StringBuilder();
        suggestionMap.put(CreateCommand.COMMAND_WORD, CreateCommand.COMMAND_WORD + " " + CreateCommand.COMMAND_FORMAT);
        suggestionMap.put(ClearCommand.COMMAND_WORD, ClearCommand.COMMAND_WORD + " " + ClearCommand.COMMAND_FORMAT);
        suggestionMap.put(FindCommand.COMMAND_WORD, FindCommand.COMMAND_WORD + " " + FindCommand.COMMAND_FORMAT);
        suggestionMap.put(DeleteCommand.COMMAND_WORD, DeleteCommand.COMMAND_WORD + " " + DeleteCommand.COMMAND_FORMAT);
        suggestionMap.put(DoneCommand.COMMAND_WORD, DoneCommand.COMMAND_WORD + " " + DoneCommand.COMMAND_FORMAT);
        suggestionMap.put(UpdateCommand.COMMAND_WORD, UpdateCommand.COMMAND_WORD + " " + UpdateCommand.COMMAND_FORMAT);
        suggestionMap.put(ExitCommand.COMMAND_WORD, ExitCommand.COMMAND_WORD + " " + ExitCommand.COMMAND_FORMAT);
        suggestionMap.put(HelpCommand.COMMAND_WORD, HelpCommand.COMMAND_WORD + " " + HelpCommand.COMMAND_FORMAT);
        suggestionMap.put(ListCommand.COMMAND_WORD, ListCommand.COMMAND_WORD + " " + ListCommand.COMMAND_FORMAT);
        suggestionMap.put(RedoCommand.COMMAND_WORD, RedoCommand.COMMAND_WORD + " " + RedoCommand.COMMAND_FORMAT);
        suggestionMap.put(RelocateCommand.COMMAND_WORD, RelocateCommand.COMMAND_WORD
                          + " " + RelocateCommand.COMMAND_FORMAT);
        suggestionMap.put(SelectCommand.COMMAND_WORD, SelectCommand.COMMAND_WORD + " " + SelectCommand.COMMAND_FORMAT);

        //Dynamic Suggested
        suggestionMap.put(SortCommand.COMMAND_WORD, SortCommand.COMMAND_WORD + " " + SortCommand.COMMAND_FORMAT);
    }

    public static SuggestionHelper getInstance() {
        if (instance == null) {
            instance = new SuggestionHelper();
        }

        return instance;
    }

    public final String getInputSuggestionOfPreamble(String preamble) {
        assert preamble != "" && preamble != null;

        Set<Entry<String, String>> results = filterPrefix(suggestionMap, preamble).entrySet();

        if (results.size() == 0) { //If don't recognize the command then show all possible commands
            return showAllSuggetions();
        } else if (results.size() == 1) {
            Entry<String, String> result = results.iterator().next();

            return result.getValue();
        } else { //results.size() > 2
            sb.setLength(0); // clears stringbuilder

            for (Map.Entry<String, String> entry : results) {
                sb.append(entry.getKey() + "  ");
            }

            return sb.toString();
        }
    }

    /*
     * Adapted from http://stackoverflow.com/questions/6713239/partial-search-in-hashmap
     * */
    private static <V> SortedMap<String, V> filterPrefix(SortedMap<String, V> baseMap, String prefix) {
        if (prefix.length() > 0) {
            char nextLetter = (char) (prefix.charAt(prefix.length() - 1) + 1);
            String end = prefix.substring(0, prefix.length() - 1) + nextLetter;
            return baseMap.subMap(prefix, end);
        }
        return baseMap;
    }

    private String showAllSuggetions() {
        sb.setLength(0); // clears stringbuilder

        for (Entry<String, String> entry : suggestionMap.entrySet()) {
            String command = entry.getKey();
            sb.append(command + "  ");
        }

        return sb.toString();
    }

    @Subscribe
    private void handleFindRequestEvent(FindRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        suggestionMap.put(SortInFindCommand.COMMAND_WORD, SortInFindCommand.COMMAND_WORD + " "
                        + SortInFindCommand.COMMAND_FORMAT);
    }

    @Subscribe
    private void handleKeyboardEscapeKeyPressedEvent(KeyboardEscapeKeyPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        suggestionMap.put(SortCommand.COMMAND_WORD, SortCommand.COMMAND_WORD + " " + SortCommand.COMMAND_FORMAT);
    }
}
```
###### \java\utask\staging\ui\helper\TagColorHelper.java
``` java
package utask.staging.ui.helper;

import java.util.Random;;

public class TagColorHelper {

    public static int getSize() {
        return ColorType.values().length;
    }

    public static String getARandomColor() {
        ColorType color = randomEnum(ColorType.class);
        return color.toString();
    }

    public static String getColorValueFromIndex (int colorIndex) {
        return getColorTypeFromIndex(colorIndex).toString();
    }

    private static ColorType getColorTypeFromIndex (int colorIndex) {
        assert colorIndex >= 0 : "Color index must be equals or greater than 0";
        assert colorIndex < getSize() : "Color index out of bounds of ColorType";
        return ColorType.values()[colorIndex];
    }

    public static String getColorValueFromName (String name) {
        return getColorTypeFromName(name.toUpperCase()).toString();
    }

    public static ColorType getColorTypeFromName (String name) {
        assert name != null : "Provided color name is null";
        return ColorType.valueOf(name);
    }

    private static <T extends Enum<?>> T randomEnum(Class<T> c) {
        Random random = new Random();
        int r = random.nextInt(c.getEnumConstants().length);
        return c.getEnumConstants()[r];
    }

    public static String getListOfSupportedColor() {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < ColorType.values().length; i++) {
            sb.append(ColorType.values()[i].name() + " ");
        }

        return sb.toString();
    }

    public enum ColorType {
        BLACK("#000"),
        BLUE("#2196F3"),
        CYAN("#00BCD4"),
        GREEN("#009688"),
        ORANGE("#FF5722"),
        PINK("#F06292"),
        PURPLE("#673AB7"),
        RED("#B71C1C"),
        YELLOW("#FFA000");

        private final String text;

        private ColorType(final String text) {
            this.text = text;
        }

        @Override
        public String toString() {
            return text;
        }
    }
}
```
###### \java\utask\staging\ui\helper\TaskListViewCell.java
``` java
package utask.staging.ui.helper;

import com.jfoenix.controls.JFXListCell;

import utask.model.task.ReadOnlyTask;
import utask.staging.ui.UTTaskListCard;

public class TaskListViewCell extends JFXListCell<ReadOnlyTask> {

    private int offset;

    public TaskListViewCell(int offset) {
        updateOffset(offset);
    }

    private void updateOffset(int offset) {
        this.offset = offset + 1;
    }

    @Override
    public void updateItem(ReadOnlyTask task, boolean empty) {
        super.updateItem(task, empty);

        if (empty || task == null) {
            setGraphic(null);
            setText(null);
        } else {
            setGraphic(new UTTaskListCard(task, getIndex() + offset).getRoot());
        }
    }
}
```
###### \java\utask\staging\ui\helper\UTFilteredListHelper.java
``` java
package utask.staging.ui.helper;

import java.util.HashMap;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.collections.transformation.FilteredList;
import utask.commons.core.EventsCenter;
import utask.commons.core.LogsCenter;
import utask.commons.events.model.UTaskChangedEvent;
import utask.model.task.ReadOnlyTask;

/*
 * UTListHelper uses facade and singleton pattern
 * It provides an interface to simplify the manage of multiple underlying FliterList.
 *
 * */
public class UTFilteredListHelper extends UTListHelper<FilteredList<ReadOnlyTask>, ReadOnlyTask> {
    private static final Logger logger = LogsCenter.getLogger(UTFilteredListHelper.class);
    private static final String NAMED_LIST_FIND_FILTERED_LIST = "FindFilteredList";

    private static UTFilteredListHelper instance = null;
    private boolean isFindOverlayShowing = false;
    private final HashMap<String, FilteredList<ReadOnlyTask>> namedList;

    private UTFilteredListHelper() {
        namedList = new HashMap<String, FilteredList<ReadOnlyTask>>();
        EventsCenter.getInstance().registerHandler(this);
    }

    public static UTFilteredListHelper getInstance() {
        if (instance == null) {
            instance = new UTFilteredListHelper();
        }

        return instance;
    }

    /*
     * Currently unused publicly, so use private access modifier
     * Uses Multiton pattern idea to retrieve named instance
     *
     * Named instance will not be chain processed with other lists
     * */
    private void addNamedList(String name, FilteredList<ReadOnlyTask> list) {
        assert name != "" && !name.isEmpty() : "Name provided for NamedList is invalid";
        assert list != null : "NamedList cannot be null";

        namedList.put(name, list);
    }

    public void addFindFilteredList(FilteredList<ReadOnlyTask> list) {
        addNamedList(NAMED_LIST_FIND_FILTERED_LIST, list);
    }

    private FilteredList<ReadOnlyTask> getFindFilteredList() {
        return namedList.get(NAMED_LIST_FIND_FILTERED_LIST);
    }

    //Exposes function in a name that does not reveal actual implementation
    public void refresh() {
        updateOffsetMap();
    }

    //Exposes function in a name that does not reveal actual implementation
    public FilteredList<ReadOnlyTask> getUnderlyingListByIndex(int index) {
        if (isFindOverlayShowing) {
            logger.info("FindOverlay is showing");
            return getFindFilteredList();
        }
        return getActualListFromDisplayIndex(index);
    }

    /*
     * Normalise the given to index to actual numbering in ListView
     *
     * @param index is zero-based
     *
     * */
    public int getActualIndexFromDisplayIndex(int index) {
        assert index >= 0;

        if (isFindOverlayShowing) {
            logger.info("FindOverlay is showing");
            return index; //WYSIWYG
        }

        FilteredList<ReadOnlyTask> lw = getActualListFromDisplayIndex(index);
        int actualInt = getActualIndexOfList(lw, index);

        return actualInt;
    }

    /**
     *  Returns total sizes of all ListView
     *
     *  Recalculation is necessary every time
     */
    public int getTotalSizeOfAllList() {

        assert(lists.size() > 0) :
            this.getClass() + " was used for the first time. Please add a ListView before calling this method";

        if (isFindOverlayShowing) {
            //TODO: Use Multiton
            FilteredList<ReadOnlyTask> list = getFindFilteredList();
            return list.size();
        }

        int totalSize = 0;

        for (FilteredList<ReadOnlyTask> lv : lists) {
            totalSize += lv.size();
        }

        return totalSize;
    }

    public void setIfFindOverlayShowing(boolean isShowing) {
        isFindOverlayShowing = isShowing;
    }

    public boolean isFindOverlayShowing() {
        return isFindOverlayShowing;
    }

    @Subscribe
    public void handleUTaskChangedEvent(UTaskChangedEvent e) {
        updateOffsetMap();
    }
}
```
###### \java\utask\staging\ui\helper\UTListHelper.java
``` java
package utask.staging.ui.helper;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;

import utask.commons.core.EventsCenter;

/* UTListHelper groups similar method used by UTFilterListHelper and UTListViewHelper
 *
 * Due to how different the actual type T is in the concrete classes,
 * it necessary have a common abstraction to get item size.
 *
 * As ListView and FliterList have no common ascendant or interface.
 *
 * So, to prevent the need to cast generic types to get item size.
 * E.g.    ((FilteredList) T).size()
 *         ((ListView) T).getItems().size()
 *
 **/
public abstract class UTListHelper<T extends Collection<E>, E> {

    protected final ArrayList<T> lists;
    protected final HashMap<T, Integer> offsetMap;

    protected UTListHelper() {
        lists = new ArrayList<T>();
        offsetMap = new HashMap<T, Integer>();
        EventsCenter.getInstance().registerHandler(this);
    }

    public void addList(T list) {
        assert list != null;
        lists.add(list);
    }

    //TODO: It is not type safe use vargs with generics
    public void addList(T... list) {
        assert list != null;
        //assert list[0].get(0) instanceof ReadOnlyTask;

        for (int i = 0; i < list.length; i++) {
            addList(list[i]);
        }
    }

    protected void addToOffsetMap(T list, int offset) {
        offsetMap.put(list, offset);
    }

    /*
     * Normalize the given to index to actual numbering in list
     *
     * @param index is zero-based
     * */
    protected int getActualIndexOfList(T list, int index) {
        int offset = offsetMap.get(list);
        return index - offset;
    }

    protected void updateOffsetMap() {
        assert lists.size() > 0 : "Incorrect usage. Add lists first before using methods";

        addToOffsetMap(lists.get(0), 0); //First list starts counting from 0

        if (lists.size() > 1) { //There's no point to refresh one list, otherwise
            int totalSize = 0;

            //Traverse and update next OffsetMap based on previous size
            for (int i = 1; i < lists.size(); i++) {
                T prevListView = lists.get(i - 1);
                T currListView = lists.get(i);

                totalSize += prevListView.size(); //Uses collection interface as to access different underlying function
                addToOffsetMap(currListView, totalSize); //Temporary cache this value for faster calculation
            }
        }
    }

    /*
     * Searches for a listview given by the index
     *
     * @param index is zero-based
     *
     * */
    public T getActualListFromDisplayIndex(int index) {
        assert index >= 0;
        int totalSize = 0;

        for (T l : lists) {
            totalSize += l.size(); //Uses collection interface as to access different underlying function

            if (index < totalSize) {
                return l;
            }
        }

        assert false : "This line is suppose to be unreachable. Display Index provided was " + index;
        return null;
    }

    //Exposed for JUnit testing to remove state
    //TODO: Use reflection to access this
    public void clear() {
        lists.clear();
        offsetMap.clear();
    }
}
```
###### \java\utask\staging\ui\helper\UTListViewHelper.java
``` java
package utask.staging.ui.helper;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.application.Platform;
import javafx.scene.control.ListView;
import utask.commons.core.EventsCenter;
import utask.commons.core.LogsCenter;
import utask.commons.events.model.UTaskChangedEvent;
import utask.commons.events.ui.JumpToTaskListRequestEvent;
import utask.commons.events.ui.UIClearListSelectionEvent;
import utask.commons.events.ui.UIShowTaskOfInterestInMainWindowEvent;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.events.TaskListPanelSelectionChangedEvent;

/*
 * UTListViewHelper uses facade and singleton pattern
 * It coordinates multiple ListViews to ensure their index numbers are in running sequence
 * and also provides utility functions for retrieving and scrolling.
 *
 * */
public class UTListViewHelper extends UTListHelper<UTListView<ReadOnlyTask>, ReadOnlyTask> {
    private static UTListViewHelper instance = null;
    private final Logger logger = LogsCenter.getLogger(UTListViewHelper.class);

    private UTListViewHelper() {
        EventsCenter.getInstance().registerHandler(this);
    }

    public static UTListViewHelper getInstance() {
        if (instance == null) {
            instance = new UTListViewHelper();
        }

        return instance;
    }

    public void addList(UTListView<ReadOnlyTask> lv) {
        super.addList(lv);
        addDefaultCellFactory(lv);
        setEventHandlerForSelectionChangeEvent(lv);
    }

    //TODO: Possible to use lazy rendering to prevent double rendering
    private void addDefaultCellFactory(ListView<ReadOnlyTask> lv) {
        final int startIndex = 0;
        lv.setCellFactory(l -> new TaskListViewCell(startIndex));
    }

    //TODO: This function may look like updateOffsetMap() in parent but it has different feature
    //      Requires effort to correctly refractor this
    public void updateListViews() {
        Platform.runLater(() -> {
            addToOffsetMap(lists.get(0), 0); //First list starts counting from 1

            if (lists.size() > 1) { //There's no point to refresh one list, otherwise
                int totalSize = 0;

                //Traverse and update next listview index based on previous size
                for (int i = 1; i < lists.size(); i++) {
                    UTListView<ReadOnlyTask> prevListView = lists.get(i - 1);
                    UTListView<ReadOnlyTask> currListView = lists.get(i);

                    totalSize += prevListView.getItems().size();

                    final int value = totalSize; //Required by Java compiler
                    currListView.setCellFactory(l -> new TaskListViewCell(value));

                    addToOffsetMap(currListView, value); //Temporary cache this value for faster calculation
                }
            }
        });
    }

    private ListView<ReadOnlyTask> getActualListViewFromReadOnlyTask(ReadOnlyTask task) {
        for (ListView<ReadOnlyTask> lv : lists) {
            if (lv.getItems().contains(task)) {
                return lv;
            }
        }

        assert false : "Incorrect usage. ReadOnlyTask does not exists in ListView";
        return null;
    }

    /*
     * Gets display index of a ReadOnlyTask
     * */
    public int getDisplayedIndexFromReadOnlyTask(ReadOnlyTask task) {
        //Ensures the correctness when updating
        //i.e. Update that move a task from today list down to future list
        //Therefore, the lists after today list may have outdated offset of size + 1
        updateOffsetMap();

        ListView<ReadOnlyTask> list = getActualListViewFromReadOnlyTask(task);

        int position = list.getItems().indexOf(task); //Current position of task in list in zero-based indexing
        int offset = offsetMap.get(list);

        return offset + position;
    }

    private void clearSelectionOfAllListViews() {
        for (ListView<ReadOnlyTask> lv : lists) {
            lv.getSelectionModel().clearSelection();
        }
    }

    //TODO: Cleanup abit confusing?
    public void scrollTo(int index) {
        Platform.runLater(() -> {

        assert (index >= 0);
            UTListView<ReadOnlyTask> listView = getActualListFromDisplayIndex(index);

            assert(listView != null);

            int actualIndex = getActualIndexOfList(listView, index);

            EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(listView, actualIndex));
            scrollTo(listView, actualIndex);
        });
    }

    private void scrollTo(ListView<ReadOnlyTask> listView, int actualIndex) {
        listView.scrollTo(actualIndex);
        listView.getSelectionModel().select(actualIndex);
    }

    private void setEventHandlerForSelectionChangeEvent(ListView<ReadOnlyTask> listView) {
        listView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    //oldValue null and newValue !=null limits event propagation to only actual selection
                    //This prevents TaskListPaneSelectionChangedEvent from triggering during delete, update and done,
                    //which can go into a loop
                    if (oldValue == null && newValue != null) {
                        logger.fine("Selection in listview panel changed to : '" + newValue + "'");
                        EventsCenter.getInstance().post(new TaskListPanelSelectionChangedEvent(listView, newValue));
                    }
                });
    }

    @Subscribe
    public void handleTaskListPanelSelectionChangedEvent(TaskListPanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        clearSelectionOfAllListViews();
        ListView<ReadOnlyTask> sender = event.getSender();
        sender.getSelectionModel().select(event.getNewSelection());
    }

    @Subscribe
    public void handleUTaskChangedEvent(UTaskChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        updateListViews();
    }

    @Subscribe
    public void handleUIShowTaskOfInterestInMainWindowEvent(UIShowTaskOfInterestInMainWindowEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        int displayIndex = getDisplayedIndexFromReadOnlyTask(event.task);
        scrollTo(displayIndex);
    }

    @Subscribe
    public void handleUIClearListSelectionEvent(UIClearListSelectionEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        clearSelectionOfAllListViews();
    }
}
```
###### \java\utask\staging\ui\UTCommandBox.java
``` java
package utask.staging.ui;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import javafx.application.Platform;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import utask.commons.core.LogsCenter;
import utask.commons.events.ui.NewResultAvailableEvent;
import utask.commons.events.ui.ShowHelpRequestEvent;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.logic.commands.CommandResult;
import utask.logic.commands.exceptions.CommandException;
import utask.staging.ui.events.KeyboardEscapeKeyPressedEvent;
import utask.staging.ui.helper.SuggestionHelper;

public class UTCommandBox extends StagingUiPart<Region> {

    private static final String FXML = "UTCommandBox.fxml";
    private static final String ERROR_TEXTFIELD_STYLE_CLASS = "command-textfield-error";
    private static final String ERROR_SUGGESTION_STYLE_CLASS = "suggestion-error";

    private final Logger logger = LogsCenter.getLogger(UTCommandBox.class);
    private final Logic logic;

    @FXML
    private Pane rootPane;

    @FXML
    private TextField commandTextField;

    @FXML
    private Label lblSuggestion;

    private List<String> lastValidCommandList;
    private int currentPositionInLastValidCommandList = -1;

    public UTCommandBox(Pane parent, Logic logic) {
        super(FXML);
        this.logic = logic;

        lastValidCommandList = new ArrayList<String>();
        addEventHandlerToControls();
        addControlsToParent(parent);
        addCommandBoxBehaviour();
    }

    private void addCommandBoxBehaviour() {
        Platform.runLater(() -> {
            commandTextField.requestFocus();
        });
    }

    private void addControlsToParent(Pane parent) {
        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void addEventHandlerToControls() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                handleSpecialKeyCombination(ke);
            }
        });

        commandTextField.setOnKeyReleased(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                handleKeyPressed(ke);
            }
        });
    }

    /**
     * Show full suggested command format on recognized command pattern.
     */
    private void handleKeyPressed(KeyEvent ke) {
        String input = commandTextField.getText();

        if (!input.trim().isEmpty()) {
            input = (input.toLowerCase().split(" "))[0];
            String suggestion = SuggestionHelper.getInstance().getInputSuggestionOfPreamble(input);
            lblSuggestion.setText(suggestion);
        } else {
            lblSuggestion.setText("");
        }
    }

    private void handleSpecialKeyCombination(KeyEvent ke) {
        KeyCode keyPressed = ke.getCode();

        switch (keyPressed) {
        case ENTER :
            handleCommandInputChanged();
            currentPositionInLastValidCommandList = lastValidCommandList.size() - 1;
            break;
        case ESCAPE :
            raise(new KeyboardEscapeKeyPressedEvent());
            break;
        case F1 :
            raise(new ShowHelpRequestEvent());
            break;
        case UP :
            if (currentPositionInLastValidCommandList >= 0) {
                displayLastValidCommand();

                if (currentPositionInLastValidCommandList > 0) {
                    currentPositionInLastValidCommandList--;
                }
            }
            break;
        case DOWN :
            if (currentPositionInLastValidCommandList >= 0
                    && currentPositionInLastValidCommandList < lastValidCommandList.size() - 1) {

                if (currentPositionInLastValidCommandList < lastValidCommandList.size() - 1) {
                    currentPositionInLastValidCommandList++;
                }

                displayLastValidCommand();
            }
            break;
        default:
            setStyleToIndicateCommandSuccess();
            break;
        }
    }

    private void displayLastValidCommand() {
        commandTextField.setText(lastValidCommandList.get(currentPositionInLastValidCommandList));
        Platform.runLater(()-> {
            commandTextField.positionCaret(commandTextField.getLength());
        });
    }

```
###### \java\utask\staging\ui\UTFindTaskOverlay.java
``` java
package utask.staging.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.animation.TranslateTransition;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import javafx.fxml.FXML;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumn.SortType;
import javafx.scene.control.TableView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.util.Duration;
import utask.commons.core.LogsCenter;
import utask.commons.events.ui.UIJumpToListInFindOverlayEvent;
import utask.commons.events.ui.UIShowTaskOfInterestInFindOverlayEvent;
import utask.commons.events.ui.UIUpdateSortInFindOverlayEvent;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.events.FindRequestEvent;
import utask.staging.ui.events.KeyboardEscapeKeyPressedEvent;

public class UTFindTaskOverlay extends StagingUiPart<Region> {

    private static final Logger logger = LogsCenter.getLogger(UTFindTaskOverlay.class);
    private static final String FXML = "UTFindTaskOverlay.fxml";

    private static final int SEARCHPANE_HIDDEN_X_POS = -3000;
    private final TranslateTransition openTransitionEffect = new TranslateTransition(new Duration(350), getRoot());
    private final TranslateTransition closeTransitionEffect = new TranslateTransition(new Duration(350), getRoot());

    @FXML
    private AnchorPane rootPane;

    @FXML
    private TableView<ReadOnlyTask> searchTable;

    @FXML
    private TableColumn<ReadOnlyTask, Number> columnIndex;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnName;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnDeadline;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnComplete;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnTimestamp;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnFrequency;

    @FXML
    private TableColumn<ReadOnlyTask, String> columnTag;

    private ObservableList<ReadOnlyTask> masterData;

    private boolean isSearchOverlayShown = false;

    private FilteredList<ReadOnlyTask> filteredData;
    private Logic logic;

    public UTFindTaskOverlay(Pane parent, Logic logic) {
        super(FXML);

        assert(parent != null && logic != null);
        this.logic = logic;

        masterData = logic.getFilteredTaskList();
        initialize();
        registerAsAnEventHandler(this);
        rootPane.setTranslateX(SEARCHPANE_HIDDEN_X_POS);
        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(searchTable, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void initialize() {
        //Initialize the columns.
        addCellFactoriesToColumn();

        //Wrap the ObservableList in a FilteredList (initially display all data).
        filteredData = new FilteredList<>(masterData, p -> true);

        //Wrap the FilteredList in a SortedList.
        SortedList<ReadOnlyTask> sortedData = new SortedList<>(filteredData);

        //Bind the SortedList comparator to the TableView comparator.
        sortedData.comparatorProperty().bind(searchTable.comparatorProperty());

        //Add sorted (and filtered) data to the table.
        searchTable.setItems(sortedData);
    }

    private void addCellFactoriesToColumn() {
        columnIndex.setCellValueFactory(cellData-> new ReadOnlyObjectWrapper<Number>(
                                    searchTable.getItems().indexOf(cellData.getValue()) + 1));
        columnName.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getName().fullName));
        columnComplete.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getStatus().toString()));
        columnDeadline.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getDeadline().value));
        columnTimestamp.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getTimestamp().value));
        columnFrequency.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getFrequency().value));
        columnTag.setCellValueFactory(t -> new ReadOnlyStringWrapper(t.getValue().getTags().getAllTagNames()));
        columnIndex.setSortable(false);
    }

    private void sort(String columnAlphabet, String orderBy) {
        TableColumn<ReadOnlyTask, String> column = getColumnToSortFromStringColumnAlphabet(columnAlphabet);
        SortType sortType = getSortTypeFromStringOrderBy(orderBy);
        sort(column, sortType);
    }

    private void sort(TableColumn<ReadOnlyTask, String> column, SortType sortOrder) {
        searchTable.getSortOrder().clear();
        column.setSortType(sortOrder);
        searchTable.getSortOrder().add(column);
    }

    /*
     * Gets the first alphabet letter in the TableView column which is in the FXML file
     * This prevent the use of magic numbers or constants
     * */
    private String getColumnAlphabetOfTableColumn(TableColumn<ReadOnlyTask, String> column) {
        String columnName = column.getText();
        assert !columnName.isEmpty();

        return column.getText().substring(0, 1);
    }

    private TableColumn<ReadOnlyTask, String> getColumnToSortFromStringColumnAlphabet(String columnAlphabet) {

        if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnName))) {
            return columnName;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnComplete))) {
            return columnComplete;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnDeadline))) {
            return columnDeadline;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnDeadline))) {
            return columnDeadline;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnTimestamp))) {
            return columnTimestamp;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnFrequency))) {
            return columnFrequency;
        } else if (columnAlphabet.equals(getColumnAlphabetOfTableColumn(columnTag))) {
            return columnTag;
        }

        assert false : "Incorrect Usage. Column alphabet provided should be shown in the UI";
        return null;
    }

    private SortType getSortTypeFromStringOrderBy(String orderBy) {
        SortType sortType;

        switch (orderBy) {
        case "dsc" :
            sortType = SortType.DESCENDING;
            break;
        case "asc" :
        default:
            sortType = SortType.ASCENDING;
            break;
        }
        return sortType;
    }

    public void openIfSearchIsNotShowing() {
        if (!isSearchOverlayShown) {
            openTransitionEffect.setToX(0);
            openTransitionEffect.play();
            isSearchOverlayShown = true;
        }
    }

    public void closeIfSearchIsShowing() {
        if (isSearchOverlayShown) {
            closeTransitionEffect.setToX(SEARCHPANE_HIDDEN_X_POS);
            closeTransitionEffect.play();
            isSearchOverlayShown = false;
            logic.setIfFindOverlayShowing(false);
        }
    }

    @Subscribe
    private void handleFindRequestEvent(FindRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        openIfSearchIsNotShowing();
    }

    @Subscribe
    private void handleKeyboardEscapeKeyPressedEvent(KeyboardEscapeKeyPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        closeIfSearchIsShowing();
    }

    @Subscribe
    private void handleUIShowTaskOfInterestInFindOverlayEvent(UIShowTaskOfInterestInFindOverlayEvent event) {
        assert isSearchOverlayShown : "This event should only be propagated when find overlay is showing";

        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        int index = searchTable.getItems().indexOf(event.task);
        scrollTo(index);
    }

    @Subscribe
    private void handleUIUpdateSortInFindOverlayEvent(UIUpdateSortInFindOverlayEvent event) {
        assert isSearchOverlayShown : "This event should only be propagated when find overlay is showing";

        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        sort(event.columnAlphabet, event.orderBy);
    }

    //TODO: Refractor
    @Subscribe
    private void handleUIJumpToListInFindOverlayEvent(UIJumpToListInFindOverlayEvent event) {
        assert isSearchOverlayShown : "This event should only be propagated when find overlay is showing";
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        scrollTo(event.targetIndex);
    }

    private void scrollTo(int index) {
        searchTable.scrollTo(index);
        searchTable.getSelectionModel().select(index);
    }
}
```
###### \java\utask\staging\ui\UTMainWindow.java
``` java
    public UTMainWindow(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.logic = logic;
        this.config = config;

        // Configure the UI
        setTitle(config.getAppTitle());
        setIcon(ICON);

        setWindowDefaultSize(prefs);
        setWindowMinSize();

        Scene scene = createScene();
        setStyleSheets(scene);
        this.primaryStage.setScene(scene);
        setEventHandlers();
        setAccelerators();

        EventsCenter.getInstance().registerHandler(this);
    }

    /*
     * Creates Scene
     * JFXDecorator is used to create 'material' styled window frame
     * */
    private Scene createScene() {
        JFXDecorator decorator = new JFXDecorator(this.primaryStage, getRoot(), false, true, true);
        decorator.setPrefSize(MIN_WIDTH, MIN_HEIGHT);
        decorator.setCustomMaximize(true);
        Scene scene = new Scene(decorator);
        return scene;
    }

    /*
     * Sets required CSS Stylesheets to a scene
     *
     * Note that fonts CSS has to be set first
     * */
    private void setStyleSheets(Scene scene) {
        scene.getStylesheets().add(UTMainWindow.class.getResource("/css/jfoenix-fonts.css").toExternalForm());
        scene.getStylesheets().add(UTMainWindow.class.getResource("/css/jfoenix-design.css").toExternalForm());
        scene.getStylesheets().add(UTMainWindow.class.getResource("/css/utask.css").toExternalForm());
    }

    /**
     * Sets the accelerator of a Button
     *
     * @param keyCombination the KeyCombination value of the accelerator
     */
    private void setAccelerator(Button control, KeyCombination keyCombination) {
        control.getScene().getAccelerators().put(keyCombination, new Runnable() {
            @Override
            public void run() {
                handleHelp();
            }
        });
    }

    private void setAccelerators() {
        setAccelerator(btnHelp, KeyCombination.valueOf("F1"));
    }

    private void setEventHandlers() {
        btnHelp.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                handleHelp();
            }
        });
    }

    void fillInnerParts() {
        new UTTaskListPanel(personListPanelPlaceholder, logic);
        todoListPanel = new UTTodoListPanel(todoListPanelPlaceholder, logic);
        new UTResultDisplay(resultDisplayPlaceholder);
        new UTStatusBarFooter(statusbarPlaceholder, config.getUTaskFilePath());
        new UTCommandBox(commandBoxPlaceholder, logic);
        new UTFindTaskOverlay(topPlaceholder, logic);

        raise(new UIShowTagColorDialogEvent(null));
    }

    public UTTodoListPanel getTodoListPanel() {
        return todoListPanel;
    }

```
###### \java\utask\staging\ui\UTTaskListPanel.java
``` java
package utask.staging.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;
import com.jfoenix.controls.JFXListView;

import javafx.beans.binding.Bindings;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.geometry.Bounds;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import utask.commons.core.EventsCenter;
import utask.commons.core.LogsCenter;
import utask.commons.events.ui.JumpToTaskListRequestEvent;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.helper.UTListView;
import utask.staging.ui.helper.UTListViewHelper;

public class UTTaskListPanel extends StagingUiPart<Region> {
    private static final String FXML = "UTTaskListPanel.fxml";
    private static final double CARD_HEIGHT = UTTaskListCard.CARD_HEIGHT;
    private final Logger logger = LogsCenter.getLogger(UTTaskListPanel.class);

    @FXML
    private ScrollPane rootPane;

    @FXML
    private VBox container;

    public UTTaskListPanel(Pane parent, Logic logic) {
        super(FXML);

        assert (parent != null && logic != null);

        addControlsToParent(parent, logic);
        EventsCenter.getInstance().registerHandler(this);
    }

    private void addControlsToParent(Pane parent, Logic logic) {
        //TODO: Use proper logic methods to populate
        createLabelledListViewControl(container, logic.getDueFilteredTaskList(), "Due");
        createLabelledListViewControl(container, logic.getTodayFilteredTaskList(), "Today");
        createLabelledListViewControl(container, logic.getTomorrowFilteredTaskList(), "Tomorrow");
        createLabelledListViewControl(container, logic.getFutureFilteredTaskList(), "Future");

        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);

        //TODO: This is not the right place to call!
        UTListViewHelper.getInstance().updateListViews();
    }

    private void createLabelledListViewControl(Pane parent, ObservableList<ReadOnlyTask> tasks, String labelName) {

        assert(tasks != null);

        Label label = createLabel(labelName);
        UTListView<ReadOnlyTask> listView = createListView();
        listView.setId("lst" + labelName);

        addLabelledListViewToParent(parent, label, listView);

        setConnections(listView, tasks);
        addStylingPropertiesToLabelBasedOnListViewSize(listView, label);
        addStylingPropertiesToListView(listView);
    }

    private Label createLabel(String name) {
        Label label = new Label(name);
        label.getStyleClass().add("list-label");
        return label;
    }

    private UTListView<ReadOnlyTask> createListView() {
        UTListView<ReadOnlyTask> list = new UTListView<ReadOnlyTask>();
        list.getStyleClass().add("jfx-list-view");
        list.getStyleClass().add("custom-jfx-list-view1");
        return list;
    }

    private void addLabelledListViewToParent(Pane parent, Label label, JFXListView<ReadOnlyTask> list) {
        parent.getChildren().add(label);
        parent.getChildren().add(list);
    }

    private void addStylingPropertiesToListView(JFXListView<ReadOnlyTask> listView) {
        listView.getStyleClass().add("inner-list-view");
        listView.minHeightProperty().bind(Bindings.size(listView.getItems()).multiply(CARD_HEIGHT));
        listView.visibleProperty().bind(Bindings.size(listView.getItems()).greaterThan(0));
        listView.managedProperty().bind(listView.visibleProperty());
    }

    /**
     * If listview has no items, it will not be visible.
     * Use managedProperty to invoke redrawing on UI
     */
    private void addStylingPropertiesToLabelBasedOnListViewSize(JFXListView<ReadOnlyTask> listView, Label label) {
        label.visibleProperty().bind(Bindings.size(listView.getItems()).greaterThan(0));
        label.managedProperty().bind(label.visibleProperty());
    }

    private void setConnections(UTListView<ReadOnlyTask> listView, ObservableList<ReadOnlyTask> tasks) {
        listView.setItems(tasks);
        UTListViewHelper.getInstance().addList(listView);
    }

    /*
     * Calculates the vertical value of the scrollbar of scrollbar to display given task of listview at the top
     * */
    private void showCardInScrollPane(ScrollPane pane, Node listView, int numberOfCards) {
        Bounds viewport = pane.getViewportBounds();
        double contentHeight = pane.getContent().getBoundsInLocal().getHeight();
        double nodeMinY = listView.getBoundsInParent().getMinY();
        double cardHeight = UTTaskListCard.CARD_HEIGHT;

        double topOfList = (nodeMinY + (numberOfCards * cardHeight)) / (contentHeight - viewport.getHeight());
        pane.setVvalue(topOfList);
    }

    /**
     * Checks if given ListView belongs to this class. In other words, on the left side of the UI.
     *
     * It is better handled here as the parent does not need to cast to check root of this UI is scrollPane.
     *
     * @param node is the a listview
     * @param index is the position of item in listview
     */
    private void scrollTo(Node node, int index) {
        assert node != null;
        assert index >= 0;

        if (container.getChildren().contains(node)) {
            showCardInScrollPane(rootPane, node, index);
        }
    }

    @Subscribe
    public void handleToTaskListRequestEvent(JumpToTaskListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        scrollTo(event.targetNode, event.index);
    }
}

```
###### \java\utask\staging\ui\UTTodoListPanel.java
``` java
package utask.staging.ui;

import javafx.beans.binding.Bindings;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import utask.commons.util.FxViewUtil;
import utask.logic.Logic;
import utask.model.task.ReadOnlyTask;
import utask.staging.ui.helper.UTListView;
import utask.staging.ui.helper.UTListViewHelper;

public class UTTodoListPanel extends StagingUiPart<Region> {
    private static final String FXML = "UTTodoListPanel.fxml";

    @FXML
    private VBox rootPane;

    @FXML
    private Label lblTodo;

    @FXML
    private UTListView<ReadOnlyTask> lstTodoTasks;

    public UTTodoListPanel(Pane parent, Logic logic) {
        super(FXML);

        assert(parent != null && logic != null);

        setConnections(lstTodoTasks, logic.getFloatingFilteredTaskList());

        addStylingPropertiesToListView();
        addStylingPropertiesToLabel();

        FxViewUtil.applyAnchorBoundaryParameters(rootPane, 0.0, 0.0, 0.0, 0.0);
        parent.getChildren().add(rootPane);
    }

    private void setConnections(UTListView<ReadOnlyTask> listView, ObservableList<ReadOnlyTask> tasks) {
        listView.setItems(tasks);

        //Add listview to helper for chain counting
        UTListViewHelper.getInstance().addList(listView);
    }

    private void addStylingPropertiesToListView() {
        lstTodoTasks.getStyleClass().add("jfx-list-view");
        lstTodoTasks.getStyleClass().add("custom-jfx-list-view1");
        lstTodoTasks.setStyle("-jfx-expanded : true;");
    }

    private void addStylingPropertiesToLabel() {
        lblTodo.visibleProperty().bind(Bindings.size(lstTodoTasks.getItems()).greaterThan(0));
        lblTodo.managedProperty().bind(lblTodo.visibleProperty());
    }
}
```
###### \resources\staging\UTCommandBox.fxml
``` fxml
<?import com.jfoenix.controls.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>
<?import java.net.URL?>

<VBox fx:id="rootPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<JFXTextField fx:id="commandTextField" labelFloat="true"
			prefHeight="35.0" promptText="Enter your commands here..."
			styleClass="command-textfield">
			<VBox.margin>
				<Insets top="15.0" />
			</VBox.margin>
		</JFXTextField>
		<Label fx:id="lblSuggestion" minWidth="600.0" prefHeight="27.0" styleClass="suggestion">
			<padding>
				<Insets left="1.0" top="5.0"/>
			</padding>
		</Label>
	</children>
	<VBox.margin>
		<Insets bottom="5.0" left="15.0" right="15.0" top="5.0" />
	</VBox.margin>
</VBox>
```
###### \resources\staging\UTFindTaskOverlay.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<AnchorPane fx:id="rootPane" HBox.hgrow="ALWAYS" VBox.vgrow="ALWAYS"
	xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<TableView fx:id="searchTable" prefHeight="-1.0" prefWidth="-1.0"
			tableMenuButtonVisible="false">
			<columns>
				<TableColumn fx:id="columnIndex" minWidth="50.0" maxWidth="50.0" text="#" />
				<TableColumn fx:id="columnName" minWidth="200" text="a. Name" />
				<TableColumn fx:id="columnComplete" minWidth="50" text="b. Done" />
				<TableColumn fx:id="columnDeadline" minWidth="100" text="c. By" />
				<TableColumn fx:id="columnTimestamp" minWidth="100" text="d. Time" />
				<TableColumn fx:id="columnFrequency" minWidth="100" text="e. Repeat" />
				<TableColumn fx:id="columnTag" minWidth="200" text="f. Tags" />
			</columns>
			<columnResizePolicy>
				<TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
			</columnResizePolicy>
		</TableView>
	</children>

	<padding>
		<Insets bottom="15.0" left="10.0" right="10.0" top="15.0" />
	</padding>
</AnchorPane>
```
###### \resources\staging\UTTaskListCard.fxml
``` fxml

<?import com.jfoenix.controls.JFXCheckBox?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<HBox maxHeight="75.0" minHeight="75.0" minWidth="120.0" prefHeight="75.0" prefWidth="120.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <VBox HBox.hgrow="NEVER">
         <HBox.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </HBox.margin>
         <children>
            <Label fx:id="lblId" alignment="TOP_CENTER" contentDisplay="TOP" minWidth="30.0" text="999" VBox.vgrow="NEVER">
               <font>
                  <Font name="System Bold" size="16.0" />
               </font>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </Label>
            <JFXCheckBox fx:id="chkDone" alignment="TOP_CENTER" contentDisplay="CENTER" focusTraversable="false" minWidth="30.0" mnemonicParsing="false" text="" textAlignment="CENTER" VBox.vgrow="NEVER">
               <font>
                  <Font size="1.0" />
               </font>
               <VBox.margin>
                  <Insets top="5.0" />
               </VBox.margin>
            </JFXCheckBox>
         </children>
      </VBox>
      <VBox HBox.hgrow="ALWAYS">
         <children>
            <Label fx:id="lblName" alignment="TOP_CENTER" contentDisplay="TOP" focusTraversable="false" graphicTextGap="0.0" text="Lorem ipsum dolor sit amet, ipsum harum sed ea, ne posse putent nam, mei et dicit quodsi. Brute eripuit explicari." wrapText="true">
               <font>
                  <Font size="16.0" />
               </font>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </Label>
            <HBox fx:id="hbTagContainer" prefHeight="20.0">
            <!--
            <children>
                  <Label alignment="CENTER" contentDisplay="CENTER" minWidth="15.0" style="-fx-background-color: RED;" text="Important" textAlignment="CENTER" textFill="WHITE" textOverrun="CLIP">
                     <HBox.margin>
                        <Insets bottom="5.0" left="0.0" right="5.0" top="5.0" />
                     </HBox.margin>
                     <padding>
                        <Insets bottom="1.0" left="1.0" right="1.0" top="1.0" />
                     </padding>
                  </Label>
               </children>
              -->
            </HBox>
            <Label fx:id="lblDate" styleClass="date" prefHeight="20.0" text=""/>
         </children>
         <HBox.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </HBox.margin>
      </VBox>
   </children>
</HBox>
```
