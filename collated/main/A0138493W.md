# A0138493W
###### \java\utask\commons\comparators\AscendingAlphabeticalComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending lexicographical order.
 */
public class AscendingAlphabeticalComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        return o1.getName().toString().compareTo(o2.getName().toString());
    }

}
```
###### \java\utask\commons\comparators\DescendingAlphabeticalComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in descending lexicographical order.
 */
public class DescendingAlphabeticalComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        return o2.getName().toString().compareTo(o1.getName().toString());
    }

}
```
###### \java\utask\commons\comparators\EarliestDeadlineComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending dates.
 */
public class EarliestDeadlineComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        int preTime = 0;
        if (!o1.getDeadline().isEmpty()) {
            preTime = (int) (o1.getDeadline().getDate().getTime() / 1000);
        }

        int nextTime = 0;
        if (!o2.getDeadline().isEmpty()) {
            nextTime = (int) (o2.getDeadline().getDate().getTime() / 1000);
        }

        return preTime - nextTime;
    }
}
```
###### \java\utask\commons\comparators\LatestDeadlineComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in descending dates.
 */
public class LatestDeadlineComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        int preTime = 0;
        if (!o1.getDeadline().isEmpty()) {
            preTime = (int) (o1.getDeadline().getDate().getTime() / 1000);
        }

        int nextTime = 0;
        if (!o2.getDeadline().isEmpty()) {
            nextTime = (int) (o2.getDeadline().getDate().getTime() / 1000);
        }

        return nextTime - preTime;
    }
}
```
###### \java\utask\commons\comparators\TagsNameComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending lexicographical Tag order.
 */
public class TagsNameComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        return o1.getTags().getFirstTagName().compareTo(o2.getTags().getFirstTagName());
    }

}
```
###### \java\utask\commons\events\ui\FileRelocateEvent.java
``` java

package utask.commons.events.ui;

import utask.commons.events.BaseEvent;

/**
 * Indicates the path when relocate data storage file
 */
public class FileRelocateEvent extends BaseEvent {

    private String path;

    public FileRelocateEvent(String path) {
        this.path = path;
    }

    public String getPath() {
        return path;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\utask\commons\util\ConfigUtil.java
``` java
    public static String getConfigPath() throws IOException {
        return Config.DEFAULT_CONFIG_FILE;
    }

}
```
###### \java\utask\logic\commands\AliasCommand.java
``` java

package utask.logic.commands;

import utask.commons.exceptions.IllegalValueException;
import utask.logic.commands.exceptions.CommandException;
import utask.model.AliasCommandMap;
import utask.model.UserPrefs;

/*
 * Create an alias for a default command
 */
public class AliasCommand extends Command {

    public static final String COMMAND_WORD = "alias";
    public static final String COMMAND_FORMAT = "ALIAS /as COMMAND";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Create an alias for a command\n"
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " d /as delete";

    public static final String MESSAGE_CREATE_ALIAS_SUCCESS = "New alias %1$s added to command %2$s";
    public static final String MESSAGE_COMMAND_WORD_NOT_EXIST = "Command %1$s is not exist";
    public static final String MESSAGE_ALIAS_CANNOT_BE_DEFAULT_COMMAND = "Alias %1$s cannot be default command";

    private final String alias;
    private final String defaultCommandWord;
    private AliasCommandMap aliasMap;

    public AliasCommand(AliasCommandMap aliasMap, String alias, String defaultCommandWord) {
        this.aliasMap = aliasMap;
        this.defaultCommandWord = defaultCommandWord;
        this.alias = alias;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (!aliasMap.getDefaultCommands().contains(defaultCommandWord)) {
            throw new CommandException(String.format(MESSAGE_COMMAND_WORD_NOT_EXIST, defaultCommandWord));
        }
        try {
            aliasMap.setAlias(alias, defaultCommandWord);
        } catch (IllegalValueException e) {
            throw new CommandException(String.format(MESSAGE_ALIAS_CANNOT_BE_DEFAULT_COMMAND, alias));
        }
        UserPrefs userPrefs = model.getUserPrefs();
        userPrefs.aliasMap = aliasMap.getAliasMap();
        return new CommandResult(String.format(MESSAGE_CREATE_ALIAS_SUCCESS, alias, defaultCommandWord));
    }

}
```
###### \java\utask\logic\commands\DeleteCommand.java
``` java
package utask.logic.commands;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import utask.commons.core.Messages;
import utask.logic.commands.exceptions.CommandException;
import utask.logic.commands.inteface.ReversibleCommand;
import utask.model.task.ReadOnlyTask;
import utask.model.task.Task;
import utask.model.task.UniqueTaskList.TaskNotFoundException;
import utask.ui.helper.DelayedExecution;

/**
 * Deletes a task identified using it's last displayed index from the uTask.
 */
public class DeleteCommand extends Command implements ReversibleCommand {

    public static final String COMMAND_WORD = "delete";
    public static final String COMMAND_FORMAT = "INDEX (must be a positive integer)";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Tasks have been deleted";

    ReadOnlyTask taskToDelete;
    List<ReadOnlyTask> deleteTasks;
    public final List<Integer> targetList;


    public DeleteCommand(List<Integer> targetList) {
        this.targetList = targetList;
        deleteTasks = new LinkedList<ReadOnlyTask>();
    }

    @Override
    public CommandResult execute() throws CommandException {

        for (int targetIndex : targetList) {
            checkIfGivenIndexIsValid(targetIndex);
            taskToDelete = getTaskToDelete(targetIndex);
            deleteTasks.add(taskToDelete);

            //Do selection effect for 1 task only. It will cause race condition when doing multiple effect in a loop
            if (targetList.size() == 1) {
                notifyUI(taskToDelete);
                new DelayedExecution((e)-> {
                    deleteTask(taskToDelete);
                }).run();
            } else {
                deleteTask(taskToDelete);
            }
        }

        model.addUndoCommand(this);

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS));
    }

    private void checkIfGivenIndexIsValid(int targetIndex) throws CommandException {
        if (model.getTotalSizeOfLists() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

    private void deleteTask(ReadOnlyTask taskToDelete) {
        try {
            model.deleteTask(taskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
    }

    private ReadOnlyTask getTaskToDelete(int targetIndex) {
        //- 1 as helper method is using zero-based indexing
        List<ReadOnlyTask> list = model.getUnderlyingListByIndex(targetIndex - 1);

        int actualInt = model.getActualIndexFromDisplayIndex(targetIndex - 1);
        return list.get(actualInt);
    }

    @Override
    public void undo() throws Exception {
        Collections.reverse(deleteTasks); //Ensures that items are restored in previous state.
        for (int i = 0; i < deleteTasks.size(); i++) {
            model.addTask((Task) deleteTasks.get(i));
        }

        notifyUI(taskToDelete);
    }

    @Override
    public void redo() throws Exception {
        notifyUI(taskToDelete);
        Collections.reverse(deleteTasks); //Ensures that items are restored in previous state.
        //Access to deleteTask() must be delayed to prevent race condition with notifyUI
        new DelayedExecution((e)-> {
            try {
                for (int i = 0; i < deleteTasks.size(); i++) {
                    model.deleteTask((Task) deleteTasks.get(i));
                }
            } catch (TaskNotFoundException pnfe) {
                //This exception is handled as it is not possible to hit this exception with normal usage
                assert false : "The target task cannot be missing";
            }
        }).run();
    }

}
```
###### \java\utask\logic\commands\FindCommand.java
``` java
package utask.logic.commands;

import java.util.Set;

import utask.commons.core.EventsCenter;
import utask.commons.core.Messages;
import utask.commons.events.ui.FindRequestEvent;

/**
 * Finds and lists all tasks in uTask who contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";
    public static final String COMMAND_FORMAT = "KEYWORD [MORE_KEYWORDS]...";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks that contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " Monday"
            + "Press [ESC] to return";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        model.setIfFindOverlayShowing(true);
        EventsCenter.getInstance().post(new FindRequestEvent());
        return new CommandResult(String.format(Messages.MESSAGE_SEARCH_RESULTS, keywords.toString(),
                                                model.getFilteredTaskList().size()));
    }

}
```
###### \java\utask\logic\commands\RelocateCommand.java
``` java

package utask.logic.commands;
import utask.commons.core.EventsCenter;
import utask.commons.events.ui.FileRelocateEvent;

/**
 * Relocate the data file by the given location from user input
 */
public class RelocateCommand extends Command {

    public static final String COMMAND_WORD = "relocate";
    public static final String COMMAND_FORMAT = "[PATH (if not specify, relocate to \\data\\utask.xml)]";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": change the save file to a new data storage location \n"
            + "Parameters: " + COMMAND_FORMAT + " \n"
            + "Example: \n"
            + "For Windows: " + COMMAND_WORD + "C:\\full\\path\\to\\destination\n"
            + "For Mac: " + COMMAND_WORD + " /Users/your_username/full/path/to/destination";

    public static final String MESSAGE_RELOCATE_TASK_SUCCESS = "The data storage file has been relocated: %1$s";
    public static final String MESSAGE_INVALID_PATH = "The path entered is invalid";

    public static String destinationPath;
    private static final String DEFAULT_FOLDER_NAME = "data";

    /**
     * Relocate Command for relocating back to default location.
     * */
    public RelocateCommand() {
        destinationPath = DEFAULT_FOLDER_NAME;
    }

    /**
     * Relocate Command for relocating back to default location.
     * */
    public RelocateCommand(String path, boolean isValidPath) {
        if (isValidPath) {
            destinationPath = path;
        } else {
            destinationPath = DEFAULT_FOLDER_NAME;
        }
    }

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new FileRelocateEvent(destinationPath));
        return new CommandResult(String.format(MESSAGE_RELOCATE_TASK_SUCCESS, destinationPath));
    }

}
```
###### \java\utask\logic\commands\SortCommand.java
``` java

package utask.logic.commands;

import utask.logic.commands.exceptions.CommandException;

/**
 * Sorts last displayed list from the uTask.
 */
public class SortCommand extends Command {

    public static final String COMMAND_WORD = "sort";
    public static final String COMMAND_FORMAT = "[SORTING_ORDER]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Sort tasks list with filters. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " earliest";

    public static final String MESSAGE_SUCCESS = "Tasks list has been sorted";

    private final String keywords;

    public SortCommand(String keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.sortFilteredTaskList(keywords);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\utask\logic\commands\UnaliasCommand.java
``` java

package utask.logic.commands;

import utask.logic.commands.exceptions.CommandException;
import utask.model.AliasCommandMap;

public class UnaliasCommand extends Command {

    public static final String COMMAND_WORD = "unalias";
    public static final String COMMAND_FORMAT = "ALIAS";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Remove an alias\n"
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " c";

    public static final String MESSAGE_UNALIAS_SUCCESS = "Alias %1$s has been removed";
    public static final String MESSAGE_ALIAS_NOT_EXIST = "Alias %1$s is not exist";

    private final String alias;
    private AliasCommandMap aliasMap;

    public UnaliasCommand(AliasCommandMap aliasMap, String alias) {
        this.aliasMap = aliasMap;
        this.alias = alias;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (aliasMap.isAliasExist(alias)) {
            aliasMap.removeAlias(alias);
        } else {
            throw new CommandException(String.format(MESSAGE_ALIAS_NOT_EXIST, alias));
        }
        return new CommandResult(String.format(MESSAGE_UNALIAS_SUCCESS, alias));
    }

}
```
###### \java\utask\logic\parser\AliasCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static utask.logic.parser.CliSyntax.PREFIX_ALIAS;

import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import utask.logic.commands.AliasCommand;
import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.model.AliasCommandMap;
/**
 * Parses input arguments and creates a new AliasCommand object
 */
public class AliasCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the AliasCommand
     * and returns an AliasCommand object for execution.
     */
    private static final String SPLITER_FOR_ALIAS = " /as";
    private static final Pattern ALIAS_REGEX = Pattern
            .compile("[\\w]+\\s/as\\s[a-z]+");

    public Command parse(AliasCommandMap aliasMap, String args) {
        final Matcher matcher = ALIAS_REGEX.matcher(args.trim());
        if (matcher.matches()) {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_ALIAS);
            argsTokenizer.tokenize(args);

            Optional<String> alias = ParserUtil.parseAlias(args.trim().split(SPLITER_FOR_ALIAS)[0]);
            if (alias.isPresent()) {
                return new AliasCommand(aliasMap, alias.get(), argsTokenizer.getValue(PREFIX_ALIAS).get());
            }
        }
        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, AliasCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\logic\parser\Parser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static utask.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.eventbus.Subscribe;

import utask.commons.core.EventsCenter;
import utask.commons.core.LogsCenter;
import utask.commons.events.ui.FindRequestEvent;
import utask.commons.events.ui.KeyboardEscapeKeyPressedEvent;
import utask.commons.exceptions.IllegalValueException;
import utask.logic.commands.AliasCommand;
import utask.logic.commands.ClearCommand;
import utask.logic.commands.Command;
import utask.logic.commands.CreateCommand;
import utask.logic.commands.CreateTagCommand;
import utask.logic.commands.DeleteCommand;
import utask.logic.commands.DeleteTagCommand;
import utask.logic.commands.DoneCommand;
import utask.logic.commands.ExitCommand;
import utask.logic.commands.FindCommand;
import utask.logic.commands.HelpCommand;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.ListAliasCommand;
import utask.logic.commands.ListCommand;
import utask.logic.commands.ListTagCommand;
import utask.logic.commands.RedoCommand;
import utask.logic.commands.RelocateCommand;
import utask.logic.commands.SelectCommand;
import utask.logic.commands.SortCommand;
import utask.logic.commands.UnaliasCommand;
import utask.logic.commands.UndoCommand;
import utask.logic.commands.UndoneCommand;
import utask.logic.commands.UpdateCommand;
import utask.logic.commands.UpdateTagCommand;
import utask.model.AliasCommandMap;
import utask.ui.helper.SuggestionHelper;

/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private final Logger logger = LogsCenter.getLogger(SuggestionHelper.class);
    private boolean showExpandedSort = false;
    private AliasCommandMap aliasMap;

    public Parser() {
        EventsCenter.getInstance().registerHandler(this);
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     * @throws IllegalValueException
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        aliasMap = AliasCommandMap.getInstance();

        if (!isDefaultCommand(commandWord)) {
            try {
                commandWord = getDefaultCommand(commandWord);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(e.getMessage());
            }
        }

        switch (commandWord) {

        case CreateCommand.COMMAND_WORD:
            return new CreateCommandParser().parse(arguments);

        case AliasCommand.COMMAND_WORD:
            return new AliasCommandParser().parse(aliasMap, arguments);

        case UnaliasCommand.COMMAND_WORD:
            return new UnaliasCommandParser().parse(aliasMap, arguments);

        case UpdateCommand.COMMAND_WORD:
            return new UpdateCommandParser().parse(arguments);

        case DoneCommand.COMMAND_WORD:
            return new DoneCommandParser().parse(arguments);

        case UndoneCommand.COMMAND_WORD:
            return new UndoneCommandParser().parse(arguments);

        case SelectCommand.COMMAND_WORD:
            return new SelectCommandParser().parse(arguments);

        case SortCommand.COMMAND_WORD:
            if (showExpandedSort) {
                return new SortInFindCommandParser().parse(arguments);
            } else {
                return new SortCommandParser().parse(arguments);
            }

        case DeleteCommand.COMMAND_WORD:
            return new DeleteCommandParser().parse(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return new FindCommandParser().parse(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ListTagCommand.COMMAND_WORD:
            return new ListTagCommand();

        case ListAliasCommand.COMMAND_WORD:
            return new ListAliasCommand();

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case UndoCommand.COMMAND_WORD:
            return new UndoCommandParser().parse(arguments);

        case RedoCommand.COMMAND_WORD:
            return new RedoCommandParser().parse(arguments);

        case RelocateCommand.COMMAND_WORD:
            return new RelocateCommandParser().parse(arguments);

        case CreateTagCommand.COMMAND_WORD:
            return new CreateTagCommandParser().parse(arguments);

        case DeleteTagCommand.COMMAND_WORD:
            return new DeleteTagCommandParser().parse(arguments);

        case UpdateTagCommand.COMMAND_WORD:
            return new UpdateTagCommandParser().parse(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }

    }

    /*
     * This method is used to detect if the command is default command
     */
    private boolean isDefaultCommand (String command) {
        return aliasMap.getDefaultCommands().contains(command);
    }

    /*
     * This method is used to get default command if the command input is alias
     */
    private String getDefaultCommand (String alias) throws IllegalValueException {
        assert alias != null && !alias.isEmpty();
        if (!aliasMap.isAliasExist(alias)) {
            throw new IllegalValueException(MESSAGE_UNKNOWN_COMMAND);
        }
        return aliasMap.getMappedCommand(alias);
    }

    @Subscribe
    private void handleFindRequestEvent(FindRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showExpandedSort = true;
    }

    @Subscribe
    private void handleKeyboardEscapeKeyPressedEvent(KeyboardEscapeKeyPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showExpandedSort = false;
    }
}
```
###### \java\utask\logic\parser\ParserUtil.java
``` java
    /**
     * Returns the indexes as a list in the {@code command} if it every index positive
     * unsigned integer Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<List<Integer>> parseMultiIndex(String command) {
        if (!isValidIndex(command.trim())) {
            return Optional.empty();
        }
        ArrayList<Integer> intIndexList = extractNumberFromInput(command);
        return Optional.of(getReversedSortedList(intIndexList));
    }

    /**
     * Returns ArrayList which contains not repeated input numbers
     */
    private static ArrayList<Integer> extractNumberFromInput(String command) {
        String[] splittedStringIndexes = command.trim().replace(" ", "").split(",");
        ArrayList<Integer> intIndexList = new ArrayList<Integer>();
        for (String index : splittedStringIndexes) {
            if (index.contains("to")) {
                String[] range = index.split("to");
                int start = Integer.parseInt(range[0]);
                int end = Integer.parseInt(range[1]);
                for (int i = start; i <= end; i++) {
                    if (!intIndexList.contains(i)) {
                        intIndexList.add(i);
                    }
                }
            } else {
                if (!intIndexList.contains(Integer.parseInt(index))) {
                    intIndexList.add(Integer.parseInt(index));
                }
            }
        }
        return intIndexList;
    }

    /**
     * Returns a sorted reversed ArrayList
     */
    private static ArrayList<Integer> getReversedSortedList(ArrayList<Integer> intIndexList) {
        Collections.sort(intIndexList);
        Collections.reverse(intIndexList);
        return intIndexList;
    }

    /**
     * Returns true if a given string is a valid input string.
     */
    private static boolean isValidIndex(String command) {
        assert command != null;
        final Matcher matcher = MULTI_INDEX_ARGS_FORMAT.matcher(command.trim());
        return matcher.matches();
    }

    /**
     * Returns true if a given string is a valid path.
     */
    public static boolean isPathValid(String command) {
        assert command != null;
        String os = System.getProperty("os.name");
        Matcher pathathMatcher = null;
        if (os.contains("Windows")) {
            pathathMatcher = WIN_PATH_FORMAT.matcher(command.trim());
        } else {
            pathathMatcher = MAC_PATH_FORMAT.matcher(command.trim());
        }
        return pathathMatcher.matches();
    }

    /**
     * Parse alias if it is a valid alias
     */
    public static Optional<String> parseAlias(String alias) {
        assert alias != null;
        final Matcher matcher = ALIAS_ARGS_FORMAT.matcher(alias.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        return Optional.of(alias);
    }
    //author

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty, or if the
     * list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

```
###### \java\utask\logic\parser\RelocateCommandParser.java
``` java

package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.RelocateCommand;

public class RelocateCommandParser {

    public Command parse(String args) {
        boolean isValidPath = ParserUtil.isPathValid(args);

        //default path
        if (args.equals("")) {
            return new RelocateCommand();
        }

        if (isValidPath) {
            return new RelocateCommand(args.trim(), true);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, RelocateCommand.MESSAGE_USAGE));
    }

}
```
###### \java\utask\logic\parser\SortCommandParser.java
``` java

package utask.logic.parser;

import utask.logic.commands.Command;
import utask.logic.commands.SortCommand;

/**
 * Parses input arguments and creates a new SortCommandParser object
 */
public class SortCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SortCommandParser
     * and returns an SortCommandParser object for execution.
     */
    public Command parse(String args) {
        //remove whitespace
        final String keyword =  args.replaceAll("\\s+", "");
        return new SortCommand(keyword);
    }

}
```
###### \java\utask\logic\parser\UnaliasCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.UnaliasCommand;
import utask.model.AliasCommandMap;

/**
 * Parses input arguments and creates a new UnaliasCommand object
 */
public class UnaliasCommandParser {
    private static final Pattern UNALIAS_REGEX = Pattern.compile("[\\w]+");

    public Command parse(AliasCommandMap aliasMap, String args) {
        final Matcher matcher = UNALIAS_REGEX.matcher(args.trim());
        if (matcher.matches()) {
            System.out.println(args.trim());
            return new UnaliasCommand(aliasMap, args.trim());
        }
        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnaliasCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\MainApp.java
``` java
    @Subscribe
    private void handleFileRelocateEvent(FileRelocateEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        String prePath = config.getUTaskFilePath();
        //Update config file and storage the changed file location
        config.setUTaskFilePath(event.getPath() + DEFAULT_FILE_NAME);
        storage.setFilePath(event.getPath() + DEFAULT_FILE_NAME);
        try {
            ConfigUtil.saveConfig(config, ConfigUtil.getConfigPath());
            storage.moveSaveFile(prePath, event.getPath() + DEFAULT_FILE_NAME);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
    }
```
###### \java\utask\model\AliasCommandMap.java
``` java

package utask.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import utask.commons.exceptions.IllegalValueException;
import utask.ui.helper.SuggestionHelper;

/*
 * Stores a HashMap of alias maps command
 */
public class AliasCommandMap {
    private HashMap<String, String> aliasesToCommand;
    private final ArrayList<String> defaultCommands;
    private static AliasCommandMap instance;

    private AliasCommandMap () {
        defaultCommands = (ArrayList<String>) SuggestionHelper.getInstance().getDefaultCommands();
        aliasesToCommand = new HashMap<String, String>();
    }

    public static AliasCommandMap getInstance() {
        if (instance == null) {
            instance = new AliasCommandMap();
        }
        return instance;
    }

    public void setAliasCommandMap(HashMap<String, String> aliasesToCommand) {
        this.aliasesToCommand = aliasesToCommand;
    }

    /**
     * set a alias for a default command
     * @throws IllegalValueException
     */
    public void setAlias(String alias, String command) throws IllegalValueException {
        assert alias != null && !alias.isEmpty();
        assert aliasesToCommand != null;
        if (defaultCommands.contains(alias)) {
            throw new IllegalValueException("Alias cannot be a default command");
        }
        if (!defaultCommands.contains(command)) {
            throw new IllegalValueException("Command is not recognized");
        }
        aliasesToCommand.put(alias, command);
    }

    public List<String> getDefaultCommands() {
        return defaultCommands;
    }

    public boolean isAliasExist(String alias) {
        assert aliasesToCommand != null;
        return aliasesToCommand.containsKey(alias);
    }

    public String getMappedCommand(String alias) {
        assert aliasesToCommand != null;
        return aliasesToCommand.get(alias);
    }

    public void removeAlias(String alias) {
        assert alias != null && !alias.isEmpty();
        assert aliasesToCommand != null;
        assert aliasesToCommand.containsKey(alias);
        aliasesToCommand.remove(alias);
    }

    public HashMap<String, String> getAliasMap() {
        assert aliasesToCommand != null;
        return aliasesToCommand;
    }
}
```
###### \java\utask\model\Model.java
``` java
    public static final String SORT_ORDER_BY_EARLIEST_FIRST = "earliest";
    public static final String SORT_ORDER_BY_LATEST_FIRST = "latest";
    public static final String SORT_ORDER_BY_A_TO_Z = "az";
    public static final String SORT_ORDER_BY_Z_TO_A = "za";
    public static final String SORT_ORDER_BY_TAG = "tag";
    public static final String SORT_ORDER_DEFAULT = SORT_ORDER_BY_EARLIEST_FIRST;
    public static final String SORT_ORDER_ERROR = "Unable to sort due to unrecognized sorting order ";

    /** Clears existing backing model and replaces with the provided new data. */
    void resetData(ReadOnlyUTask newData);

    /** Returns the UTask */
    ReadOnlyUTask getUTask();

    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;

    /** Adds the given task */
    void addTask(Task task) throws UniqueTaskList.DuplicateTaskException;

```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public void sortFilteredTaskList(String sortingOrder) {
        assert sortingOrder != null;
        switch(sortingOrder) {
        case "": //default sorting order
            uTask.sortByComparator(new EarliestDeadlineComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_EARLIEST_FIRST:
            uTask.sortByComparator(new EarliestDeadlineComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_LATEST_FIRST:
            uTask.sortByComparator(new LatestDeadlineComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_A_TO_Z:
            uTask.sortByComparator(new AscendingAlphabeticalComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_Z_TO_A:
            uTask.sortByComparator(new DescendingAlphabeticalComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_TAG:
            uTask.sortByComparator(new TagsNameComparator());
            setSortingConfig(sortingOrder);
            break;

        default:
            logger.warning(Model.SORT_ORDER_ERROR + sortingOrder);
            break;
        }
        indicateUTaskChanged();
    }

    /*
     * This method is used to set user sorting configuration
     */
    private void setSortingConfig(String userConfig) {
        assert userConfig != null;
        logger.fine("The sorting order is set as " + userConfig);
        this.sortingConfig = userConfig;
    }
```
###### \java\utask\model\ModelManager.java
``` java
    private class FindQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        FindQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword)
                            || StringUtil.containsWordIgnoreCase(task.getDeadline().toString(), keyword)
                            || StringUtil.containsWordIgnoreCase(task.getTimestamp().toString(), keyword)
                            || StringUtil.containsWordIgnoreCase(task.getFrequency().value, keyword)
                            || StringUtil.containsWordIgnoreCase(task.getStatus().toString(), keyword)
                            || StringUtil.containsWordIgnoreCase(task.getTags().getAllTagNames(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### \java\utask\model\task\Deadline.java
``` java
    /**
     * Returns deadline as date.
     *
     * @return date
     * @throws ParseException
     */
    public Date getDate() {
        assert date != null;

//        DateFormat fmt = new SimpleDateFormat("ddMMyyyy");
//        StringBuilder dateString = new StringBuilder(value);
//        dateString.insert(4, "20");
//        Date date = fmt.parse(dateString.toString());
        return date;
    }

```
###### \java\utask\model\UTask.java
``` java
    /**
     * Sort task by comparator
     */
    public void sortByComparator(Comparator<ReadOnlyTask> comparator) {
        assert comparator != null;
        FXCollections.sort(tasks.getInternalList(), comparator);
    }

```
###### \java\utask\model\util\SampleDataUtil.java
``` java

package utask.model.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Random;

import utask.model.ReadOnlyUTask;
import utask.model.UTask;
import utask.model.tag.Tag;
import utask.model.tag.TagColorIndex;
import utask.model.tag.TagName;
import utask.model.tag.UniqueTagList;
import utask.model.task.Deadline;
import utask.model.task.DeadlineTask;
import utask.model.task.EventTask;
import utask.model.task.FloatingTask;
import utask.model.task.Frequency;
import utask.model.task.Name;
import utask.model.task.Status;
import utask.model.task.Task;
import utask.model.task.Timestamp;
import utask.model.task.UniqueTaskList.DuplicateTaskException;

/**
 * This class is used to auto generate some sample data when data file is not exist
 * so far for demo and testing purpose, will generate 60 tasks in total
 */
public class SampleDataUtil {
    private static final String[] DAY_OF_WEEK = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    private static List<Task> sampleList = new ArrayList<Task>();

    /*
     * Return a List of Tasks generated by task generator
     */
    public static List<Task> getSampleTasks() {
        generateSampleTasks();
        return sampleList;
    }

    /*
     * Return sample UTask
     */
    public static ReadOnlyUTask getSampleUTask() {
        try {
            UTask sampleAB = new UTask();
            List<Task> sampleTaskList = getSampleTasks();
            for (Task sampleTask : sampleTaskList) {
                sampleAB.addTask(sampleTask);
            }
            return sampleAB;
        } catch (DuplicateTaskException e) {
            throw new AssertionError("sample data cannot contain duplicate persons", e);
        }
    }

    /*
     * This method is used to generate three different types of tasks
     */
    private static void generateSampleTasks() {
        for (int i = 1; i <= 20; i++) {
            try {
                sampleList.add(generateEventTaskWithSeed(i));
                sampleList.add(generateDeadlineTaskWithSeed(i));
                sampleList.add(generateFloatingTaskWithSeed(i));
            } catch (Exception e) {
                assert false : "sample data cannot be invalid";
            }
        }
    }

    /*
     * This method is used to generate sample Event task
     */
    public static Task generateEventTaskWithSeed(int seed) throws Exception {

        String deadline = (generateDeadline(seed));

        return new EventTask(new Name("Event Task " + seed),
                new Deadline(deadline), new Timestamp(deadline, "0000 to 2359"),
                new Frequency("Every " + randomFrequency()),
                new UniqueTagList(new Tag(
                        new TagName("tag" + Math.abs(seed)),
                        new TagColorIndex("2")),
                        new Tag(new TagName("tag" + Math.abs(seed + 1)),
                        new TagColorIndex("8"))),
                new Status("Incomplete"));
    }

    /*
     * This method is used to generate sample Deadline task
     */
    public static Task generateDeadlineTaskWithSeed(int seed) throws Exception {
        return new DeadlineTask(new Name("Deadline Task " + seed),
                new Deadline(generateDeadline(seed)),
                new Frequency("Every " + randomFrequency()),
                new UniqueTagList(new Tag(
                        new TagName("tag" + Math.abs(seed)),
                        new TagColorIndex("2")),
                        new Tag(new TagName("tag" + Math.abs(seed + 1)),
                        new TagColorIndex("8"))),
                new Status("Incomplete"));
    }

    /*
     * This method is used to generate sample Floating task
     */
    public static Task generateFloatingTaskWithSeed(int seed) throws Exception {
        return new FloatingTask(new Name("Floating Task " + seed),
                new Frequency("Every " + randomFrequency()),
                new UniqueTagList(new Tag(
                        new TagName("tag" + Math.abs(seed)),
                        new TagColorIndex("2")),
                        new Tag(new TagName("tag" + Math.abs(seed + 1)),
                        new TagColorIndex("8"))),
                new Status("Incomplete"));
    }

    /*
     * This method is used to generate different deadlines
     */
    private static String generateDeadline(int i) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(new Date());
        calendar.add(Calendar.DATE, (-10 + i));
        DateFormat fmt = new SimpleDateFormat("ddMMyy");
        return fmt.format(calendar.getTime());
    }

    /*
     * This method is used to random a number for different frequency
     * make the sample data more realistic
     */
    private static String randomFrequency() {
        Random randomGenerator = new Random();
        return DAY_OF_WEEK[randomGenerator.nextInt(6)];
    }
}
```
###### \java\utask\storage\StorageManager.java
``` java
    /*
     * This method is used to move the data file from old path to new path which is entered by relocate command
     * Exception will be thrown if cannot move the file
     */
    @Override
    public void moveSaveFile(String prePath, String newPath) {
        assert prePath != null;
        assert newPath != null;
        try {
            File oldFile = new File(prePath);
            if (oldFile.exists() && !oldFile.isDirectory()) {
                File newFile = new File(newPath);
                newFile.getParentFile().mkdirs();
                Files.move(oldFile.toPath(), newFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
                logger.fine("The file has been moved to new location: " + newPath);
            }
        } catch (IOException e) {
            logger.info("Failed to move the data file: " + StringUtil.getDetails(e));
        }
    }

```
###### \java\utask\ui\dialogs\AliasDialog.java
``` java
public class AliasDialog extends Dialog {
    private static final String ALIAS_LABEL_FORMAT = "%s >> %s";
    private static final String HAS_ALIAS_HEADING = "Alias";
    private static final String NO_ALIAS_MESSAGE = "Try adding some alias first!";
    private static final String NO_ALIAS_HEADING = ":( NO ALIAS";

    public AliasDialog(StackPane parent) {
        super(parent);
    }

    private void initialize(Map<String, String> alias) {
        List<Node> displayNodes = new ArrayList<Node>();

        Iterator<Entry<String, String>> it = alias.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, String> pair = (Map.Entry<String, String>) it.next();
            String aliasText = pair.getKey();
            String commandText = pair.getValue();
            displayNodes.add(createLabel(aliasText, commandText));
            it.remove(); // avoids a ConcurrentModificationException
        }

        if (displayNodes.size() > 0) {
            VBox vbox = new VBox();
            vbox.getChildren().addAll(displayNodes);
            contentLayout.setHeading(new Label(HAS_ALIAS_HEADING));
            contentLayout.setBody(vbox);
        } else {
            contentLayout.setHeading(new Label(NO_ALIAS_HEADING));
            contentLayout.setBody(new Label(NO_ALIAS_MESSAGE));
        }
    }

    public void show(Map<String, String> alias) {
        initialize(alias);
        super.show();
    }

    private Label createLabel(String alias, String command) {
        String text = String.format(ALIAS_LABEL_FORMAT, alias, command);
        Label label = new Label(text);
        return label;
    }
}
```
###### \java\utask\ui\helper\SuggestionHelper.java
``` java
    public List<String> getDefaultCommands() {
        List<String> defaultCommands = new ArrayList<String>();
        for (Entry<String, String> entry : suggestionMap.entrySet()) {
            String command = entry.getKey();
            defaultCommands.add(command);
        }
        return defaultCommands;
    }
```
###### \java\utask\ui\TaskListCard.java
``` java
    private String getPrettyDate(ReadOnlyTask task) {
        assert task != null;
        Date deadline = task.getDeadline().getDate();

        DateFormat fmt = new SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH);
        if (fmt.format(deadline).equals(fmt.format(new Date()))) {
            return fmt.format(deadline) + ", today";
        }

        if (task.getTimestamp().hasFrom()) {
            deadline = task.getTimestamp().getFrom();
        }

        PrettyTime p = new PrettyTime();
        return fmt.format(deadline) + ", " + p.format(deadline);
    }
```
