# A0138493W
###### \java\utask\commons\comparators\AscendingAlphabeticalComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending lexicographical order.
 */
public class AscendingAlphabeticalComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        return o1.getName().toString().compareTo(o2.getName().toString());
    }

}
```
###### \java\utask\commons\comparators\DescendingAlphabeticalComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in descending lexicographical order.
 */
public class DescendingAlphabeticalComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        return o2.getName().toString().compareTo(o1.getName().toString());
    }

}
```
###### \java\utask\commons\comparators\EarliestDeadlineComparator.java
``` java

package utask.commons.comparators;

import java.text.ParseException;
import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending dates.
 */
public class EarliestDeadlineComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        int preTime = 0;
        if (!o1.getDeadline().isEmpty()) {
            try {
                preTime = (int) (o1.getDeadline().getDate().getTime() / 1000);
            } catch (ParseException e) {
                assert false : "Should never come to this catch";
            }
        }

        int nextTime = 0;
        if (!o2.getDeadline().isEmpty()) {
            try {
                nextTime = (int) (o2.getDeadline().getDate().getTime() / 1000);
            } catch (ParseException e) {
                assert false : "Should never come to this catch";
            }
        }

        return preTime - nextTime;
    }
}
```
###### \java\utask\commons\comparators\LatestDeadlineComparator.java
``` java

package utask.commons.comparators;

import java.text.ParseException;
import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in descending dates.
 */
public class LatestDeadlineComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        int preTime = 0;
        if (!o1.getDeadline().isEmpty()) {
            try {
                preTime = (int) (o1.getDeadline().getDate().getTime() / 1000);
            } catch (ParseException e) {
                assert false : "Should never come to this catch";
            }
        }

        int nextTime = 0;
        if (!o2.getDeadline().isEmpty()) {
            try {
                nextTime = (int) (o2.getDeadline().getDate().getTime() / 1000);
            } catch (ParseException e) {
                assert false : "Should never come to this catch";
            }
        }

        return nextTime - preTime;
    }
}
```
###### \java\utask\commons\comparators\TagsNameComparator.java
``` java

package utask.commons.comparators;

import java.util.Comparator;

import utask.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending lexicographical Tag order.
 */
public class TagsNameComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask o1, ReadOnlyTask o2) {
        return o1.getTags().getFirstTagName().compareTo(o2.getTags().getFirstTagName());
    }

}
```
###### \java\utask\commons\util\ConfigUtil.java
``` java
    public static String getConfigPath() throws IOException {
        return Config.DEFAULT_CONFIG_FILE;
    }

}
```
###### \java\utask\logic\commands\AliasCommand.java
``` java

package utask.logic.commands;

import utask.logic.commands.exceptions.CommandException;

/*
 * Create an alias for a default command
 */
public class AliasCommand extends Command {

    public static final String COMMAND_WORD = "alias";
    public static final String COMMAND_FORMAT = "A /as B";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Create an alias for a command\n"
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " d /as delete";

    public static final String MESSAGE_CREATE_ALIAS_SUCCESS = "New alias %1$s added to command %2$s";
    public static final String MESSAGE_COMMAND_WORD_NOT_EXIST = "Command word %1$s is not exist";

    private final String alias;
    private final String defaultCommandWord;

    public AliasCommand(String alias, String defaultCommandWord) {
        this.defaultCommandWord = defaultCommandWord;
        this.alias = alias;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (!model.getDefaultCommandsSet().contains(defaultCommandWord)) {
            throw new CommandException(String.format(MESSAGE_COMMAND_WORD_NOT_EXIST, defaultCommandWord));
        }
        model.setAlias(alias, defaultCommandWord);
        return new CommandResult(String.format(MESSAGE_CREATE_ALIAS_SUCCESS, alias, defaultCommandWord));
    }

}
```
###### \java\utask\logic\commands\DeleteCommand.java
``` java
package utask.logic.commands;

import java.util.List;

import utask.commons.core.Messages;
import utask.logic.commands.exceptions.CommandException;
import utask.logic.commands.inteface.ReversibleCommand;
import utask.model.task.ReadOnlyTask;
import utask.model.task.Task;
import utask.model.task.UniqueTaskList.TaskNotFoundException;
import utask.staging.ui.helper.DelayedExecution;

/**
 * Deletes a task identified using it's last displayed index from the uTask.
 */
public class DeleteCommand extends Command implements ReversibleCommand {

    public static final String COMMAND_WORD = "delete";
    public static final String COMMAND_FORMAT = "INDEX (must be a positive integer)";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Tasks have been deleted";

    ReadOnlyTask taskToDelete;
    public final List<Integer> targetList;


    public DeleteCommand(List<Integer> targetList) {
        this.targetList = targetList;
    }

    @Override
    public CommandResult execute() throws CommandException {

        for (int targetIndex : targetList) {
            checkIfGivenIndexIsValid(targetIndex);
            taskToDelete = getTaskToDelete(targetIndex);

            //Do selection effect for 1 task only. It will cause race condition when doing multiple effect in a loop
            if (targetList.size() == 1) {
                notifyUI(taskToDelete);
                new DelayedExecution((e)-> {
                    deleteTask(taskToDelete);
                }).run();
            } else {
                deleteTask(taskToDelete);
            }
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS));
    }

    private void checkIfGivenIndexIsValid(int targetIndex) throws CommandException {
        if (model.getTotalSizeOfLists() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

    private void deleteTask(ReadOnlyTask taskToDelete) {
        try {
            model.deleteTask(taskToDelete);
            model.addUndoCommand(this);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
    }

    private ReadOnlyTask getTaskToDelete(int targetIndex) {
        //- 1 as helper method is using zero-based indexing
        List<ReadOnlyTask> list = model.getUnderlyingListByIndex(targetIndex - 1);

        int actualInt = model.getActualIndexFromDisplayIndex(targetIndex - 1);
        return list.get(actualInt);
    }

    @Override
    public void undo() throws Exception {
        model.addTask((Task) taskToDelete);
        notifyUI(taskToDelete);
    }

    @Override
    public void redo() throws Exception {
        notifyUI(taskToDelete);

        //Access to deleteTask() must be delayed to prevent race condition with notifyUI
        new DelayedExecution((e)-> {
            try {
                model.deleteTask(taskToDelete);
            } catch (TaskNotFoundException pnfe) {
                //This exception is handled as it is not possible to hit this exception with normal usage
                assert false : "The target task cannot be missing";
            }
        }).run();
    }

}
```
###### \java\utask\logic\commands\FindCommand.java
``` java
package utask.logic.commands;

import java.util.Set;

import utask.commons.core.EventsCenter;
import utask.commons.core.Messages;
import utask.staging.ui.events.FindRequestEvent;

/**
 * Finds and lists all tasks in uTask who contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";
    public static final String COMMAND_FORMAT = "KEYWORD [MORE_KEYWORDS]...";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks that contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " Monday"
            + "Press [ESC] to return";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        model.setIfFindOverlayShowing(true);
        EventsCenter.getInstance().post(new FindRequestEvent());
        return new CommandResult(String.format(Messages.MESSAGE_SEARCH_RESULTS, keywords.toString(),
                                                model.getFilteredTaskList().size()));
    }

}
```
###### \java\utask\logic\commands\RelocateCommand.java
``` java

package utask.logic.commands;
import utask.commons.core.EventsCenter;
import utask.staging.ui.events.FileRelocateEvent;

/**
 * Relocate the data file by the given location from user input
 */
public class RelocateCommand extends Command {

    public static final String COMMAND_WORD = "relocate";
    public static final String COMMAND_FORMAT = "[PATH (if not specify, relocate to \\data\\utask.xml)]";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": change the save file to a new data storage location \n"
            + "Parameters: " + COMMAND_FORMAT + " \n"
            + "Example: \n"
            + "For Windows: " + COMMAND_WORD + "C:\\full\\path\\to\\destination\n"
            + "For Mac: " + COMMAND_WORD + " /Users/your_username/full/path/to/destination";

    public static final String MESSAGE_RELOCATE_TASK_SUCCESS = "The data storage file has been relocated: %1$s";
    public static final String MESSAGE_INVALID_PATH = "The path entered is invalid";

    public static String destinationPath;
    private static final String DEFAULT_FOLDER_NAME = "data";

    /**
     * Relocate Command for relocating back to default location.
     * */
    public RelocateCommand() {
        this.destinationPath = DEFAULT_FOLDER_NAME;
    }

    /**
     * Relocate Command for relocating back to default location.
     * */
    public RelocateCommand(String path, boolean isValidPath) {
        if (isValidPath) {
            this.destinationPath = path;
        } else {
            this.destinationPath = DEFAULT_FOLDER_NAME;
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        EventsCenter.getInstance().post(new FileRelocateEvent(destinationPath));
        return new CommandResult(String.format(MESSAGE_RELOCATE_TASK_SUCCESS, destinationPath));
    }

}
```
###### \java\utask\logic\commands\SortCommand.java
``` java

package utask.logic.commands;

import utask.logic.commands.exceptions.CommandException;

/**
 * Sorts last displayed list from the uTask.
 */
public class SortCommand extends Command {

    public static final String COMMAND_WORD = "sort";
    public static final String COMMAND_FORMAT = "[SORTING_ORDER]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Sort tasks list with filters. "
            + "Parameters: " + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " earliest";

    public static final String MESSAGE_SUCCESS = "Tasks list has been sorted";

    private final String keywords;

    public SortCommand(String keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.sortFilteredTaskList(keywords);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\utask\logic\parser\AliasCommandParser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static utask.logic.parser.CliSyntax.PREFIX_ALIAS;

import java.util.Optional;

import utask.logic.commands.AliasCommand;
import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
/**
 * Parses input arguments and creates a new AliasCommand object
 */
public class AliasCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the AliasCommand
     * and returns an AliasCommand object for execution.
     */
    private static final String SPLITER_FOR_ALIAS = " /as";

    public Command parse(String args) {

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_ALIAS);
        argsTokenizer.tokenize(args);

        Optional<String> alias = ParserUtil.parseAlias(args.trim().split(SPLITER_FOR_ALIAS)[0]);
        if (alias.isPresent()) {
            return new AliasCommand(alias.get(), argsTokenizer.getValue(PREFIX_ALIAS).get());
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, AliasCommand.MESSAGE_USAGE));
    }
}
```
###### \java\utask\logic\parser\Parser.java
``` java
package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static utask.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.eventbus.Subscribe;

import utask.commons.core.EventsCenter;
import utask.commons.core.LogsCenter;
import utask.logic.commands.AliasCommand;
import utask.logic.commands.ClearCommand;
import utask.logic.commands.Command;
import utask.logic.commands.CreateCommand;
import utask.logic.commands.CreateTagCommand;
import utask.logic.commands.DeleteCommand;
import utask.logic.commands.DoneCommand;
import utask.logic.commands.ExitCommand;
import utask.logic.commands.FindCommand;
import utask.logic.commands.HelpCommand;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.ListCommand;
import utask.logic.commands.RedoCommand;
import utask.logic.commands.RelocateCommand;
import utask.logic.commands.SelectCommand;
import utask.logic.commands.SortCommand;
import utask.logic.commands.UndoCommand;
import utask.logic.commands.UndoneCommand;
import utask.logic.commands.UpdateCommand;
import utask.model.Model;
import utask.staging.ui.events.FindRequestEvent;
import utask.staging.ui.events.KeyboardEscapeKeyPressedEvent;
import utask.staging.ui.helper.SuggestionHelper;

/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private Model model;
    private final Logger logger = LogsCenter.getLogger(SuggestionHelper.class);
    private boolean showExpandedSort = false;

    public Parser(Model model) {
        this.model = model;
        EventsCenter.getInstance().registerHandler(this);
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        if (!isDeafultCommand(commandWord)) {
            commandWord = getDefaultCommand(commandWord);
        }
        switch (commandWord) {

        case CreateCommand.COMMAND_WORD:
            return new CreateCommandParser().parse(arguments);

        case AliasCommand.COMMAND_WORD:
            return new AliasCommandParser().parse(arguments);

        case UpdateCommand.COMMAND_WORD:
            return new UpdateCommandParser().parse(arguments);

        case DoneCommand.COMMAND_WORD:
            return new DoneCommandParser().parse(arguments);

        case UndoneCommand.COMMAND_WORD:
            return new UndoneCommandParser().parse(arguments);

        case SelectCommand.COMMAND_WORD:
            return new SelectCommandParser().parse(arguments);

        case SortCommand.COMMAND_WORD:
            if (showExpandedSort) {
                return new SortInFindCommandParser().parse(arguments);
            } else {
                return new SortCommandParser().parse(arguments);
            }

        case DeleteCommand.COMMAND_WORD:
            return new DeleteCommandParser().parse(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return new FindCommandParser().parse(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case UndoCommand.COMMAND_WORD:
            return new UndoCommandParser().parse(arguments);

        case RedoCommand.COMMAND_WORD:
            return new RedoCommandParser().parse(arguments);

        case RelocateCommand.COMMAND_WORD:
            return new RelocateCommandParser().parse(arguments);

        case CreateTagCommand.COMMAND_WORD:
            return new CreateTagCommandParser().parse(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }

    }

    /*
     * This method is used to detect if the command is default command
     */
    private boolean isDeafultCommand (String command) {
        return model.getDefaultCommandsSet().contains(command);
    }

    /*
     * This method is used to get default command if the command input is alias
     */
    private String getDefaultCommand (String command) {
        if (model.isAliasForDefaultCommandWord(command, CreateCommand.COMMAND_WORD)) {
            return CreateCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, AliasCommand.COMMAND_WORD)) {
            return AliasCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, UpdateCommand.COMMAND_WORD)) {
            return UpdateCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, DoneCommand.COMMAND_WORD)) {
            return DoneCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, UndoneCommand.COMMAND_WORD)) {
            return UndoneCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, SortCommand.COMMAND_WORD)) {
            return SortCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, DeleteCommand.COMMAND_WORD)) {
            return DeleteCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, ClearCommand.COMMAND_WORD)) {
            return ClearCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, FindCommand.COMMAND_WORD)) {
            return FindCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, ExitCommand.COMMAND_WORD)) {
            return ExitCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, HelpCommand.COMMAND_WORD)) {
            return HelpCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, UndoCommand.COMMAND_WORD)) {
            return UndoCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, RedoCommand.COMMAND_WORD)) {
            return RedoCommand.COMMAND_WORD;
        } else if (model.isAliasForDefaultCommandWord(command, RelocateCommand.COMMAND_WORD)) {
            return RelocateCommand.COMMAND_WORD;
        }
        return command;
    }

    @Subscribe
    private void handleFindRequestEvent(FindRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showExpandedSort = true;
    }

    @Subscribe
    private void handleKeyboardEscapeKeyPressedEvent(KeyboardEscapeKeyPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showExpandedSort = false;
    }
}
```
###### \java\utask\logic\parser\ParserUtil.java
``` java
    /**
     * Returns the indexes as a list in the {@code command} if it every index positive
     * unsigned integer Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<List<Integer>> parseMultiIndex(String command) {
        if (!isValidIndex(command.trim())) {
            return Optional.empty();
        }
        ArrayList<Integer> intIndexList = extractNumberFromInput(command);
        return Optional.of(getReversedSortedList(intIndexList));
    }

    /**
     * Returns ArrayList which contains not repeated input numbers
     */
    private static ArrayList<Integer> extractNumberFromInput(String command) {
        String[] splittedStringIndexes = command.trim().replace(" ", "").split(",");
        ArrayList<Integer> intIndexList = new ArrayList<Integer>();
        for (String index : splittedStringIndexes) {
            if (index.contains("to")) {
                String[] range = index.split("to");
                int start = Integer.parseInt(range[0]);
                int end = Integer.parseInt(range[1]);
                for (int i = start; i <= end; i++) {
                    if (!intIndexList.contains(i)) {
                        intIndexList.add(i);
                    }
                }
            } else {
                if (!intIndexList.contains(Integer.parseInt(index))) {
                    intIndexList.add(Integer.parseInt(index));
                }
            }
        }
        return intIndexList;
    }

    /**
     * Returns a sorted reversed ArrayList
     */
    private static ArrayList<Integer> getReversedSortedList(ArrayList<Integer> intIndexList) {
        Collections.sort(intIndexList);
        Collections.reverse(intIndexList);
        return intIndexList;
    }

    /**
     * Returns true if a given string is a valid input string.
     */
    private static boolean isValidIndex(String command) {
        assert command != null;
        final Matcher matcher = MULTI_INDEX_ARGS_FORMAT.matcher(command.trim());
        return matcher.matches();
    }

    /**
     * Returns true if a given string is a valid path.
     */
    public static boolean isPathValid(String command) {
        assert command != null;
        String os = System.getProperty("os.name");
        Matcher pathathMatcher = null;
        if (os.contains("Windows")) {
            pathathMatcher = WIN_PATH_FORMAT.matcher(command.trim());
        } else {
            pathathMatcher = MAC_PATH_FORMAT.matcher(command.trim());
        }
        return pathathMatcher.matches();
    }

    /**
     * Parse alias if it is a valid alias
     */
    public static Optional<String> parseAlias(String alias) {
        assert alias != null;
        final Matcher matcher = ALIAS_ARGS_FORMAT.matcher(alias.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        return Optional.of(alias);
    }
    //author

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty, or if the
     * list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

```
###### \java\utask\logic\parser\RelocateCommandParser.java
``` java

package utask.logic.parser;

import static utask.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import utask.logic.commands.Command;
import utask.logic.commands.IncorrectCommand;
import utask.logic.commands.RelocateCommand;

public class RelocateCommandParser {

    public Command parse(String args) {
        boolean isValidPath = ParserUtil.isPathValid(args);

        //default path
        if (args.equals("")) {
            return new RelocateCommand();
        }

        if (isValidPath) {
            return new RelocateCommand(args.trim(), true);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, RelocateCommand.MESSAGE_USAGE));
    }

}
```
###### \java\utask\logic\parser\SortCommandParser.java
``` java

package utask.logic.parser;

import utask.logic.commands.Command;
import utask.logic.commands.SortCommand;

/**
 * Parses input arguments and creates a new SortCommandParser object
 */
public class SortCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SortCommandParser
     * and returns an SortCommandParser object for execution.
     */
    public Command parse(String args) {
        //remove whitespace
        final String keyword =  args.replaceAll("\\s+", "");
        return new SortCommand(keyword);
    }

}
```
###### \java\utask\model\AliasMap.java
``` java

package utask.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

/*
 * Stores a HashMap of command maps aliases
 */
public class AliasMap {

    private HashMap<String, ArrayList<String>> commandToAliases;

    public AliasMap () {
        setDefaultAliasMapping();
    }

    /*
     * Set default aliases for command
     */
    public void setDefaultAliasMapping() {
        HashMap<String, ArrayList<String>> defaultAliasMap = getDefaultAliasMapping();
        commandToAliases = new HashMap<String, ArrayList<String>>();
        for (String key : defaultAliasMap.keySet()) {
            commandToAliases.put(key, defaultAliasMap.get(key));
        }
    }

    /*
     * Returns default map of commands to aliases as a HashMap
     */
    private HashMap<String, ArrayList<String>> getDefaultAliasMapping() {
        HashMap<String, ArrayList<String>> defaultAliasMap = new HashMap<String, ArrayList<String>>();
        defaultAliasMap.put("alias", new ArrayList<String>());
        defaultAliasMap.put("clear", new ArrayList<String>());
        defaultAliasMap.put("create", new ArrayList<String>());
        defaultAliasMap.put("delete", new ArrayList<String>());
        defaultAliasMap.put("done", new ArrayList<String>());
        defaultAliasMap.put("exit", new ArrayList<String>());
        defaultAliasMap.put("find", new ArrayList<String>());
        defaultAliasMap.put("help", new ArrayList<String>());
        defaultAliasMap.put("redo", new ArrayList<String>());
        defaultAliasMap.put("relocate", new ArrayList<String>());
        defaultAliasMap.put("sort", new ArrayList<String>());
        defaultAliasMap.put("undo", new ArrayList<String>());
        defaultAliasMap.put("undone", new ArrayList<String>());
        defaultAliasMap.put("update", new ArrayList<String>());
        return defaultAliasMap;
    }

    /*
     * Return all the default commands as a String Set
     */
    public Set<String> getDefaultCommandsSet() {
        return getDefaultAliasMapping().keySet();
    }

    /**
     * set a alias for a default command
     */
    public void setAlias(String alias, String command) {
        assert alias != null;
        assert(commandToAliases.get(command) != null);
        ArrayList<String> aliases = commandToAliases.get(command);
        aliases.add(alias);
        commandToAliases.replace(command, aliases);
    }

    /*
     * Return true if the input alias exists for the given defaultCommandWord
     */
    public boolean isAliasForDefaultCommandWord(String alias, String defaultCommandWord) {
        return commandToAliases.get(defaultCommandWord).contains(alias);
    }
}
```
###### \java\utask\model\Model.java
``` java
    public static final String SORT_ORDER_BY_EARLIEST_FIRST = "earliest";
    public static final String SORT_ORDER_BY_LATEST_FIRST = "latest";
    public static final String SORT_ORDER_BY_A_TO_Z = "az";
    public static final String SORT_ORDER_BY_Z_TO_A = "za";
    public static final String SORT_ORDER_BY_TAG = "tag";
    public static final String SORT_ORDER_DEFAULT = SORT_ORDER_BY_EARLIEST_FIRST;
    public static final String SORT_ORDER_ERROR = "Unable to sort due to unrecognized sorting order ";

    /** Clears existing backing model and replaces with the provided new data. */
    void resetData(ReadOnlyUTask newData);

    /** Returns the UTask */
    ReadOnlyUTask getUTask();

    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;

    /** Adds the given task */
    void addTask(Task task) throws UniqueTaskList.DuplicateTaskException;

```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public void sortFilteredTaskList(String sortingOrder) {
        assert sortingOrder != null;
        switch(sortingOrder) {
        case "": //default sorting order
            uTask.sortByComparator(new EarliestDeadlineComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_EARLIEST_FIRST:
            uTask.sortByComparator(new EarliestDeadlineComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_LATEST_FIRST:
            uTask.sortByComparator(new LatestDeadlineComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_A_TO_Z:
            uTask.sortByComparator(new AscendingAlphabeticalComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_Z_TO_A:
            uTask.sortByComparator(new DescendingAlphabeticalComparator());
            setSortingConfig(sortingOrder);
            break;

        case Model.SORT_ORDER_BY_TAG:
            uTask.sortByComparator(new TagsNameComparator());
            setSortingConfig(sortingOrder);
            break;

        default:
            logger.warning(Model.SORT_ORDER_ERROR + sortingOrder);
            break;
        }
        indicateUTaskChanged();
    }

    /*
     * This method is used to set user sorting configuration
     */
    private void setSortingConfig(String userConfig) {
        assert userConfig != null;
        logger.fine("The sorting order is set as " + userConfig);
        this.sortingConfig = userConfig;
    }
```
###### \java\utask\model\ModelManager.java
``` java
    private class FindQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        FindQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword)
                            || StringUtil.containsWordIgnoreCase(task.getDeadline().value, keyword)
                            || StringUtil.containsWordIgnoreCase(task.getTimestamp().value, keyword)
                            || StringUtil.containsWordIgnoreCase(task.getFrequency().value, keyword)
                            || StringUtil.containsWordIgnoreCase(task.getStatus().toString(), keyword)
                            || StringUtil.containsWordIgnoreCase(task.getTags().getAllTagNames(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### \java\utask\model\ModelManager.java
``` java
    @Override
    public Set<String> getDefaultCommandsSet() {
        return aliasMap.getDefaultCommandsSet();
    }

    @Override
    public void setAlias(String alias, String command) {
        aliasMap.setAlias(alias, command);
    }

    @Override
    public boolean isAliasForDefaultCommandWord(String alias, String defaultCommandWord) {
        return aliasMap.isAliasForDefaultCommandWord(alias, defaultCommandWord);
    }
}
```
###### \java\utask\model\task\Deadline.java
``` java
    /**
     * Returns deadline as date.
     *
     * @return date
     * @throws ParseException
     */
    public Date getDate() throws ParseException {
        assert value != null;

        DateFormat fmt = new SimpleDateFormat("ddMMyyyy");
        StringBuilder dateString = new StringBuilder(value);
        dateString.insert(4, "20");
        Date date = fmt.parse(dateString.toString());
        return date;
    }

```
###### \java\utask\model\UTask.java
``` java
    /**
     * Sort task by comparator
     */
    public void sortByComparator(Comparator<ReadOnlyTask> comparator) {
        assert comparator != null;
        FXCollections.sort(tasks.getInternalList(), comparator);
    }

```
###### \java\utask\model\util\SampleDataUtil.java
``` java

package utask.model.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Random;

import utask.model.ReadOnlyUTask;
import utask.model.UTask;
import utask.model.tag.Tag;
import utask.model.tag.TagColorIndex;
import utask.model.tag.TagName;
import utask.model.tag.UniqueTagList;
import utask.model.task.Deadline;
import utask.model.task.DeadlineTask;
import utask.model.task.EventTask;
import utask.model.task.FloatingTask;
import utask.model.task.Frequency;
import utask.model.task.Name;
import utask.model.task.Status;
import utask.model.task.Task;
import utask.model.task.Timestamp;
import utask.model.task.UniqueTaskList.DuplicateTaskException;

/**
 * This class is used to auto generate some sample data when data file is not exist
 * so far for demo and testing purpose, will generate 60 tasks in total
 */
public class SampleDataUtil {
    private static final String[] DAY_OF_WEEK = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    private static List<Task> sampleList = new ArrayList<Task>();

    /*
     * Return a List of Tasks generated by task generator
     */
    public static List<Task> getSampleTasks() {
        generateSampleTasks();
        return sampleList;
    }

    /*
     * Return sample UTask
     */
    public static ReadOnlyUTask getSampleUTask() {
        try {
            UTask sampleAB = new UTask();
            List<Task> sampleTaskList = getSampleTasks();
            for (Task sampleTask : sampleTaskList) {
                sampleAB.addTask(sampleTask);
            }
            return sampleAB;
        } catch (DuplicateTaskException e) {
            throw new AssertionError("sample data cannot contain duplicate persons", e);
        }
    }

    /*
     * This method is used to generate three different types of tasks
     */
    private static void generateSampleTasks() {
        for (int i = 1; i <= 20; i++) {
            try {
                sampleList.add(generateEventTaskWithSeed(i));
                sampleList.add(generateDeadlineTaskWithSeed(i));
                sampleList.add(generateFloatingTaskWithSeed(i));
            } catch (Exception e) {
                assert false : "sample data cannot be invalid";
            }
        }
    }

    /*
     * This method is used to generate sample Event task
     */
    private static Task generateEventTaskWithSeed(int seed) throws Exception {
        return new EventTask(new Name("Event Task " + seed),
                new Deadline(generateDeadline(seed)), new Timestamp("0000 to 2359"),
                new Frequency("Every " + randomFrequency()),
                new UniqueTagList(new Tag(
                        new TagName("tag" + Math.abs(seed)),
                        new TagColorIndex("2")),
                        new Tag(new TagName("tag" + Math.abs(seed + 1)),
                        new TagColorIndex("8"))),
                new Status("no"));
    }

    /*
     * This method is used to generate sample Deadline task
     */
    private static Task generateDeadlineTaskWithSeed(int seed) throws Exception {
        return new DeadlineTask(new Name("Deadline Task " + seed),
                new Deadline(generateDeadline(seed)),
                new Frequency("Every " + randomFrequency()),
                new UniqueTagList(new Tag(
                        new TagName("tag" + Math.abs(seed)),
                        new TagColorIndex("2")),
                        new Tag(new TagName("tag" + Math.abs(seed + 1)),
                        new TagColorIndex("8"))),
                new Status("no"));
    }

    /*
     * This method is used to generate sample Floating task
     */
    private static Task generateFloatingTaskWithSeed(int seed) throws Exception {
        return new FloatingTask(new Name("Floating Task " + seed),
                new Frequency("Every " + randomFrequency()),
                new UniqueTagList(new Tag(
                        new TagName("tag" + Math.abs(seed)),
                        new TagColorIndex("2")),
                        new Tag(new TagName("tag" + Math.abs(seed + 1)),
                        new TagColorIndex("8"))),
                new Status("no"));
    }

    /*
     * This method is used to generate different deadlines
     */
    private static String generateDeadline(int i) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(new Date());
        calendar.add(Calendar.DATE, (-10 + i));
        DateFormat fmt = new SimpleDateFormat("ddMMyy");
        return fmt.format(calendar.getTime());
    }

    /*
     * This method is used to random a number for different frequency
     * make the sample data more realistic
     */
    private static String randomFrequency() {
        Random randomGenerator = new Random();
        return DAY_OF_WEEK[randomGenerator.nextInt(6)];
    }
}
```
###### \java\utask\staging\ui\events\FileRelocateEvent.java
``` java

package utask.staging.ui.events;

import utask.commons.events.BaseEvent;

/**
 * Indicates the path when relocate data storage file
 */
public class FileRelocateEvent extends BaseEvent {

    private String path;

    public FileRelocateEvent(String path) {
        this.path = path;
    }

    public String getPath() {
        return path;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\utask\staging\ui\StageDriver.java
``` java
    @Subscribe
    private void handleFileRelocateEvent(FileRelocateEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        String prePath = config.getUTaskFilePath();
        //Update config file and storage the changed file location
        config.setUTaskFilePath(event.getPath() + DEAFULT_FILE_NAME);
        storage.setFilePath(event.getPath() + DEAFULT_FILE_NAME);
        try {
            ConfigUtil.saveConfig(config, ConfigUtil.getConfigPath());
            storage.moveSaveFile(prePath, event.getPath() + DEAFULT_FILE_NAME);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### \java\utask\staging\ui\UTTaskListCard.java
``` java
    private String getPrettyDate(ReadOnlyTask task) {
        assert task != null;
        Date deadline = null;
        try {
            deadline = task.getDeadline().getDate();
        } catch (ParseException e) {
            assert false : "Should never have parse error, regex should check input";
        }
        DateFormat fmt = new SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH);
        if (fmt.format(deadline).equals(fmt.format(new Date()))) {
            return fmt.format(deadline) + ", today";
        }
        PrettyTime p = new PrettyTime();
        return fmt.format(deadline) + ", " + p.format(deadline);
    }
```
###### \java\utask\storage\StorageManager.java
``` java
    /*
     * This method is used to move the data file from old path to new path which is entered by relocate command
     * Exception will be thrown if cannot move the file
     */
    @Override
    public void moveSaveFile(String prePath, String newPath) {
        assert prePath != null;
        assert newPath != null;
        try {
            File oldFile = new File(prePath);
            if (oldFile.exists() && !oldFile.isDirectory()) {
                File newFile = new File(newPath);
                newFile.getParentFile().mkdirs();
                Files.move(oldFile.toPath(), newFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
                logger.fine("The file has been moved to new location: " + newPath);
            }
        } catch (IOException e) {
            logger.info("Failed to move the data file: " + StringUtil.getDetails(e));
        }
    }

```
